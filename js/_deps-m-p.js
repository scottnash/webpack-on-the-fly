window.modules["12"] = [function(require,module,exports){;(function(){
'use strict';

var auth0 = require(7);

module.exports = {
  props: ['linkIcon'],
  data: function data() {
    return {
      appMeta: null
    };
  },
  computed: {
    hasPCDAccount: function hasPCDAccount() {
      return this.appMeta && this.appMeta.has_pcd_subscription;
    },
    planName: function planName() {
      var appMeta = this.appMeta,
          hasPCDAccount = appMeta && appMeta.has_pcd_subscription,
          hasPrintAndDigitalAccount = hasPCDAccount && appMeta.pcd_account_type === 'both',
          hasDigitalPCDAccount = hasPCDAccount && appMeta.pcd_account_type === 'digital',
          hasAppleAccount = appMeta && appMeta.has_apple_subscription,
          hasGoogleAccount = appMeta && appMeta.has_google_subscription,
          hasEmployeeAccount = appMeta && appMeta.has_staff_subscription;

      if (hasPrintAndDigitalAccount) {
        return 'Print and Digital';
      } else if (hasDigitalPCDAccount || hasAppleAccount || hasGoogleAccount) {
        return 'Digital';
      } else if (hasEmployeeAccount) {
        return 'Employee Account';
      } else {
        return 'Other';
      }
    },
    accountNumber: function accountNumber() {
      var appMeta = this.appMeta,
          hasPCDAccount = appMeta && appMeta.has_pcd_subscription,
          hasPCDAccountNumber = appMeta && appMeta.pcd_account_number,
          hasAppleAccount = appMeta && appMeta.has_apple_subscription,
          hasGoogleAccount = appMeta && appMeta.has_google_subscription;

      if (hasPCDAccount && hasPCDAccountNumber) {
        return appMeta.pcd_account_number;
      } else if (hasAppleAccount) {
        return 'N/A (iTunes Subscription)';
      } else if (hasGoogleAccount) {
        return 'N/A (Android Subscription)';
      } else {
        return 'N/A';
      }
    }
  },
  created: function created() {
    var _this = this;

    this.appMeta = auth0.getAppMetadata();
    auth0.on('init login logout', function () {
      _this.appMeta = auth0.getAppMetadata();
    });
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"account-body"},[_c('div',{staticClass:"account-field"},[_c('div',{staticClass:"account-field-label"},[_vm._v("Your Plan")]),_vm._v(" "),_c('div',{staticClass:"account-field-value"},[_vm._v(_vm._s(_vm.planName))])]),_vm._v(" "),_c('div',{staticClass:"account-field"},[_c('div',{staticClass:"account-field-label"},[_vm._v("Account Number")]),_vm._v(" "),_c('div',{staticClass:"account-field-value"},[_vm._v(_vm._s(_vm.accountNumber))])]),_vm._v(" "),(_vm.hasPCDAccount)?_c('a',{staticClass:"account-link",attrs:{"href":"https://nym.pcdfusion.com/pcd/CustomerSupport/App/13277","target":"_blank"}},[_c('span',{staticClass:"account-link-text"},[_vm._v("Manage Plan")]),_vm._v(" "),_c('span',{staticClass:"account-link-icon",domProps:{"innerHTML":_vm._s(_vm.linkIcon)}})]):_vm._e(),_vm._v(" "),(_vm.hasPCDAccount)?_c('p',{staticClass:"account-input-help"},[_vm._v("* You will be prompted to enter your subscription information again")]):_vm._e(),_vm._v(" "),(_vm.hasPCDAccount)?_c('p',{staticClass:"account-message"},[_c('strong',[_vm._v("Need additional assistance?")]),_vm._v(" Call us at 1-800-678-0900.\n  ")]):_vm._e()])}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require(10)
  hotAPI.install(require(8), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-90c93d8e", __vue__options__)
  } else {
    hotAPI.reload("data-v-90c93d8e", __vue__options__)
  }
})()}}, {"7":7,"8":8,"10":10}];
window.modules["15"] = [function(require,module,exports){;(function(){
'use strict';

module.exports = {
  props: {
    showCloseButton: Boolean
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"account-modal-overlay"},[_c('div',{staticClass:"account-modal"},[(_vm.showCloseButton)?_c('button',{staticClass:"account-modal-close",attrs:{"type":"button"},on:{"click":function($event){_vm.$parent.$emit('close')}}},[_c('svg',{attrs:{"width":"18","height":"18","viewBox":"0 0 18 18","xmlns":"http://www.w3.org/2000/svg"}},[_c('title',[_vm._v("Combined Shape")]),_vm._v(" "),_c('path',{attrs:{"d":"M9 7.78L16.78 0 18 1.22 10.22 9 18 16.78 16.78 18 9 10.22 1.22 18 0 16.78 7.78 9 0 1.22 1.22 0 9 7.78z","fill":"#000","fill-rule":"nonzero"}})])]):_vm._e(),_vm._v(" "),_c('div',{staticClass:"account-modal-body"},[_vm._t("header"),_vm._v(" "),_vm._t("body")],2)])])}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require(10)
  hotAPI.install(require(8), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7a536bdc", __vue__options__)
  } else {
    hotAPI.reload("data-v-7a536bdc", __vue__options__)
  }
})()}}, {"8":8,"10":10}];
window.modules["21"] = [function(require,module,exports){;(function(){
'use strict';

var auth0 = require(7);

module.exports = {
  data: function data() {
    return {
      success: false,
      error: ''
    };
  },
  computed: {
    viewState: function viewState() {
      if (this.success) {
        return 'success';
      }

      if (this.error) {
        return 'error';
      }

      return 'initial';
    },
    email: function email() {
      return auth0.getEmail() || 'nowhere';
    }
  },
  methods: {
    resetPassword: function resetPassword() {
      var _this = this;

      return auth0.triggerPasswordReset(this.email).then(function () {
        return _this.success = true;
      }).catch(function (err) {
        return _this.error = String(err);
      });
    }
  },
  components: {
    modal: require(15)
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('modal',{attrs:{"showCloseButton":true}},[(_vm.viewState === 'initial')?[_c('h3',{staticClass:"account-modal-header",attrs:{"slot":"header"},slot:"header"},[_vm._v("Reset Your Password")]),_vm._v(" "),_c('template',{slot:"body"},[_c('p',{staticClass:"account-modal-text"},[_vm._v("Are you sure you want to reset your password? We will email a password reset link to "+_vm._s(_vm.email)+".")]),_vm._v(" "),_c('div',{staticClass:"account-modal-buttons"},[_c('button',{staticClass:"account-button-filled",attrs:{"type":"submit"},on:{"click":function($event){$event.stopPropagation();$event.preventDefault();return _vm.resetPassword($event)}}},[_vm._v("Confirm")]),_vm._v(" "),_c('button',{staticClass:"account-button-outlined",attrs:{"type":"button"},on:{"click":function($event){_vm.$emit('close')}}},[_vm._v("Cancel")])])])]:_vm._e(),_vm._v(" "),(_vm.viewState === 'error')?[_c('p',{staticClass:"account-modal-error-text",attrs:{"slot":"body"},slot:"body"},[_vm._v(_vm._s(_vm.error))]),_vm._v(" "),_c('template',{slot:"dismiss"},[_c('button',{staticClass:"account-modal-close",attrs:{"type":"button"},domProps:{"innerHTML":_vm._s(_vm.closeIcon)},on:{"click":function($event){_vm.$emit('close')}}})])]:_vm._e(),_vm._v(" "),(_vm.viewState === 'success')?_c('template',{slot:"body"},[_c('p',{staticClass:"account-modal-success-text"},[_vm._v("An email has been sent to "+_vm._s(_vm.email)+" with instructions to update your password.")]),_vm._v(" "),_c('button',{staticClass:"account-button-filled account-button-wide",attrs:{"type":"button"},on:{"click":function($event){_vm.$emit('close')}}},[_vm._v("Done")])]):_vm._e()],2)}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require(10)
  hotAPI.install(require(8), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-46511a6e", __vue__options__)
  } else {
    hotAPI.reload("data-v-46511a6e", __vue__options__)
  }
})()}}, {"7":7,"8":8,"10":10,"15":15}];
window.modules["13"] = [function(require,module,exports){;(function(){
'use strict';

var auth0 = require(7);

module.exports = {
  props: {
    editIcon: {
      type: String,
      required: true
    }
  },
  data: function data() {
    return {
      email: '',
      username: '',
      modal: ''
    };
  },
  methods: {
    openModal: function openModal() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      this.modal = name;
    },
    closeModal: function closeModal() {
      this.modal = '';
    }
  },
  created: function created() {
    var _this = this;

    var email = auth0.getEmail(),
        username = auth0.getUserMetadata() && auth0.getUserMetadata().username;
    this.email = email || '';
    this.username = username || '';
    auth0.on('init login logout', function () {
      _this.email = auth0.getEmail();
      _this.username = auth0.getUserMetadata() && auth0.getUserMetadata().username;
    });
  },
  components: {
    password: require(21)
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"account-body"},[_c('div',{staticClass:"account-field"},[_c('div',{staticClass:"account-field-label"},[_vm._v("Email")]),_vm._v(" "),_c('div',{staticClass:"account-field-value"},[_vm._v(_vm._s(_vm.email))])]),_vm._v(" "),_c('div',{staticClass:"account-field"},[_c('div',{staticClass:"account-field-label"},[_vm._v("Password")]),_vm._v(" "),_c('div',{staticClass:"account-field-value"},[_vm._v("**********")]),_vm._v(" "),_c('a',{staticClass:"account-field-edit",on:{"click":function($event){_vm.openModal('password')}}},[_c('span',{staticClass:"account-field-edit-logo",domProps:{"innerHTML":_vm._s(_vm.editIcon)}}),_vm._v(" "),_c('span',{staticClass:"account-field-edit-text"},[_vm._v("Reset")])])]),_vm._v(" "),_c('div',{staticClass:"account-field account-field-username"},[_c('div',{staticClass:"account-field-label"},[_vm._v("Username")]),_vm._v(" "),_c('div',{staticClass:"account-field-value"},[_vm._v(_vm._s(_vm.username))])]),_vm._v(" "),_c('transition',{attrs:{"name":"fade"}},[(_vm.modal==='password')?_c('password',{attrs:{"close":_vm.closeModal,"closeIcon":_vm.closeIcon},on:{"close":_vm.closeModal}}):_vm._e()],1)],1)}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require(10)
  hotAPI.install(require(8), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-32575bce", __vue__options__)
  } else {
    hotAPI.reload("data-v-32575bce", __vue__options__)
  }
})()}}, {"7":7,"8":8,"10":10,"21":21}];
window.modules["97"] = [function(require,module,exports){'use strict'; // this is a big regex that matches everything embedly knows about that ISN'T a video provider
// generated from http://embed.ly/tools/generator
// note: embedly doesn't know about twitter, so we added it manually

module.exports.match = function (url) {
  return url.match(/((http:\/\/(www\.flickr\.com\/photos\/.*|flic\.kr\/.*|polaroidswing\.com\/p\/.*|momento360\.com\/e\/u\/.*|https\?:\/\/kuula\.co\/post\/.*|.*imgur\.com\/.*|i.*\.photobucket\.com\/albums\/.*|s.*\.photobucket\.com\/albums\/.*|media\.photobucket\.com\/image\/.*|www\.mobypicture\.com\/user\/.*\/view\/.*|moby\.to\/.*|xkcd\.com\/.*|www\.xkcd\.com\/.*|imgs\.xkcd\.com\/.*|www\.asofterworld\.com\/index\.php\?id=.*|www\.asofterworld\.com\/.*\.jpg|asofterworld\.com\/.*\.jpg|www\.qwantz\.com\/index\.php\?comic=.*|23hq\.com\/.*\/photo\/.*|www\.23hq\.com\/.*\/photo\/.*|.*dribbble\.com\/shots\/.*|drbl\.in\/.*|.*\.smugmug\.com\/.*|.*\.smugmug\.com\/.*#.*|img\.ly\/.*|www\.tinypic\.com\/view\.php.*|tinypic\.com\/view\.php.*|www\.tinypic\.com\/player\.php.*|tinypic\.com\/player\.php.*|www\.tinypic\.com\/r\/.*\/.*|tinypic\.com\/r\/.*\/.*|.*\.tinypic\.com\/.*\.jpg|.*\.tinypic\.com\/.*\.png|meadd\.com\/.*\/.*|meadd\.com\/.*|.*\.deviantart\.com\/art\/.*|.*\.deviantart\.com\/gallery\/.*|.*\.deviantart\.com\/#\/.*|fav\.me\/.*|.*\.deviantart\.com|.*\.deviantart\.com\/gallery|.*\.deviantart\.com\/.*\/.*\.jpg|.*\.deviantart\.com\/.*\/.*\.gif|.*\.deviantart\.net\/.*\/.*\.jpg|.*\.deviantart\.net\/.*\/.*\.gif|www\.fotopedia\.com\/.*\/.*|fotopedia\.com\/.*\/.*|photozou\.jp\/photo\/show\/.*\/.*|photozou\.jp\/photo\/photo_only\/.*\/.*|instagr\.am\/p\/.*|instagram\.com\/p\/.*|www\.instagram\.com\/p\/.*|skitch\.com\/.*\/.*\/.*|img\.skitch\.com\/.*|www\.questionablecontent\.net\/|questionablecontent\.net\/|www\.questionablecontent\.net\/view\.php.*|questionablecontent\.net\/view\.php.*|questionablecontent\.net\/comics\/.*\.png|www\.questionablecontent\.net\/comics\/.*\.png|twitrpix\.com\/.*|.*\.twitrpix\.com\/.*|www\.someecards\.com\/.*\/.*|someecards\.com\/.*\/.*|some\.ly\/.*|www\.some\.ly\/.*|pikchur\.com\/.*|achewood\.com\/.*|www\.achewood\.com\/.*|achewood\.com\/index\.php.*|www\.achewood\.com\/index\.php.*|www\.whosay\.com\/.*\/content\/.*|www\.whosay\.com\/.*\/photos\/.*|www\.whosay\.com\/.*\/videos\/.*|say\.ly\/.*|ow\.ly\/i\/.*|mlkshk\.com\/p\/.*|d\.pr\/i\/.*|www\.eyeem\.com\/p\/.*|www\.eyeem\.com\/a\/.*|www\.eyeem\.com\/u\/.*|giphy\.com\/gifs\/.*|gph\.is\/.*|frontback\.me\/p\/.*|www\.frontback\.me\/p\/.*|www\.fotokritik\.com\/.*\/.*|fotokritik\.com\/.*\/.*|vid\.me\/.*|galeri\.uludagsozluk\.com\/.*|gfycat\.com\/.*|tochka\.net\/.*|.*\.tochka\.net\/.*|4cook\.net\/recipe\/.*|www\.alphahat\.com\/view\/.*|alphahat\.com\/view\/.*|futurism\.com\/images\/.*|superstack\.io\/v\/.*|gist\.github\.com\/.*|producthunt\.com\/.*|www\.slideshare\.net\/.*\/.*|www\.slideshare\.net\/mobile\/.*\/.*|.*\.slideshare\.net\/.*\/.*|slidesha\.re\/.*|scribd\.com\/doc\/.*|www\.scribd\.com\/doc\/.*|scribd\.com\/mobile\/documents\/.*|www\.scribd\.com\/mobile\/documents\/.*|upscri\.be\/.*|contentupgrade\.me\/.*|screenr\.com\/.*|pollshare\.com\/poll\/.*|polldaddy\.com\/community\/poll\/.*|polldaddy\.com\/poll\/.*|answers\.polldaddy\.com\/poll\/.*|www\.howcast\.com\/videos\/.*|www\.screencast\.com\/.*\/media\/.*|screencast\.com\/.*\/media\/.*|www\.screencast\.com\/t\/.*|screencast\.com\/t\/.*|issuu\.com\/.*\/docs\/.*|www\.kickstarter\.com\/projects\/.*\/.*|www\.scrapblog\.com\/viewer\/viewer\.aspx.*|foursquare\.com\/.*|www\.foursquare\.com\/.*|4sq\.com\/.*|linkedin\.com\/in\/.*|linkedin\.com\/pub\/.*|.*\.linkedin\.com\/in\/.*|.*\.linkedin\.com\/pub\/.*|linkedin\.com\/in\/.*|linkedin\.com\/company\/.*|.*\.linkedin\.com\/company\/.*|www\.sliderocket\.com\/.*|sliderocket\.com\/.*|app\.sliderocket\.com\/.*|portal\.sliderocket\.com\/.*|beta-sliderocket\.com\/.*|www\.yelp\.com\/.*&hrid=\.+|www\.sociale\.co\/question\/.*|www\.genial\.ly\/.*|maps\.google\.com\/maps\?.*|maps\.google\.com\/\?.*|maps\.google\.com\/maps\/ms\?.*|www\.google\..*\/maps\/.*|google\..*\/maps\/.*|.*\.alpacamaps\.com\/.*|graphcommons\.com\/graphs\/.*|graphcommons\.com\/nodes\/.*|https\?:\/\/infogr\.am\/.*|datawrapper\.dwcdn\.net\/.*|embed\.kumu\.io|embed\.kumu\.io|my\.opera\.com\/.*\/albums\/show\.dml\?id=.*|my\.opera\.com\/.*\/albums\/showpic\.dml\?album=.*&picture=.*|tumblr\.com\/.*|.*\.tumblr\.com\/post\/.*|www\.polleverywhere\.com\/polls\/.*|www\.polleverywhere\.com\/multiple_choice_polls\/.*|www\.polleverywhere\.com\/free_text_polls\/.*|www\.quantcast\.com\/wd:.*|www\.quantcast\.com\/.*|siteanalytics\.compete\.com\/.*|.*\.status\.net\/notice\/.*|identi\.ca\/notice\/.*|myloc\.me\/.*|pastebin\.com\/.*|pastie\.org\/.*|www\.pastie\.org\/.*|redux\.com\/stream\/item\/.*\/.*|redux\.com\/f\/.*\/.*|www\.redux\.com\/stream\/item\/.*\/.*|www\.redux\.com\/f\/.*\/.*|cl\.ly\/.*|cl\.ly\/.*\/content|speakerdeck\.com\/.*\/.*|www\.kiva\.org\/lend\/.*|www\.timetoast\.com\/timelines\/.*|storify\.com\/.*\/.*|.*meetup\.com\/.*|meetu\.ps\/.*|www\.dailymile\.com\/people\/.*\/entries\/.*|.*\.kinomap\.com\/.*|www\.metacdn\.com\/r\/c\/.*\/.*|www\.metacdn\.com\/r\/m\/.*\/.*|prezi\.com\/.*\/.*|.*\.uservoice\.com\/.*\/suggestions\/.*|www\.wikipedia\.org\/wiki\/.*|.*\.wikipedia\.org\/wiki\/.*|www\.wikimedia\.org\/wiki\/File.*|360\.io\/.*|www\.behance\.net\/gallery\/.*|behance\.net\/gallery\/.*|www\.jdsupra\.com\/legalnews\/.*|jdsupra\.com\/legalnews\/.*|minilogs\.com\/.*|www\.minilogs\.com\/.*|jsfiddle\.net\/.*|ponga\.com\/.*|list\.ly\/list\/.*|crowdmap\.com\/post\/.*|.*\.crowdmap\.com\/post\/.*|crowdmap\.com\/map\/.*|.*\.crowdmap\.com\/map\/.*|ifttt\.com\/recipes\/.*|weavly\.com\/watch\/.*|www\.weavly\.com\/watch\/.*|tagmotion\.com\/tree\/.*|www\.tagmotion\.com\/tree\/.*|public\.talely\.com\/.*\/.*|polarb\.com\/.*|.*\.polarb\.com\/.*|on\.bubb\.li\/.*|bubb\.li\/.*|.*\.bubb\.li\/.*|embed\.imajize\.com\/.*|giflike\.com\/a\/.*|www\.giflike\.com\/a\/.*|i\.giflike\.com\/.*|rapidengage\.com\/s\/.*|infomous\.com\/node\/.*|stepic\.org\/.*|chirb\.it\/.*|beta\.polstir\.com\/.*\/.*|polstir\.com\/.*\/.*|www\.gettyimages\.com\/detail\/photo\/.*|gty\.im\/.*|www\.gettyimages\.com\/license\/.*|isnare\.com\/.*|www\.isnare\.com\/.*|www\.branchtrack\.com\/projects\/.*|jsbin\.com\/.*\/.*|jsbin\.com\/.*|wedgi\.es\/.*|public\.chartblocks\.com\/c\/.*|radd\.it\/r\/.*|radd\.it\/comments\/.*|radd\.it\/user\/.*|radd\.it\/playlists\/.*|radd\.it\/magic\/.*|vibi\.com\/videocard\/.*|kastio\.com\/webcasts\/.*|.*\.kastio\.com\/webcasts\/.*|megavisor\.com\/view\/.*|megavisor\.com\/en\/view\/.*|bunkrapp\.com\/.*\/.*|.*\.cartodb\.com\/.*\/.*|flowvella\.com\/s\/.*|fr\.peoplbrain\.com\/tutoriaux\/.*|codepicnic\.com\/bites\/.*|codepicnic\.com\/consoles\/.*|tr\.instela\.com\/.*|codepen\.io\/.*\/pen\/.*|codepen\.io\/.*\/pen\/.*|runelm\.io\/.*\/.*|www\.vtility\.net\/virtualtour\/.*|quora\.com\/.*\/answer\/.*|www\.quora\.com\/.*\/answer\/.*|tunein\.com\/.*|tun\.in\/.*|scribblemaps\.com\/maps\/view\/.*\/.*|www\.scribblemaps\.com\/maps\/view\/.*\/.*|www\.codeply\.com\/view\/.*|codeply\.com\/view\/.*|www\.candybank\.com\/.*|flat\.io\/score\/.*|www\.qzzr\.com\/quiz\/.*|shorti\.com\/.*|www\.shorti\.com\/.*|blab\.im\/.*|pollplug\.com\/poll\/.*|alpha\.vrchive\.com\/.*|vrchive\.com\/.*|www\.globalgiving\.org\/projects\/.*|www\.globalgiving\.org\/funds\/.*|www\.globalgiving\.org\/microprojects\/.*|www\.newhive\.com\/.*\/.*|slidr\.io\/.*\/.*|publons\.com\/author\/.*|www\.publons\.com\/author\/.*|calameo\.com\/.*|www\.calameo\.com\/.*|relayto\.com\/.*|www\.relayto\.com\/.*|www\.graphiq\.com\/w\/.*|graphiq\.com\/w\/.*|w\.graphiq\.com\/w\/.*|view\.stacker\.cc\/.*|content\.newsbound\.com\/.*\/.*|.*\.silk\.co\/explore\/.*|docs\.com\/.*|rocketium\.com\/.*|cdn\.knightlab\.com\/libs\/timeline3\/.*|cdn\.knightlab\.com\/libs\/juxtapose\/.*|uploads\.knightlab\.com\/storymapjs\/.*\/index\.html|www\.thelastgraph\.com\/lg\.php\?a=.*|thelastgraph\.com\/lg\.php\?a=.*|rogertalk\.com\/.*|www\.rogertalk\.com\/.*|stackshare\.io\/.*|www\.stackshare\.io\/.*|maphubs\.com\/user\/.*\/map\/.*|www\.maphubs\.com\/user\/.*\/map\/.*|braid\.io\/embed-tile\/.*|www\.braid\.io\/embed-tile\/.*|talkshow\.im\/show\/.*|www\.talkshow\.im\/show\/.*|medibang\.com\/sv\/.*|www\.medibang\.com\/sv\/.*|redivis\.com\/r\/.*|www\.redivis\.com\/r\/.*|my\.webboards\.fr\/.*|cooler\.tv\/.*|mathembed\.com\/latex.*|minko\.io\/s\/|campaign\.theheartstringsproject\.com\/.*|www\.altizure\.com\/project\/.*|exploratory\.io\/viz\/.*|esplor\.io\/.*|www\.pastery\.net\/.*|hardbound\.co\/.*\/.*\/.*|mybeweeg\.com\/w\/.*|storribook\.com\/articles\/view\/.*\/.*|sidewire\.com\/.*\/.*\/.*|codiva\.io\/p\/.*|www\.codiva\.io\/p\/.*|www\.fwdeveryone\.com\/t\/.*|fwdeveryone\.com\/t\/.*|app\.wizer\.me\/learn\/.*|app\.wizer\.me\/preview\/.*|kidoju\.com\/.*|.*\.razoo\.com\/.*|eyrie\.io\/.*|verse\.com\/stories\/.*|www\.moviemogul\.io\/.*|walkinto\.in\/.*\/.*|.*\.walkinto\.in\/.*\/.*|spaces\.archilogic\.com\/model\/.*|spaces\.archilogic\.com\/3d\/.*|ellie-app\.com\/.*\/.*|www\.maprosoft\.com\/app\/map.*|www\.gradba\.se\/v\/.*|cincopa\.com\/~.*|.*\.cincopa\.com\/watch\/.*|vr3d\.vn\/.*|lcontacts\.herokuapp\.com\/embed\/button\/.*|vrbfoto\.com\/f\/.*|orbitvu\.com\/001\/.*|www\.amazon\.com\/gp\/product\/.*|www\.amazon\.com\/.*\/dp\/.*|www\.amazon\.com\/o\/ASIN\/.*|www\.amazon\.com\/gp\/offer-listing\/.*|www\.amazon\.com\/.*\/ASIN\/.*|www\.amazon\.com\/gp\/aw\/d\/.*|amazon\.com\/gp\/product\/.*|amazon\.com\/.*\/dp\/.*|amazon\.com\/o\/ASIN\/.*|amazon\.com\/gp\/offer-listing\/.*|amazon\.com\/.*\/ASIN\/.*|amazon\.com\/gp\/aw\/d\/.*|www\.amazon\.cn\/gp\/product\/.*|www\.amazon\.cn\/.*\/dp\/.*|www\.amazon\.cn\/o\/ASIN\/.*|www\.amazon\.cn\/gp\/offer-listing\/.*|www\.amazon\.cn\/.*\/ASIN\/.*|www\.amazon\.cn\/gp\/aw\/d\/.*|amazon\.cn\/gp\/product\/.*|amazon\.cn\/.*\/dp\/.*|amazon\.cn\/o\/ASIN\/.*|amazon\.cn\/gp\/offer-listing\/.*|amazon\.cn\/.*\/ASIN\/.*|amazon\.cn\/gp\/aw\/d\/.*|www\.amazon\.in\/gp\/product\/.*|www\.amazon\.in\/.*\/dp\/.*|www\.amazon\.in\/o\/ASIN\/.*|www\.amazon\.in\/gp\/offer-listing\/.*|www\.amazon\.in\/.*\/ASIN\/.*|www\.amazon\.in\/gp\/aw\/d\/.*|amazon\.in\/gp\/product\/.*|amazon\.in\/.*\/dp\/.*|amazon\.in\/o\/ASIN\/.*|amazon\.in\/gp\/offer-listing\/.*|amazon\.in\/.*\/ASIN\/.*|amazon\.in\/gp\/aw\/d\/.*|www\.amazon\.co\.jp\/gp\/product\/.*|www\.amazon\.co\.jp\/.*\/dp\/.*|www\.amazon\.co\.jp\/o\/ASIN\/.*|www\.amazon\.co\.jp\/gp\/offer-listing\/.*|www\.amazon\.co\.jp\/.*\/ASIN\/.*|www\.amazon\.co\.jp\/gp\/aw\/d\/.*|amazon\.co\.jp\/gp\/product\/.*|amazon\.co\.jp\/.*\/dp\/.*|amazon\.co\.jp\/o\/ASIN\/.*|amazon\.co\.jp\/gp\/offer-listing\/.*|amazon\.co\.jp\/.*\/ASIN\/.*|amazon\.co\.jp\/gp\/aw\/d\/.*|www\.amazon\.fr\/gp\/product\/.*|www\.amazon\.fr\/.*\/dp\/.*|www\.amazon\.fr\/o\/ASIN\/.*|www\.amazon\.fr\/gp\/offer-listing\/.*|www\.amazon\.fr\/.*\/ASIN\/.*|www\.amazon\.fr\/gp\/aw\/d\/.*|amazon\.fr\/gp\/product\/.*|amazon\.fr\/.*\/dp\/.*|amazon\.fr\/o\/ASIN\/.*|amazon\.fr\/gp\/offer-listing\/.*|amazon\.fr\/.*\/ASIN\/.*|amazon\.fr\/gp\/aw\/d\/.*|www\.amazon\.de\/gp\/product\/.*|www\.amazon\.de\/.*\/dp\/.*|www\.amazon\.de\/o\/ASIN\/.*|www\.amazon\.de\/gp\/offer-listing\/.*|www\.amazon\.de\/.*\/ASIN\/.*|www\.amazon\.de\/gp\/aw\/d\/.*|amazon\.de\/gp\/product\/.*|amazon\.de\/.*\/dp\/.*|amazon\.de\/o\/ASIN\/.*|amazon\.de\/gp\/offer-listing\/.*|amazon\.de\/.*\/ASIN\/.*|amazon\.de\/gp\/aw\/d\/.*|www\.amazon\.es\/gp\/product\/.*|www\.amazon\.es\/.*\/dp\/.*|www\.amazon\.es\/o\/ASIN\/.*|www\.amazon\.es\/gp\/offer-listing\/.*|www\.amazon\.es\/.*\/ASIN\/.*|www\.amazon\.es\/gp\/aw\/d\/.*|amazon\.es\/gp\/product\/.*|amazon\.es\/.*\/dp\/.*|amazon\.es\/o\/ASIN\/.*|amazon\.es\/gp\/offer-listing\/.*|amazon\.es\/.*\/ASIN\/.*|amazon\.es\/gp\/aw\/d\/.*|www\.amazon\.it\/gp\/product\/.*|www\.amazon\.it\/.*\/dp\/.*|www\.amazon\.it\/o\/ASIN\/.*|www\.amazon\.it\/gp\/offer-listing\/.*|www\.amazon\.it\/.*\/ASIN\/.*|www\.amazon\.it\/gp\/aw\/d\/.*|amazon\.it\/gp\/product\/.*|amazon\.it\/.*\/dp\/.*|amazon\.it\/o\/ASIN\/.*|amazon\.it\/gp\/offer-listing\/.*|amazon\.it\/.*\/ASIN\/.*|amazon\.it\/gp\/aw\/d\/.*|www\.amazon\.co\.uk\/gp\/product\/.*|www\.amazon\.co\.uk\/.*\/dp\/.*|www\.amazon\.co\.uk\/o\/ASIN\/.*|www\.amazon\.co\.uk\/gp\/offer-listing\/.*|www\.amazon\.co\.uk\/.*\/ASIN\/.*|www\.amazon\.co\.uk\/gp\/aw\/d\/.*|amazon\.co\.uk\/gp\/product\/.*|amazon\.co\.uk\/.*\/dp\/.*|amazon\.co\.uk\/o\/ASIN\/.*|amazon\.co\.uk\/gp\/offer-listing\/.*|amazon\.co\.uk\/.*\/ASIN\/.*|amazon\.co\.uk\/gp\/aw\/d\/.*|www\.amazon\.ca\/gp\/product\/.*|www\.amazon\.ca\/.*\/dp\/.*|www\.amazon\.ca\/o\/ASIN\/.*|www\.amazon\.ca\/gp\/offer-listing\/.*|www\.amazon\.ca\/.*\/ASIN\/.*|www\.amazon\.ca\/gp\/aw\/d\/.*|amazon\.ca\/gp\/product\/.*|amazon\.ca\/.*\/dp\/.*|amazon\.ca\/o\/ASIN\/.*|amazon\.ca\/gp\/offer-listing\/.*|amazon\.ca\/.*\/ASIN\/.*|amazon\.ca\/gp\/aw\/d\/.*|www\.amazon\.com\.mx\/gp\/product\/.*|www\.amazon\.com\.mx\/.*\/dp\/.*|www\.amazon\.com\.mx\/o\/ASIN\/.*|www\.amazon\.com\.mx\/gp\/offer-listing\/.*|www\.amazon\.com\.mx\/.*\/ASIN\/.*|www\.amazon\.com\.mx\/gp\/aw\/d\/.*|amazon\.com\.mx\/gp\/product\/.*|amazon\.com\.mx\/.*\/dp\/.*|amazon\.com\.mx\/o\/ASIN\/.*|amazon\.com\.mx\/gp\/offer-listing\/.*|amazon\.com\.mx\/.*\/ASIN\/.*|amazon\.com\.mx\/gp\/aw\/d\/.*|www\.amazon\.com\.au\/gp\/product\/.*|www\.amazon\.com\.au\/.*\/dp\/.*|www\.amazon\.com\.au\/o\/ASIN\/.*|www\.amazon\.com\.au\/gp\/offer-listing\/.*|www\.amazon\.com\.au\/.*\/ASIN\/.*|www\.amazon\.com\.au\/gp\/aw\/d\/.*|amazon\.com\.au\/gp\/product\/.*|amazon\.com\.au\/.*\/dp\/.*|amazon\.com\.au\/o\/ASIN\/.*|amazon\.com\.au\/gp\/offer-listing\/.*|amazon\.com\.au\/.*\/ASIN\/.*|amazon\.com\.au\/gp\/aw\/d\/.*|www\.amazon\.com\.br\/gp\/product\/.*|www\.amazon\.com\.br\/.*\/dp\/.*|www\.amazon\.com\.br\/o\/ASIN\/.*|www\.amazon\.com\.br\/gp\/offer-listing\/.*|www\.amazon\.com\.br\/.*\/ASIN\/.*|www\.amazon\.com\.br\/gp\/aw\/d\/.*|amazon\.com\.br\/gp\/product\/.*|amazon\.com\.br\/.*\/dp\/.*|amazon\.com\.br\/o\/ASIN\/.*|amazon\.com\.br\/gp\/offer-listing\/.*|amazon\.com\.br\/.*\/ASIN\/.*|amazon\.com\.br\/gp\/aw\/d\/.*|www\.amzn\.com\/.*|amzn\.com\/.*|shoplocket\.com\/products\/.*|etsy\.com\/.*|www\.etsy\.com\/.*|fiverr\.com\/.*\/.*|www\.fiverr\.com\/.*\/.*|kit\.com\/.*|soundcloud\.com\/.*|soundcloud\.com\/.*\/.*|soundcloud\.com\/.*\/sets\/.*|soundcloud\.com\/groups\/.*|snd\.sc\/.*|open\.spotify\.com\/.*|spoti\.fi\/.*|play\.spotify\.com\/.*|www\.last\.fm\/music\/.*|www\.last\.fm\/music\/+videos\/.*|www\.last\.fm\/music\/+images\/.*|www\.last\.fm\/music\/.*\/_\/.*|www\.last\.fm\/music\/.*\/.*|www\.simplecast\.com\/s\/.*|www\.changelog\.com\/.*|www\.megafono\.io\/.*|www\.mixcloud\.com\/.*\/.*\/|play\.radiopublic\.com\/.*|www\.hark\.com\/clips\/.*|www\.rdio\.com\/#\/artist\/.*\/album\/.*|www\.rdio\.com\/artist\/.*\/album\/.*|www\.zero-inch\.com\/.*|.*\.bandcamp\.com\/|.*\.bandcamp\.com\/track\/.*|.*\.bandcamp\.com\/album\/.*|freemusicarchive\.org\/music\/.*|www\.freemusicarchive\.org\/music\/.*|freemusicarchive\.org\/curator\/.*|www\.freemusicarchive\.org\/curator\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/templates\/story\/story\.php.*|huffduffer\.com\/.*\/.*|audioboom\.com\/posts\/.*|www\.audioboom\.com\/boos\/.*|audioboom\.com\/boos\/.*|boo\.fm\/b.*|www\.xiami\.com\/song\/.*|xiami\.com\/song\/.*|www\.saynow\.com\/playMsg\.html.*|www\.saynow\.com\/playMsg\.html.*|grooveshark\.com\/.*|radioreddit\.com\/songs.*|www\.radioreddit\.com\/songs.*|radioreddit\.com\/\?q=songs.*|www\.radioreddit\.com\/\?q=songs.*|www\.gogoyoko\.com\/song\/.*|hypem\.com\/premiere\/.*|bop\.fm\/s\/.*\/.*|clyp\.it\/.*|www\.dnbradio\.com\/.*|dnbradio\.com\/.*|anchor\.fm\/.*|bumpers\.fm\/e\/.*|buzzsprout\.com\/.*|.*\.buzzsprout\.com\/.*|60db\.co\/story\/.*|allihoopa\.com\/s\/.*|vizamp\.com\/player\/.*|www\.vizamp\.com\/player\/.*|tapewrite\.com\/.*|player\.megaphone\.fm\/.*|cms\.megaphone\.fm\/.*|play\.soundsgood\.co\/.*|.*\.sparemin\.com\/myrecording|.*\.sparemin\.com\/recording-.*))|(https:\/\/(www\.flickr\.com\/photos\/.*|flic\.kr\/.*|polaroidswing\.com\/p\/.*|momento360\.com\/e\/u\/.*|.*imgur\.com\/.*|www\.instagram\.com\/p\/.*|skitch\.com\/.*\/.*\/.*|img\.skitch\.com\/.*|frontback\.me\/p\/.*|www\.frontback\.me\/p\/.*|vidd\.me\/.*|vid\.me\/.*|gfycat\.com\/.*|.*\.accredible\.com\/.*|accredible\.com\/.*|futurism\.com\/images\/.*|superstack\.io\/v\/.*|www\.pexels\.com\/photo\/.*|gist\.github\.com\/.*|producthunt\.com\/.*|www\.slideshare\.net\/.*\/.*|www\.slideshare\.net\/mobile\/.*\/.*|.*\.slideshare\.net\/.*\/.*|slidesha\.re\/.*|scribd\.com\/doc\/.*|www\.scribd\.com\/doc\/.*|scribd\.com\/mobile\/documents\/.*|www\.scribd\.com\/mobile\/documents\/.*|scribd\.com\/documents\/.*|www\.scribd\.com\/documents\/.*|upscri\.be\/.*|contentupgrade\.me\/.*|pollshare\.com\/poll\/.*|www\.getwhichit\.com\/page\/.*|issuu\.com\/.*\/docs\/.*|www\.kickstarter\.com\/projects\/.*\/.*|foursquare\.com\/.*|www\.foursquare\.com\/.*|linkedin\.com\/in\/.*|linkedin\.com\/pub\/.*|.*\.linkedin\.com\/in\/.*|.*\.linkedin\.com\/pub\/.*|linkedin\.com\/in\/.*|linkedin\.com\/company\/.*|.*\.linkedin\.com\/company\/.*|www\.yelp\.com\/.*&hrid=\.+|www\.sociale\.co\/question\/.*|www\.genial\.ly\/.*|maps\.google\.com\/maps\?.*|maps\.google\.com\/\?.*|maps\.google\.com\/maps\/ms\?.*|www\.google\..*\/maps\/.*|google\..*\/maps\/.*|.*\.alpacamaps\.com\/.*|graphcommons\.com\/graphs\/.*|graphcommons\.com\/nodes\/.*|datawrapper\.dwcdn\.net\/.*|tumblr\.com\/.*|.*\.tumblr\.com\/post\/.*|pastebin\.com\/.*|speakerdeck\.com\/.*\/.*|storify\.com\/.*\/.*|.*meetup\.com\/.*|meetu\.ps\/.*|www\.wikipedia\.org\/wiki\/.*|.*\.wikipedia\.org\/wiki\/.*|www\.wikimedia\.org\/wiki\/File.*|urtak\.com\/u\/.*|urtak\.com\/clr\/.*|ganxy\.com\/.*|www\.ganxy\.com\/.*|sketchfab\.com\/models\/.*|sketchfab\.com\/show\/.*|ifttt\.com\/recipes\/.*|cloudup\.com\/.*|rapidengage\.com\/s\/.*|stepic\.org\/.*|readtapestry\.com\/s\/.*\/|chirb\.it\/.*|www\.gettyimages\.com\/detail\/photo\/.*|gty\.im\/.*|www\.gettyimages\.com\/license\/.*|www\.branchtrack\.com\/projects\/.*|www\.wedgies\.com\/question\/.*|public\.chartblocks\.com\/c\/.*|megavisor\.com\/view\/.*|megavisor\.com\/en\/view\/.*|bunkrapp\.com\/.*\/.*|.*\.cartodb\.com\/.*\/.*|flowvella\.com\/s\/.*|fr\.peoplbrain\.com\/tutoriaux\/.*|codepicnic\.com\/bites\/.*|codepicnic\.com\/consoles\/.*|tr\.instela\.com\/.*|runelm\.io\/.*\/.*|quora\.com\/.*\/answer\/.*|www\.quora\.com\/.*\/answer\/.*|tunein\.com\/.*|tun\.in\/.*|scribblemaps\.com\/maps\/view\/.*\/.*|www\.scribblemaps\.com\/maps\/view\/.*\/.*|marvelapp\.com\/.*|www\.flat\.io\/score\/.*|www\.qzzr\.com\/quiz\/.*|blab\.im\/.*|glitter\.club\/.*|pollplug\.com\/poll\/.*|alpha\.vrchive\.com\/.*|vrchive\.com\/.*|www\.globalgiving\.org\/projects\/.*|www\.globalgiving\.org\/funds\/.*|www\.globalgiving\.org\/microprojects\/.*|www\.newhive\.com\/.*\/.*|newhive\.com\/.*\/.*|newhive\.com\/.*\/.*|slidr\.io\/.*\/.*|publons\.com\/author\/.*|www\.publons\.com\/author\/.*|calameo\.com\/.*|www\.calameo\.com\/.*|relayto\.com\/.*|www\.relayto\.com\/.*|www\.graphiq\.com\/w\/.*|graphiq\.com\/w\/.*|w\.graphiq\.com\/w\/.*|view\.stacker\.cc\/.*|content\.newsbound\.com\/.*\/.*|projects\.invisionapp\.com\/share\/.*|invis\.io\/.*|.*\.silk\.co\/explore\/.*|docs\.com\/.*|sway\.com\/.*|publicgood\.com\/campaign\/.*|publicgood\.com\/org\/.*|publicgood\.com\/org\/.*\/campaign\/.*|airtable\.com\/shr.*|rocketium\.com\/.*|cdn\.knightlab\.com\/libs\/timeline3\/.*|cdn\.knightlab\.com\/libs\/juxtapose\/.*|rogertalk\.com\/.*|www\.rogertalk\.com\/.*|maphubs\.com\/user\/.*\/map\/.*|www\.maphubs\.com\/user\/.*\/map\/.*|braid\.io\/embed-tile\/.*|www\.braid\.io\/embed-tile\/.*|talkshow\.im\/show\/.*|www\.talkshow\.im\/show\/.*|medibang\.com\/sv\/.*|www\.medibang\.com\/sv\/.*|redivis\.com\/r\/.*|www\.redivis\.com\/r\/.*|my\.webboards\.fr\/.*|my\.matterport\.com\/show\/.*|cooler\.tv\/.*|mathembed\.com\/latex.*|minko\.io\/s\/|campaign\.theheartstringsproject\.com\/.*|www\.altizure\.com\/project\/.*|exploratory\.io\/viz\/.*|maps\.mysidewalk\.com\/.*|esplor\.io\/.*|www\.pastery\.net\/.*|hardbound\.co\/.*\/.*\/.*|mybeweeg\.com\/w\/.*|storribook\.com\/articles\/view\/.*\/.*|sidewire\.com\/.*\/.*\/.*|codiva\.io\/p\/.*|www\.codiva\.io\/p\/.*|www\.fwdeveryone\.com\/t\/.*|fwdeveryone\.com\/t\/.*|app\.wizer\.me\/learn\/.*|app\.wizer\.me\/preview\/.*|kidoju\.com\/.*|.*\.razoo\.com\/.*|eyrie\.io\/.*|verse\.com\/stories\/.*|www\.canva\.com\/design\/.*|www\.moviemogul\.io\/.*|powered\.by\.rabbut\.com\/p\/.*|walkinto\.in\/.*\/.*|.*\.walkinto\.in\/.*\/.*|spaces\.archilogic\.com\/model\/.*|spaces\.archilogic\.com\/3d\/.*|api\.peptone\.io\/v1\/visualize\/.*|www\.highly\.co\/hl\/.*|.*\.uplabs\.com\/posts\/.*|ellie-app\.com\/.*\/.*|www\.maprosoft\.com\/app\/map.*|www\.gradba\.se\/v\/.*|cincopa\.com\/~.*|.*\.cincopa\.com\/watch\/.*|lcontacts\.herokuapp\.com\/embed\/button\/.*|vrbfoto\.com\/f\/.*|orbitvu\.com\/001\/.*|www\.ipushpull\.com\/pages\/domains\/.*\/pages\/.*|ipushpull\.com\/pages\/domains\/.*\/pages\/.*|app\.very\.gd\/p\/.*|www\.icloud\.com\/keynote\/.*|icloud\.com\/keynote\/.*|www\.iorad\.com\/player\/.*|iorad\.com\/player\/.*|etsy\.com\/.*|www\.etsy\.com\/.*|kit\.com|soundcloud\.com\/.*|soundcloud\.com\/.*\/.*|soundcloud\.com\/.*\/sets\/.*|soundcloud\.com\/groups\/.*|open\.spotify\.com\/.*|play\.spotify\.com\/.*|www\.last\.fm\/music\/.*|www\.last\.fm\/music\/+videos\/.*|www\.last\.fm\/music\/+images\/.*|www\.last\.fm\/music\/.*\/_\/.*|www\.last\.fm\/music\/.*\/.*|www\.simplecast\.com\/s\/.*|www\.changelog\.com\/.*|www\.megafono\.io\/.*|play\.radiopublic\.com\/.*|www\.rdio\.com\/#\/artist\/.*\/album\/.*|www\.rdio\.com\/artist\/.*\/album\/.*|.*\.bandcamp\.com\/|.*\.bandcamp\.com\/track\/.*|.*\.bandcamp\.com\/album\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/templates\/story\/story\.php.*|audioboom\.com\/posts\/.*|bop\.fm\/s\/.*\/.*|bop\.fm\/p\/.*|bop\.fm\/a\/.*|clyp\.it\/.*|sfx\.io\/.*|anchor\.fm\/.*|bumpers\.fm\/e\/.*|buzzsprout\.com\/.*|.*\.buzzsprout\.com\/.*|60db\.co\/story\/.*|allihoopa\.com\/s\/.*|vizamp\.com\/player\/.*|www\.vizamp\.com\/player\/.*|art19\.com\/shows\/.*\/episodes\/.*|tapewrite\.com\/.*|player\.megaphone\.fm\/.*|cms\.megaphone\.fm\/.*|play\.soundsgood\.co\/.*|.*\.sparemin\.com\/myrecording|.*\.sparemin\.com\/recording-.*)))/i) || url.match(/twitter\.com/i);
};
}, {}];
window.modules["156"] = [function(require,module,exports){"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* jshint ignore:start */

/* eslint-disable */
// start https://mixpanel.com/help/reference/javascript
// sourced on 2016-09-28
// has slight modification as indicated below
(function (e, a) {
  if (!a.__SV) {
    var b = window;

    try {
      var c,
          l,
          i,
          j = b.location,
          g = j.hash;

      c = function c(a, b) {
        return (l = a.match(RegExp(b + "=([^&]*)"))) ? l[1] : null;
      };

      g && c(g, "state") && (i = JSON.parse(decodeURIComponent(c(g, "state"))), "mpeditor" === i.action && (b.sessionStorage.setItem("_mpcehash", g), history.replaceState(i.desiredHash || "", e.title, j.pathname + j.search)));
    } catch (m) {}

    var k, h;
    window.mixpanel = a;
    a._i = [];

    a.init = function (b, c, f) {
      function e(b, a) {
        var c = a.split(".");
        2 == c.length && (b = b[c[0]], a = c[1]);

        b[a] = function () {
          b.push([a].concat(Array.prototype.slice.call(arguments, 0)));
        };
      }

      var d = a;
      "undefined" !== typeof f ? d = a[f] = [] : f = "mixpanel";
      d.people = d.people || [];

      d.toString = function (b) {
        var a = "mixpanel";
        "mixpanel" !== f && (a += "." + f);
        b || (a += " (stub)");
        return a;
      };

      d.people.toString = function () {
        return d.toString(1) + ".people (stub)";
      };

      k = "disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");

      for (h = 0; h < k.length; h++) {
        e(d, k[h]);
      }

      a._i.push([b, c, f]);
    };

    a.__SV = 1.2;
    /* replaced these lines as we are not using their ajax
    b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)
    */

    loadAfterInit(); // added this line
  }
})(document, window.mixpanel || []); // end https://mixpanel.com/help/reference/javascript
// wrap in function so that it runs after mixpanel.init


function loadAfterInit() {
  // start http://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js
  // sourced 2016-09-28
  (function () {
    var m = !0,
        n = null,
        r = !1;

    function B() {
      return function () {};
    }

    (function () {
      function V(a) {
        function b() {
          try {
            a.F = a.F || {}, a.F.$__c = (a.F.$__c || 0) + 1, c.cookie.set("mp_" + d + "__c", a.F.$__c, 1, m);
          } catch (b) {
            k.error(b);
          }
        }

        var d = a.c("name");
        a.F = a.F || {};
        a.F.$__c = parseInt(c.cookie.get("mp_" + d + "__c")) || 0;
        c.o(document, "submit", b);
        c.o(document, "change", b);
        var e = n;
        c.o(document, "mousedown", function (a) {
          e = a.target;
        });
        c.o(document, "mouseup", function (a) {
          a.target === e && b();
        });
      }

      function W() {
        function a() {
          if (!a.Zc) Q = a.Zc = m, R = r, c.a(y, function (a) {
            a.oc();
          });
        }

        function b() {
          try {
            document.documentElement.doScroll("left");
          } catch (d) {
            setTimeout(b, 1);
            return;
          }

          a();
        }

        if (document.addEventListener) "complete" === document.readyState ? a() : document.addEventListener("DOMContentLoaded", a, r);else if (document.attachEvent) {
          document.attachEvent("onreadystatechange", a);
          var d = r;

          try {
            d = window.frameElement === n;
          } catch (e) {}

          document.documentElement.doScroll && d && b();
        }
        c.o(window, "load", a, m);
      }

      function X() {
        s.init = function (a, b, d) {
          if (d) return s[d] || (s[d] = y[d] = H(a, b, d), s[d].sa()), s[d];
          d = s;
          if (y.mixpanel) d = y.mixpanel;else if (a) d = H(a, b, "mixpanel"), d.sa(), y.mixpanel = d;
          s = d;
          1 === L && (window.mixpanel = s);
          Y();
        };
      }

      function Y() {
        c.a(y, function (a, b) {
          "mixpanel" !== b && (s[b] = a);
        });
        s._ = c;
      }

      function H(a, b, d) {
        var e,
            g = "mixpanel" === d ? s : s[d];
        if (g && 0 === L) e = g;else {
          if (g && !c.isArray(g)) {
            k.error("You have already initialized " + d);
            return;
          }

          e = new h();
        }
        e.Na(a, b, d);
        e.people = new p();
        e.people.Na(e);
        z = z || e.c("debug");
        e.__autotrack_enabled = e.c("autotrack");

        if (e.c("autotrack")) {
          C.$c(e.c("token"), 100, 100) ? C.ed() ? C.U(e) : (e.__autotrack_enabled = r, k.log("Disabling Automatic Event Collection because this browser is not supported")) : (e.__autotrack_enabled = r, k.log("Not in active bucket: disabling Automatic Event Collection."));

          try {
            V(e);
          } catch (j) {
            k.error(j);
          }
        }

        !c.d(g) && c.isArray(g) && (e.Ka.call(e.people, g.people), e.Ka(g));
        return e;
      }

      function p() {}

      function h() {}

      function o(a) {
        this.props = {};
        this.Eb = r;
        this.name = a.persistence_name ? "mp_" + a.persistence_name : "mp_" + a.token + "_mixpanel";
        var b = a.persistence;
        if ("cookie" !== b && "localStorage" !== b) k.ca("Unknown persistence type " + b + "; falling back to cookie"), b = a.persistence = "cookie";

        if (b = "localStorage" === b) {
          b = m;

          try {
            c.localStorage.set("__mplssupport__", "xyz"), "xyz" !== c.localStorage.get("__mplssupport__") && (b = r), c.localStorage.remove("__mplssupport__");
          } catch (d) {
            b = r;
          }

          b || k.error("localStorage unsupported; falling back to cookie store");
        }

        this.w = b ? c.localStorage : c.cookie;
        this.load();
        this.cc(a);
        this.Fd(a);
        this.save();
      }

      function I() {
        this.Tb = "submit";
      }

      function D() {
        this.Tb = "click";
      }

      function x() {}

      var z = r,
          w;
      w = "undefined" === typeof window ? {
        navigator: {}
      } : window;
      var M = Array.prototype,
          S = Object.prototype,
          E = M.slice,
          G = S.toString,
          J = S.hasOwnProperty,
          u = w.console,
          F = w.navigator,
          v = w.document,
          t = F.userAgent,
          N = Function.prototype.bind,
          T = M.forEach,
          U = M.indexOf;
      w = Array.isArray;
      var O = {},
          c = {
        trim: function trim(a) {
          return a.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
        }
      },
          k = {
        log: function log() {
          if (z && !c.d(u) && u) try {
            u.log.apply(u, arguments);
          } catch (a) {
            c.a(arguments, function (a) {
              u.log(a);
            });
          }
        },
        error: function error() {
          if (z && !c.d(u) && u) {
            var a = ["Mixpanel error:"].concat(c.ja(arguments));

            try {
              u.error.apply(u, a);
            } catch (b) {
              c.a(a, function (a) {
                u.error(a);
              });
            }
          }
        },
        ca: function ca() {
          if (!c.d(u) && u) {
            var a = ["Mixpanel error:"].concat(c.ja(arguments));

            try {
              u.error.apply(u, a);
            } catch (b) {
              c.a(a, function (a) {
                u.error(a);
              });
            }
          }
        }
      };

      c.bind = function (a, b) {
        var d, _e;

        if (N && a.bind === N) return N.apply(a, E.call(arguments, 1));
        if (!c.ab(a)) throw new TypeError();
        d = E.call(arguments, 2);
        return _e = function e() {
          if (!(this instanceof _e)) return a.apply(b, d.concat(E.call(arguments)));
          var c = {};
          c.prototype = a.prototype;
          var j = new c();
          c.prototype = n;
          c = a.apply(j, d.concat(E.call(arguments)));
          return Object(c) === c ? c : j;
        };
      };

      c.Cb = function (a) {
        for (var b in a) {
          "function" === typeof a[b] && (a[b] = c.bind(a[b], a));
        }
      };

      c.a = function (a, b, d) {
        if (!(a === n || void 0 === a)) if (T && a.forEach === T) a.forEach(b, d);else if (a.length === +a.length) for (var c = 0, g = a.length; c < g && !(c in a && b.call(d, a[c], c, a) === O); c++) {
          ;
        } else for (c in a) {
          if (J.call(a, c) && b.call(d, a[c], c, a) === O) break;
        }
      };

      c.u = function (a) {
        a && c.bb(a) && (a = a.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"));
        return a;
      };

      c.extend = function (a) {
        c.a(E.call(arguments, 1), function (b) {
          for (var d in b) {
            void 0 !== b[d] && (a[d] = b[d]);
          }
        });
        return a;
      };

      c.isArray = w || function (a) {
        return "[object Array]" === G.call(a);
      };

      c.ab = function (a) {
        try {
          return /^\s*\bfunction\b/.test(a);
        } catch (b) {
          return r;
        }
      };

      c.dd = function (a) {
        return !(!a || !J.call(a, "callee"));
      };

      c.ja = function (a) {
        return !a ? [] : a.ja ? a.ja() : c.isArray(a) || c.dd(a) ? E.call(a) : c.Hd(a);
      };

      c.Hd = function (a) {
        var b = [];
        if (a === n) return b;
        c.a(a, function (a) {
          b[b.length] = a;
        });
        return b;
      };

      c.Nd = function (a) {
        return a;
      };

      c.Lb = function (a, b) {
        var d = r;
        if (a === n) return d;
        if (U && a.indexOf === U) return -1 != a.indexOf(b);
        c.a(a, function (a) {
          if (d || (d = a === b)) return O;
        });
        return d;
      };

      c.g = function (a, b) {
        return -1 !== a.indexOf(b);
      };

      c.Nb = function (a, b) {
        a.prototype = new b();
        a.zd = b.prototype;
      };

      c.j = function (a) {
        return a === Object(a) && !c.isArray(a);
      };

      c.V = function (a) {
        if (c.j(a)) {
          for (var b in a) {
            if (J.call(a, b)) return r;
          }

          return m;
        }

        return r;
      };

      c.d = function (a) {
        return void 0 === a;
      };

      c.bb = function (a) {
        return "[object String]" == G.call(a);
      };

      c.fd = function (a) {
        return "[object Date]" == G.call(a);
      };

      c.hd = function (a) {
        return "[object Number]" == G.call(a);
      };

      c.gd = function (a) {
        return !!(a && 1 === a.nodeType);
      };

      c.Ib = function (a) {
        c.a(a, function (b, d) {
          c.fd(b) ? a[d] = c.ad(b) : c.j(b) && (a[d] = c.Ib(b));
        });
        return a;
      };

      c.timestamp = function () {
        Date.now = Date.now || function () {
          return +new Date();
        };

        return Date.now();
      };

      c.ad = function (a) {
        function b(a) {
          return 10 > a ? "0" + a : a;
        }

        return a.getUTCFullYear() + "-" + b(a.getUTCMonth() + 1) + "-" + b(a.getUTCDate()) + "T" + b(a.getUTCHours()) + ":" + b(a.getUTCMinutes()) + ":" + b(a.getUTCSeconds());
      };

      c.l = function (a) {
        return function () {
          try {
            return a.apply(this, arguments);
          } catch (b) {
            k.ca("Implementation error. Please contact support@mixpanel.com.");
          }
        };
      };

      c.od = function (a) {
        for (var b = ["identify", "_check_and_handle_notifications", "_show_notification"], d = 0; d < b.length; d++) {
          a.prototype[b[d]] = c.l(a.prototype[b[d]]);
        }
      };

      c.pd = function (a) {
        for (var b in a) {
          "function" === typeof a[b] && (a[b] = c.l(a[b]));
        }
      };

      c.za = function (a) {
        var b = {};
        c.a(a, function (a, e) {
          c.bb(a) && 0 < a.length && (b[e] = a);
        });
        return b;
      };

      c.truncate = function (a, b) {
        var d;
        "string" === typeof a ? d = a.slice(0, b) : c.isArray(a) ? (d = [], c.a(a, function (a) {
          d.push(c.truncate(a, b));
        })) : c.j(a) ? (d = {}, c.a(a, function (a, g) {
          d[g] = c.truncate(a, b);
        })) : d = a;
        return d;
      };

      c.na = function () {
        return function (a) {
          function b(a, c) {
            var j = "",
                l = 0,
                i = l = "",
                i = 0,
                f = j,
                h = [],
                q = c[a];
            q && "object" === _typeof(q) && "function" === typeof q.toJSON && (q = q.toJSON(a));

            switch (_typeof(q)) {
              case "string":
                return d(q);

              case "number":
                return isFinite(q) ? "" + q : "null";

              case "boolean":
              case "null":
                return "" + q;

              case "object":
                if (!q) return "null";
                j += "    ";
                h = [];

                if ("[object Array]" === G.apply(q)) {
                  i = q.length;

                  for (l = 0; l < i; l += 1) {
                    h[l] = b(l, q) || "null";
                  }

                  return i = 0 === h.length ? "[]" : j ? "[\n" + j + h.join(",\n" + j) + "\n" + f + "]" : "[" + h.join(",") + "]";
                }

                for (l in q) {
                  J.call(q, l) && (i = b(l, q)) && h.push(d(l) + (j ? ": " : ":") + i);
                }

                return i = 0 === h.length ? "{}" : j ? "{" + h.join(",") + "" + f + "}" : "{" + h.join(",") + "}";
            }
          }

          function d(a) {
            var b = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                d = {
              "\b": "\\b",
              "\t": "\\t",
              "\n": "\\n",
              "\f": "\\f",
              "\r": "\\r",
              '"': '\\"',
              "\\": "\\\\"
            };
            b.lastIndex = 0;
            return b.test(a) ? '"' + a.replace(b, function (a) {
              var b = d[a];
              return "string" === typeof b ? b : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' : '"' + a + '"';
          }

          return b("", {
            "": a
          });
        };
      }();

      c.ma = function () {
        function a() {
          switch (i) {
            case "t":
              return g("t"), g("r"), g("u"), g("e"), m;

            case "f":
              return g("f"), g("a"), g("l"), g("s"), g("e"), r;

            case "n":
              return g("n"), g("u"), g("l"), g("l"), n;
          }

          j('Unexpected "' + i + '"');
        }

        function b() {
          for (; i && " " >= i;) {
            g();
          }
        }

        function d() {
          var a,
              b,
              d = "",
              c;
          if ('"' === i) for (; g();) {
            if ('"' === i) return g(), d;
            if ("\\" === i) {
              if (g(), "u" === i) {
                for (b = c = 0; 4 > b; b += 1) {
                  a = parseInt(g(), 16);
                  if (!isFinite(a)) break;
                  c = 16 * c + a;
                }

                d += String.fromCharCode(c);
              } else if ("string" === typeof f[i]) d += f[i];else break;
            } else d += i;
          }
          j("Bad string");
        }

        function c() {
          var a;
          a = "";
          "-" === i && (a = "-", g("-"));

          for (; "0" <= i && "9" >= i;) {
            a += i, g();
          }

          if ("." === i) for (a += "."; g() && "0" <= i && "9" >= i;) {
            a += i;
          }

          if ("e" === i || "E" === i) {
            a += i;
            g();
            if ("-" === i || "+" === i) a += i, g();

            for (; "0" <= i && "9" >= i;) {
              a += i, g();
            }
          }

          a = +a;
          if (isFinite(a)) return a;
          j("Bad number");
        }

        function g(a) {
          a && a !== i && j("Expected '" + a + "' instead of '" + i + "'");
          i = h.charAt(l);
          l += 1;
          return i;
        }

        function j(a) {
          throw {
            name: "SyntaxError",
            message: a,
            Ld: l,
            text: h
          };
        }

        var l,
            i,
            f = {
          '"': '"',
          "\\": "\\",
          "/": "/",
          b: "\b",
          f: "\f",
          n: "\n",
          r: "\r",
          t: "\t"
        },
            h,
            _q;

        _q = function q() {
          b();

          switch (i) {
            case "{":
              var l;

              a: {
                var f,
                    h = {};

                if ("{" === i) {
                  g("{");
                  b();

                  if ("}" === i) {
                    g("}");
                    l = h;
                    break a;
                  }

                  for (; i;) {
                    f = d();
                    b();
                    g(":");
                    Object.hasOwnProperty.call(h, f) && j('Duplicate key "' + f + '"');
                    h[f] = _q();
                    b();

                    if ("}" === i) {
                      g("}");
                      l = h;
                      break a;
                    }

                    g(",");
                    b();
                  }
                }

                j("Bad object");
              }

              return l;

            case "[":
              a: {
                l = [];

                if ("[" === i) {
                  g("[");
                  b();

                  if ("]" === i) {
                    g("]");
                    f = l;
                    break a;
                  }

                  for (; i;) {
                    l.push(_q());
                    b();

                    if ("]" === i) {
                      g("]");
                      f = l;
                      break a;
                    }

                    g(",");
                    b();
                  }
                }

                j("Bad array");
              }

              return f;

            case '"':
              return d();

            case "-":
              return c();

            default:
              return "0" <= i && "9" >= i ? c() : a();
          }
        };

        return function (a) {
          h = a;
          l = 0;
          i = " ";
          a = _q();
          b();
          i && j("Syntax error");
          return a;
        };
      }();

      c.Ab = function (a) {
        var b,
            d,
            e,
            g,
            j = 0,
            l = 0,
            i = "",
            i = [];
        if (!a) return a;
        a = c.Gd(a);

        do {
          b = a.charCodeAt(j++), d = a.charCodeAt(j++), e = a.charCodeAt(j++), g = b << 16 | d << 8 | e, b = g >> 18 & 63, d = g >> 12 & 63, e = g >> 6 & 63, g &= 63, i[l++] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(b) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(d) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(e) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(g);
        } while (j < a.length);

        i = i.join("");

        switch (a.length % 3) {
          case 1:
            i = i.slice(0, -2) + "==";
            break;

          case 2:
            i = i.slice(0, -1) + "=";
        }

        return i;
      };

      c.Gd = function (a) {
        var a = (a + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n"),
            b = "",
            d,
            c,
            g = 0,
            j;
        d = c = 0;
        g = a.length;

        for (j = 0; j < g; j++) {
          var l = a.charCodeAt(j),
              i = n;
          128 > l ? c++ : i = 127 < l && 2048 > l ? String.fromCharCode(l >> 6 | 192, l & 63 | 128) : String.fromCharCode(l >> 12 | 224, l >> 6 & 63 | 128, l & 63 | 128);
          i !== n && (c > d && (b += a.substring(d, c)), b += i, d = c = j + 1);
        }

        c > d && (b += a.substring(d, a.length));
        return b;
      };

      c.jb = function () {
        function a() {
          function a(b, c) {
            var d,
                e = 0;

            for (d = 0; d < c.length; d++) {
              e |= j[d] << 8 * d;
            }

            return b ^ e;
          }

          var b,
              c,
              j = [],
              l = 0;

          for (b = 0; b < t.length; b++) {
            c = t.charCodeAt(b), j.unshift(c & 255), 4 <= j.length && (l = a(l, j), j = []);
          }

          0 < j.length && (l = a(l, j));
          return l.toString(16);
        }

        function b() {
          for (var a = 1 * new Date(), b = 0; a == 1 * new Date();) {
            b++;
          }

          return a.toString(16) + b.toString(16);
        }

        return function () {
          var c = (screen.height * screen.width).toString(16);
          return b() + "-" + Math.random().toString(16).replace(".", "") + "-" + a() + "-" + c + "-" + b();
        };
      }();

      c.Ob = function (a) {
        return /(google web preview|baiduspider|yandexbot|bingbot|googlebot|yahoo! slurp)/i.test(a) ? m : r;
      };

      c.ic = function (a) {
        var b,
            d,
            e,
            g = [];
        c.d(b) && (b = "&");
        c.a(a, function (a, b) {
          d = encodeURIComponent(a.toString());
          e = encodeURIComponent(b);
          g[g.length] = e + "=" + d;
        });
        return g.join(b);
      };

      c.Jb = function (a, b) {
        var b = b.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]"),
            c = RegExp("[\\?&]" + b + "=([^&#]*)").exec(a);
        return c === n || c && "string" !== typeof c[1] && c[1].length ? "" : decodeURIComponent(c[1]).replace(/\+/g, " ");
      };

      c.ea = function (a, b) {
        var c = a.match(RegExp(b + "=([^&]*)"));
        return c ? c[1] : n;
      };

      c.cookie = {
        get: function get(a) {
          for (var a = a + "=", b = v.cookie.split(";"), c = 0; c < b.length; c++) {
            for (var e = b[c]; " " == e.charAt(0);) {
              e = e.substring(1, e.length);
            }

            if (0 === e.indexOf(a)) return decodeURIComponent(e.substring(a.length, e.length));
          }

          return n;
        },
        parse: function parse(a) {
          var b;

          try {
            b = c.ma(c.cookie.get(a)) || {};
          } catch (d) {}

          return b;
        },
        vd: function vd(a, b, c, e, g) {
          var d;
          var j = "",
              l = "",
              i = "";
          e && (d = (j = (j = v.location.hostname.match(/[a-z0-9][a-z0-9\-]+\.[a-z\.]{2,6}$/i)) ? j[0] : "") ? "; domain=." + j : "", j = d);
          c && (l = new Date(), l.setTime(l.getTime() + 1E3 * c), l = "; expires=" + l.toGMTString());
          g && (i = "; secure");
          v.cookie = a + "=" + encodeURIComponent(b) + l + "; path=/" + j + i;
        },
        set: function set(a, b, c, e, g) {
          var d;
          var j = "",
              l = "",
              i = "";
          e && (d = (j = (j = v.location.hostname.match(/[a-z0-9][a-z0-9\-]+\.[a-z\.]{2,6}$/i)) ? j[0] : "") ? "; domain=." + j : "", j = d);
          c && (l = new Date(), l.setTime(l.getTime() + 864E5 * c), l = "; expires=" + l.toGMTString());
          g && (i = "; secure");
          a = a + "=" + encodeURIComponent(b) + l + "; path=/" + j + i;
          return v.cookie = a;
        },
        remove: function remove(a, b) {
          c.cookie.set(a, "", -1, b);
        }
      };
      c.localStorage = {
        error: function error(a) {
          k.error("localStorage error: " + a);
        },
        get: function get(a) {
          try {
            return window.localStorage.getItem(a);
          } catch (b) {
            c.localStorage.error(b);
          }

          return n;
        },
        parse: function parse(a) {
          try {
            return c.ma(c.localStorage.get(a)) || {};
          } catch (b) {}

          return n;
        },
        set: function set(a, b) {
          try {
            window.localStorage.setItem(a, b);
          } catch (d) {
            c.localStorage.error(d);
          }
        },
        remove: function remove(a) {
          try {
            window.localStorage.removeItem(a);
          } catch (b) {
            c.localStorage.error(b);
          }
        }
      };

      c.o = function () {
        function a(a, e, g) {
          return function (j) {
            if (j = j || b(window.event)) {
              var l = m,
                  i;
              c.ab(g) && (i = g(j));
              j = e.call(a, j);
              if (r === i || r === j) l = r;
              return l;
            }
          };
        }

        function b(a) {
          if (a) a.preventDefault = b.preventDefault, a.stopPropagation = b.stopPropagation;
          return a;
        }

        b.preventDefault = function () {
          this.returnValue = r;
        };

        b.stopPropagation = function () {
          this.cancelBubble = m;
        };

        return function (b, c, g, j, l) {
          b ? b.addEventListener && !j ? b.addEventListener(c, g, !!l) : (c = "on" + c, b[c] = a(b, g, b[c])) : k.error("No valid element provided to register_event");
        };
      }();

      c.Yc = function () {
        function a(a, b) {
          return 0 <= (" " + a.className + " ").replace(d, " ").indexOf(" " + b + " ");
        }

        function b(b) {
          if (!v.getElementsByTagName) return [];
          var b = b.split(" "),
              d,
              j,
              l,
              i,
              f,
              h,
              q,
              k = [v];

          for (i = 0; i < b.length; i++) {
            if (d = b[i].replace(/^\s+/, "").replace(/\s+$/, ""), -1 < d.indexOf("#")) {
              j = d.split("#");
              d = j[0];
              k = v.getElementById(j[1]);
              if (!k || d && k.nodeName.toLowerCase() != d) return [];
              k = [k];
            } else if (-1 < d.indexOf(".")) {
              j = d.split(".");
              d = j[0];
              var o = j[1];
              d || (d = "*");
              j = [];

              for (f = l = 0; f < k.length; f++) {
                q = "*" == d ? k[f].all ? k[f].all : k[f].getElementsByTagName("*") : k[f].getElementsByTagName(d);

                for (h = 0; h < q.length; h++) {
                  j[l++] = q[h];
                }
              }

              k = [];

              for (f = d = 0; f < j.length; f++) {
                j[f].className && c.bb(j[f].className) && a(j[f], o) && (k[d++] = j[f]);
              }
            } else if (j = d.match(/^(\w*)\[(\w+)([=~\|\^\$\*]?)=?"?([^\]"]*)"?\]$/)) {
              d = j[1];
              var p = j[2],
                  o = j[3],
                  A = j[4];
              d || (d = "*");
              j = [];

              for (f = l = 0; f < k.length; f++) {
                q = "*" == d ? k[f].all ? k[f].all : k[f].getElementsByTagName("*") : k[f].getElementsByTagName(d);

                for (h = 0; h < q.length; h++) {
                  j[l++] = q[h];
                }
              }

              k = [];
              d = 0;

              switch (o) {
                case "=":
                  o = function o(a) {
                    return a.getAttribute(p) == A;
                  };

                  break;

                case "~":
                  o = function o(a) {
                    return a.getAttribute(p).match(RegExp("\\b" + A + "\\b"));
                  };

                  break;

                case "|":
                  o = function o(a) {
                    return a.getAttribute(p).match(RegExp("^" + A + "-?"));
                  };

                  break;

                case "^":
                  o = function o(a) {
                    return 0 === a.getAttribute(p).indexOf(A);
                  };

                  break;

                case "$":
                  o = function o(a) {
                    return a.getAttribute(p).lastIndexOf(A) == a.getAttribute(p).length - A.length;
                  };

                  break;

                case "*":
                  o = function o(a) {
                    return -1 < a.getAttribute(p).indexOf(A);
                  };

                  break;

                default:
                  o = function o(a) {
                    return a.getAttribute(p);
                  };

              }

              k = [];

              for (f = d = 0; f < j.length; f++) {
                o(j[f]) && (k[d++] = j[f]);
              }
            } else {
              j = [];

              for (f = l = 0; f < k.length; f++) {
                q = k[f].getElementsByTagName(d);

                for (h = 0; h < q.length; h++) {
                  j[l++] = q[h];
                }
              }

              k = j;
            }
          }

          return k;
        }

        var d = /[\t\r\n]/g;
        return function (a) {
          return c.gd(a) ? [a] : c.j(a) && !c.d(a.length) ? a : b.call(this, a);
        };
      }();

      c.info = {
        Qc: function Qc() {
          var a = "",
              b = {};
          c.a("utm_source utm_medium utm_campaign utm_content utm_term".split(" "), function (d) {
            a = c.Jb(v.URL, d);
            a.length && (b[d] = a);
          });
          return b;
        },
        qd: function qd(a) {
          return 0 === a.search("https?://(.*)google.([^/?]*)") ? "google" : 0 === a.search("https?://(.*)bing.com") ? "bing" : 0 === a.search("https?://(.*)yahoo.com") ? "yahoo" : 0 === a.search("https?://(.*)duckduckgo.com") ? "duckduckgo" : n;
        },
        rd: function rd(a) {
          var b = c.info.qd(a),
              d = {};
          if (b !== n) d.$search_engine = b, a = c.Jb(a, "yahoo" != b ? "q" : "p"), a.length && (d.mp_keyword = a);
          return d;
        },
        ba: function ba(a, b, d) {
          return d || c.g(a, " OPR/") ? c.g(a, "Mini") ? "Opera Mini" : "Opera" : /(BlackBerry|PlayBook|BB10)/i.test(a) ? "BlackBerry" : c.g(a, "IEMobile") || c.g(a, "WPDesktop") ? "Internet Explorer Mobile" : c.g(a, "Edge") ? "Microsoft Edge" : c.g(a, "FBIOS") ? "Facebook Mobile" : c.g(a, "Chrome") ? "Chrome" : c.g(a, "CriOS") ? "Chrome iOS" : c.g(a, "FxiOS") ? "Firefox iOS" : c.g(b || "", "Apple") ? c.g(a, "Mobile") ? "Mobile Safari" : "Safari" : c.g(a, "Android") ? "Android Mobile" : c.g(a, "Konqueror") ? "Konqueror" : c.g(a, "Firefox") ? "Firefox" : c.g(a, "MSIE") || c.g(a, "Trident/") ? "Internet Explorer" : c.g(a, "Gecko") ? "Mozilla" : "";
        },
        Db: function Db(a, b, d) {
          b = {
            "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
            "Microsoft Edge": /Edge\/(\d+(\.\d+)?)/,
            Chrome: /Chrome\/(\d+(\.\d+)?)/,
            "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
            Safari: /Version\/(\d+(\.\d+)?)/,
            "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
            Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
            Firefox: /Firefox\/(\d+(\.\d+)?)/,
            "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
            Konqueror: /Konqueror:(\d+(\.\d+)?)/,
            BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
            "Android Mobile": /android\s(\d+(\.\d+)?)/,
            "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
            Mozilla: /rv:(\d+(\.\d+)?)/
          }[c.info.ba(a, b, d)];
          if (void 0 === b) return n;
          a = a.match(b);
          return !a ? n : parseFloat(a[a.length - 2]);
        },
        fb: function fb() {
          return /Windows/i.test(t) ? /Phone/.test(t) || /WPDesktop/.test(t) ? "Windows Phone" : "Windows" : /(iPhone|iPad|iPod)/.test(t) ? "iOS" : /Android/.test(t) ? "Android" : /(BlackBerry|PlayBook|BB10)/i.test(t) ? "BlackBerry" : /Mac/i.test(t) ? "Mac OS X" : /Linux/.test(t) ? "Linux" : "";
        },
        Hb: function Hb(a) {
          return /Windows Phone/i.test(a) || /WPDesktop/.test(a) ? "Windows Phone" : /iPad/.test(a) ? "iPad" : /iPod/.test(a) ? "iPod Touch" : /iPhone/.test(a) ? "iPhone" : /(BlackBerry|PlayBook|BB10)/i.test(a) ? "BlackBerry" : /Android/.test(a) ? "Android" : "";
        },
        Ub: function Ub(a) {
          a = a.split("/");
          return 3 <= a.length ? a[2] : "";
        },
        ha: function ha() {
          return c.extend(c.za({
            $os: c.info.fb(),
            $browser: c.info.ba(t, F.vendor, window.opera),
            $referrer: v.referrer,
            $referring_domain: c.info.Ub(v.referrer),
            $device: c.info.Hb(t)
          }), {
            $current_url: window.location.href,
            $browser_version: c.info.Db(t, F.vendor, window.opera),
            $screen_height: screen.height,
            $screen_width: screen.width,
            mp_lib: "web",
            $lib_version: "2.9.14"
          });
        },
        md: function md() {
          return c.extend(c.za({
            $os: c.info.fb(),
            $browser: c.info.ba(t, F.vendor, window.opera)
          }), {
            $browser_version: c.info.Db(t, F.vendor, window.opera)
          });
        },
        ld: function ld(a) {
          return c.za({
            mp_page: a,
            mp_referrer: v.referrer,
            mp_browser: c.info.ba(t, F.vendor, window.opera),
            mp_platform: c.info.fb()
          });
        }
      };
      c.toArray = c.ja;
      c.isObject = c.j;
      c.JSONEncode = c.na;
      c.JSONDecode = c.ma;
      c.isBlockedUA = c.Ob;
      c.isEmptyObject = c.V;
      c.info = c.info;
      c.info.device = c.info.Hb;
      c.info.browser = c.info.ba;
      c.info.properties = c.info.ha;
      var C = {
        tb: [],
        Hc: function Hc(a) {
          if (a.previousElementSibling) return a.previousElementSibling;

          do {
            a = a.previousSibling;
          } while (a && 1 !== a.nodeType);

          return a;
        },
        Ec: function Ec(a, b) {
          var c = document.createElement("script");
          c.type = "text/javascript";
          c.src = a;
          c.onload = b;
          var e = document.getElementsByTagName("script");
          0 < e.length ? e[0].parentNode.insertBefore(c, e[0]) : document.body.appendChild(c);
        },
        qa: function qa(a) {
          return "svg" === a.tagName.toLowerCase() ? a.className.Md || a.getAttribute("class") || "" : a.className || "";
        },
        xc: function xc(a) {
          var b = {
            classes: this.qa(a).split(" "),
            tag_name: a.tagName.toLowerCase()
          };

          if (c.g(["input", "select", "textarea"], a.tagName.toLowerCase())) {
            var d = this.qb(a);
            this.Ma(a, d) && (b.value = d);
          }

          c.a(a.attributes, function (a) {
            b["attr__" + a.name] = a.value;
          });

          for (var e = d = 1, g = a; g = this.Hc(g);) {
            d++, g.tagName === a.tagName && e++;
          }

          b.nth_child = d;
          b.nth_of_type = e;
          return b;
        },
        Jc: function Jc(a, b) {
          if (!a || a === document || a === document.body.parentNode || 1 !== a.nodeType) return r;

          switch (a.tagName.toLowerCase()) {
            case "html":
              return r;

            case "form":
              return "submit" === b.type;

            case "input":
              return -1 === ["button", "submit"].indexOf(a.getAttribute("type")) ? "change" === b.type : "click" === b.type;

            case "select":
            case "textarea":
              return "change" === b.type;

            default:
              return "click" === b.type;
          }
        },
        pb: function pb(a) {
          return {
            $event_type: a,
            $ce_version: 1,
            $host: window.location.host,
            $pathname: window.location.pathname
          };
        },
        wc: function wc(a) {
          var b = n;

          switch (a.type.toLowerCase()) {
            case "checkbox":
              a.checked && (b = [a.value]);
              break;

            case "radio":
              if (a.checked) b = a.value;
              break;

            default:
              b = a.value;
          }

          return b;
        },
        yc: function yc(a) {
          if (a.multiple) {
            var b = [];
            c.a(a.querySelectorAll("[selected]"), function (a) {
              b.push(a.value);
            });
            a = b;
          } else a = a.value;

          return a;
        },
        Ma: function Ma(a, b) {
          for (var d = a; d.parentNode && d !== document.body; d = d.parentNode) {
            var e = this.qa(d).split(" ");
            if (c.g(e, "mp-sensitive") || c.g(e, "mp-no-track")) return r;
          }

          if (c.g(this.qa(a).split(" "), "mp-include")) return m;
          if (b === n) return r;

          switch ((a.type || "").toLowerCase()) {
            case "hidden":
              return r;

            case "password":
              return r;
          }

          return /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|seccode|securitycode|securitynum|socialsec|socsec|ssn/i.test((a.name || a.id || "").replace(/[^a-zA-Z0-9]/g, "")) || "string" === typeof b && (/^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/.test((b || "").replace(/[\- ]/g, "")) || /(^\d{3}-?\d{2}-?\d{4}$)/.test(b)) ? r : m;
        },
        qb: function qb(a) {
          var b;

          switch (a.tagName.toLowerCase()) {
            case "input":
              b = this.wc(a);
              break;

            case "select":
              b = this.yc(a);
              break;

            default:
              b = a.value || a.textContent;
          }

          return this.Ma(a, b) ? b : n;
        },
        vc: function vc(a) {
          var b = {};
          c.a(a.elements, function (a) {
            var c = a.getAttribute("name") || a.getAttribute("id");

            if (c !== n) {
              var c = "$form_field__" + c,
                  g = this.qb(a);
              this.Ma(a, g) && (a = b[c], b[c] = void 0 !== a ? [].concat(a, g) : g);
            }
          }, this);
          return b;
        },
        rc: function rc(a) {
          var b = [];
          c.a(document.querySelectorAll(a.css_selector), function (a) {
            -1 < ["input", "select"].indexOf(a.tagName.toLowerCase()) ? b.push(a.value) : a.textContent && b.push(a.textContent);
          });
          return b.join(", ");
        },
        tc: function tc(a) {
          var b = {};
          c.a(this.lb, function (d) {
            c.a(d.event_selectors, function (e) {
              e = document.querySelectorAll(e);
              c.a(e, function (e) {
                c.g(a, e) && (b[d.name] = this.rc(d));
              }, this);
            }, this);
          }, this);
          return b;
        },
        Rc: function Rc(a) {
          a = parseInt(a.getResponseHeader("X-MP-CE-Backoff"));

          if (!isNaN(a) && 0 < a) {
            var b = c.timestamp() + 1E3 * a;
            console.log("disabling CE for " + a + " seconds (from " + c.timestamp() + " until " + b + ")");
            c.cookie.vd("__mpced", m, a, m);
          }
        },
        uc: function uc(a) {
          return "undefined" === typeof a.target ? a.srcElement : a.target;
        },
        Lc: function Lc(a, b) {
          var d = this.uc(a);
          if (3 === d.nodeType) d = d.parentNode;

          if (this.Jc(d, a)) {
            for (var e = [d]; d.parentNode && d !== document.body;) {
              e.push(d.parentNode), d = d.parentNode;
            }

            var g = [],
                j,
                f,
                i,
                h = r;
            c.a(e, function (a, b) {
              "a" === a.tagName.toLowerCase() ? j = a.getAttribute("href") : "form" === a.tagName.toLowerCase() && (i = a);

              if (!f && 5 > b && a.textContent) {
                var d = c.trim(a.textContent);
                d && (f = d.replace(/[\r\n]/g, " ").replace(/[ ]+/g, " ").substring(0, 255));
              }

              d = this.qa(a).split(" ");
              c.g(d, "mp-no-track") && (h = m);
              g.push(this.xc(a));
            }, this);
            if (h) return r;
            e = c.extend(this.pb(a.type), {
              $elements: g,
              $el_attr__href: j,
              $el_text: f
            }, this.tc(e));
            i && ("submit" === a.type || "click" === a.type) && c.extend(e, this.vc(i));
            b.J("$web_event", e);
            return m;
          }
        },
        Kd: function Kd(a) {
          window.location.href = a;
        },
        mc: function mc(a) {
          var b = c.bind(function (b) {
            c.cookie.parse("__mpced") !== m && (b = b || window.event, this.Lc(b, a));
          }, this);
          c.o(document, "submit", b, r, m);
          c.o(document, "change", b, r, m);
          c.o(document, "click", b, r, m);
        },
        lb: {},
        U: function U(a) {
          if (!document || !document.body) {
            console.log("document not ready yet, trying again in 500 milliseconds...");
            var b = this;
            setTimeout(function () {
              b.U(a);
            }, 500);
          } else {
            var d = a.c("token");
            if (-1 < this.tb.indexOf(d)) console.log('autotrack already initialized for token "' + d + '"');else if (this.tb.push(d), !this.Fc(a)) {
              var e = c.bind(function (b) {
                if (b && b.config && b.config.enable_collect_everything === m) {
                  if (b.custom_properties) this.lb = b.custom_properties;
                  a.J("$web_event", c.extend({
                    $title: document.title
                  }, this.pb("pageview")));
                  this.mc(a);
                } else a.__autotrack_enabled = r;
              }, this);
              a.p(a.c("decide_host") + "/decide/", {
                verbose: m,
                version: "1",
                lib: "web",
                token: d
              }, a.ta(e));
            }
          }
        },
        nb: function nb(a, b) {
          var d;

          try {
            var e = c.ea(b, "state"),
                e = JSON.parse(decodeURIComponent(e)),
                g = c.ea(b, "expires_in");
            d = {
              accessToken: c.ea(b, "access_token"),
              accessTokenExpiresAt: new Date().getTime() + 1E3 * Number(g),
              appHost: e.appHost,
              bookmarkletMode: !!e.bookmarkletMode,
              projectId: e.projectId,
              projectOwnerId: e.projectOwnerId,
              projectToken: e.token,
              readOnly: e.readOnly,
              userFlags: e.userFlags,
              userId: e.userId
            };
            window.sessionStorage.setItem("editorParams", JSON.stringify(d));
            e.desiredHash ? window.location.hash = e.desiredHash : window.history ? history.replaceState("", document.title, window.location.pathname + window.location.search) : window.location.hash = "";
          } catch (j) {
            console.error("Unable to parse data from hash", j);
          }

          return d;
        },
        Fc: function Fc(a) {
          var b = r;
          c.ea(window.location.hash, "state") && (b = c.ea(window.location.hash, "state"), b = JSON.parse(decodeURIComponent(b)), b = "mpeditor" === b.action);
          var d = !!window.sessionStorage.getItem("_mpcehash");
          b ? b = this.nb(a, window.location.hash) : d ? (b = this.nb(a, window.sessionStorage.getItem("_mpcehash")), window.sessionStorage.removeItem("_mpcehash")) : b = JSON.parse(window.sessionStorage.getItem("editorParams") || "{}");
          return b.projectToken && a.c("token") === b.projectToken ? (this.Dc(a, b), m) : r;
        },
        mb: r,
        Dc: function Dc(a, b) {
          if (!this.mb) {
            this.mb = m;
            var c = "?_ts=" + new Date().getTime(),
                e = a.c("app_host") + "/site_media";
            this.Ec(z ? e + "/compiled/reports/collect-everything/editor.js" + c : e + "/bundle-webpack/reports/collect-everything/editor.min.js" + c, function () {
              window.mp_load_editor(b);
            });
            return m;
          }

          return r;
        },
        $c: function $c(a, b, d) {
          for (var b = !c.d(b) ? b : 10, d = !c.d(d) ? d : 10, e = 0, g = 0; g < a.length; g++) {
            e += a.charCodeAt(g);
          }

          return e % b < d;
        },
        ed: function ed() {
          return c.ab(document.querySelectorAll);
        }
      };
      c.Cb(C);
      c.pd(C);
      var L,
          s,
          Z = "__mps,__mpso,__mpa,__mpap,__mpu,$people_distinct_id,__alias,__cmpns,__timers".split(",");
      w = "https:" === document.location.protocol ? "https://" : "http://";
      var K = window.XMLHttpRequest && "withCredentials" in new XMLHttpRequest(),
          R = !K && -1 === t.indexOf("MSIE") && -1 === t.indexOf("Mozilla"),
          P = {
        api_host: w + "api.mixpanel.com",
        app_host: w + "mixpanel.com",
        autotrack: m,
        cdn: w + "cdn.mxpnl.com",
        cross_subdomain_cookie: m,
        persistence: "cookie",
        persistence_name: "",
        cookie_name: "",
        loaded: B(),
        store_google: m,
        save_referrer: m,
        test: r,
        verbose: r,
        img: r,
        track_pageview: m,
        debug: r,
        track_links_timeout: 300,
        cookie_expiration: 365,
        upgrade: r,
        disable_persistence: r,
        disable_cookie: r,
        secure_cookie: r,
        ip: m,
        property_blacklist: []
      };
      P.decide_host = P.api_host;
      var Q = r;
      x.prototype.wa = B();
      x.prototype.Va = B();
      x.prototype.Ra = B();

      x.prototype.U = function (a) {
        this.Rb = a;
        return this;
      };

      x.prototype.J = function (a, b, d, e) {
        var g = this,
            j = c.Yc(a);
        if (0 === j.length) k.error("The DOM query (" + a + ") returned 0 elements");else return c.a(j, function (a) {
          c.o(a, this.Tb, function (a) {
            var c = {},
                j = g.wa(d, this),
                f = g.Rb.c("track_links_timeout");
            g.Va(a, this, c);
            window.setTimeout(g.$b(e, j, c, m), f);
            g.Rb.J(b, j, g.$b(e, j, c));
          });
        }, this), m;
      };

      x.prototype.$b = function (a, b, c, e) {
        var e = e || r,
            g = this;
        return function () {
          if (!c.Pc) c.Pc = m, a && a(e, b) === r || g.Ra(b, c, e);
        };
      };

      x.prototype.wa = function (a, b) {
        return "function" === typeof a ? a(b) : c.extend({}, a);
      };

      c.Nb(D, x);

      D.prototype.wa = function (a, b) {
        var c = D.zd.wa.apply(this, arguments);
        if (b.href) c.url = b.href;
        return c;
      };

      D.prototype.Va = function (a, b, c) {
        c.Sb = 2 === a.which || a.metaKey || a.ctrlKey || "_blank" === b.target;
        c.href = b.href;
        c.Sb || a.preventDefault();
      };

      D.prototype.Ra = function (a, b) {
        b.Sb || setTimeout(function () {
          window.location = b.href;
        }, 0);
      };

      c.Nb(I, x);

      I.prototype.Va = function (a, b, c) {
        c.element = b;
        a.preventDefault();
      };

      I.prototype.Ra = function (a, b) {
        setTimeout(function () {
          b.element.submit();
        }, 0);
      };

      o.prototype.ha = function () {
        var a = {};
        c.a(this.props, function (b, d) {
          c.Lb(Z, d) || (a[d] = b);
        });
        return a;
      };

      o.prototype.load = function () {
        if (!this.disabled) {
          var a = this.w.parse(this.name);
          a && (this.props = c.extend({}, a));
        }
      };

      o.prototype.Fd = function (a) {
        var b = a.upgrade,
            d;
        if (b) d = "mp_super_properties", "string" === typeof b && (d = b), b = this.w.parse(d), this.w.remove(d), this.w.remove(d, m), b && (this.props = c.extend(this.props, b.all, b.events));
        if (!a.cookie_name && "mixpanel" !== a.name && (d = "mp_" + a.token + "_" + a.name, b = this.w.parse(d))) this.w.remove(d), this.w.remove(d, m), this.G(b);
        this.w === c.localStorage && (b = c.cookie.parse(this.name), c.cookie.remove(this.name), c.cookie.remove(this.name, m), b && this.G(b));
      };

      o.prototype.save = function () {
        this.disabled || (this.qc(), this.w.set(this.name, c.na(this.props), this.Wa, this.Ta, this.Vb));
      };

      o.prototype.remove = function () {
        this.w.remove(this.name, r);
        this.w.remove(this.name, m);
      };

      o.prototype.clear = function () {
        this.remove();
        this.props = {};
      };

      o.prototype.G = function (a, b, d) {
        return c.j(a) ? ("undefined" === typeof b && (b = "None"), this.Wa = "undefined" === typeof d ? this.Gb : d, c.a(a, function (a, c) {
          if (!this.props[c] || this.props[c] === b) this.props[c] = a;
        }, this), this.save(), m) : r;
      };

      o.prototype.ia = function (a, b) {
        return c.j(a) ? (this.Wa = "undefined" === typeof b ? this.Gb : b, c.extend(this.props, a), this.save(), m) : r;
      };

      o.prototype.Ca = function (a) {
        a in this.props && (delete this.props[a], this.save());
      };

      o.prototype.qc = c.l(function () {
        var a = this.props.__cmpns,
            b = z ? 6E4 : 36E5;

        if (a) {
          for (var d in a) {
            1 * new Date() - a[d] > b && delete a[d];
          }

          c.V(a) && delete this.props.__cmpns;
        }
      });

      o.prototype.Ed = function () {
        if (!this.Eb) this.G(c.info.Qc()), this.Eb = m;
      };

      o.prototype.dc = function (a) {
        this.ia(c.info.rd(a));
      };

      o.prototype.ib = function (a) {
        this.G({
          $initial_referrer: a || "$direct",
          $initial_referring_domain: c.info.Ub(a) || "$direct"
        }, "");
      };

      o.prototype.cd = function () {
        return c.za({
          $initial_referrer: this.props.$initial_referrer,
          $initial_referring_domain: this.props.$initial_referring_domain
        });
      };

      o.prototype.cc = function (a) {
        this.Gb = this.Wa = a.cookie_expiration;
        this.td(a.disable_persistence);
        this.sd(a.cross_subdomain_cookie);
        this.wd(a.secure_cookie);
      };

      o.prototype.td = function (a) {
        (this.disabled = a) && this.remove();
      };

      o.prototype.sd = function (a) {
        if (a !== this.Ta) this.Ta = a, this.remove(), this.save();
      };

      o.prototype.bd = function () {
        return this.Ta;
      };

      o.prototype.wd = function (a) {
        if (a !== this.Vb) this.Vb = a ? m : r, this.remove(), this.save();
      };

      o.prototype.B = function (a, b) {
        var d = this.La(a),
            e = b[a],
            g = this.Z("$set"),
            j = this.Z("$set_once"),
            f = this.Z("$add"),
            i = this.Z("$union"),
            h = this.Z("$append", []);
        "__mps" === d ? (c.extend(g, e), this.S("$add", e), this.S("$union", e)) : "__mpso" === d ? c.a(e, function (a, b) {
          b in j || (j[b] = a);
        }) : "__mpa" === d ? c.a(e, function (a, b) {
          b in g ? g[b] += a : (b in f || (f[b] = 0), f[b] += a);
        }, this) : "__mpu" === d ? c.a(e, function (a, b) {
          c.isArray(a) && (b in i || (i[b] = []), i[b] = i[b].concat(a));
        }) : "__mpap" === d && h.push(e);
        k.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):");
        k.log(b);
        this.save();
      };

      o.prototype.S = function (a, b) {
        var d = this.R(a);
        c.d(d) || (c.a(b, function (a, b) {
          delete d[b];
        }, this), this.save());
      };

      o.prototype.La = function (a) {
        if ("$set" === a) return "__mps";
        if ("$set_once" === a) return "__mpso";
        if ("$add" === a) return "__mpa";
        if ("$append" === a) return "__mpap";
        if ("$union" === a) return "__mpu";
        k.error("Invalid queue:", a);
      };

      o.prototype.R = function (a) {
        return this.props[this.La(a)];
      };

      o.prototype.Z = function (a, b) {
        var d = this.La(a),
            b = c.d(b) ? {} : b;
        return this.props[d] || (this.props[d] = b);
      };

      o.prototype.ud = function (a) {
        var b = this.props.__timers || {};
        b[a] = new Date().getTime();
        this.props.__timers = b;
        this.save();
      };

      o.prototype.nd = function (a) {
        var b = (this.props.__timers || {})[a];
        c.d(b) || (delete this.props.__timers[a], this.save());
        return b;
      };

      var f;

      h.prototype.U = function (a, b, d) {
        if (c.d(d)) k.error("You must name your new library: init(token, config, name)");else if ("mixpanel" === d) k.error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet");else return a = H(a, b, d), s[d] = a, a.sa(), a;
      };

      h.prototype.Na = function (a, b, d) {
        this.__loaded = m;
        this.config = {};
        this.Wb(c.extend({}, P, b, {
          name: d,
          token: a,
          callback_fn: ("mixpanel" === d ? d : "mixpanel." + d) + "._jsc"
        }));
        this._jsc = B();
        this.Ia = [];
        this.Ja = [];
        this.Ha = [];
        this.P = {
          disable_all_events: r,
          identify_called: r
        };
        this.persistence = this.cookie = new o(this.config);
        this.G({
          distinct_id: c.jb()
        }, "");
      };

      h.prototype.sa = function () {
        this.c("loaded")(this);
        this.c("track_pageview") && this.ac();
      };

      h.prototype.oc = function () {
        c.a(this.Ia, function (a) {
          this.Pa.apply(this, a);
        }, this);
        c.a(this.Ja, function (a) {
          this.p.apply(this, a);
        }, this);
        delete this.Ia;
        delete this.Ja;
      };

      h.prototype.Pa = function (a, b) {
        if (this.c("img")) return k.error("You can't use DOM tracking functions with img = true."), r;
        if (!Q) return this.Ia.push([a, b]), r;
        var c = new a().U(this);
        return c.J.apply(c, b);
      };

      h.prototype.ta = function (a, b) {
        if (c.d(a)) return n;
        if (K) return function (c) {
          a(c, b);
        };
        var d = this._jsc,
            e = "" + Math.floor(1E8 * Math.random()),
            g = this.c("callback_fn") + "[" + e + "]";

        d[e] = function (c) {
          delete d[e];
          a(c, b);
        };

        return g;
      };

      h.prototype.p = function (a, b, d) {
        if (R) this.Ja.push(arguments);else {
          var e = this.c("verbose");
          b.verbose && (e = m);
          this.c("test") && (b.test = 1);
          e && (b.verbose = 1);
          this.c("img") && (b.img = 1);
          if (!K) if (d) b.callback = d;else if (e || this.c("test")) b.callback = "(function(){})";
          b.ip = this.c("ip") ? 1 : 0;
          b._ = new Date().getTime().toString();
          a += "?" + c.ic(b);

          if ("img" in b) {
            var g = document.createElement("img");
            g.src = a;
            document.body.appendChild(g);
          } else if (K) try {
            var j = new XMLHttpRequest();
            j.open("GET", a, m);
            j.withCredentials = m;

            j.onreadystatechange = function () {
              if (4 === j.readyState) if (-1 !== a.indexOf("api.mixpanel.com/track") && C.Rc(j), 200 === j.status) d && (e ? d(c.ma(j.responseText)) : d(Number(j.responseText)));else {
                var b = "Bad HTTP status: " + j.status + " " + j.statusText;
                k.error(b);
                d && (e ? d({
                  status: 0,
                  error: b
                }) : d(0));
              }
            };

            j.send(n);
          } catch (f) {
            k.error(f);
          } else {
            g = document.createElement("script");
            g.type = "text/javascript";
            g.async = m;
            g.defer = m;
            g.src = a;
            var i = document.getElementsByTagName("script")[0];
            i.parentNode.insertBefore(g, i);
          }
        }
      };

      h.prototype.Ka = function (a) {
        function b(a, b) {
          c.a(a, function (a) {
            this[a[0]].apply(this, a.slice(1));
          }, b);
        }

        var d,
            e = [],
            g = [],
            j = [];
        c.a(a, function (a) {
          a && (d = a[0], "function" === typeof a ? a.call(this) : c.isArray(a) && "alias" === d ? e.push(a) : c.isArray(a) && -1 !== d.indexOf("track") && "function" === typeof this[d] ? j.push(a) : g.push(a));
        }, this);
        b(e, this);
        b(g, this);
        b(j, this);
      };

      h.prototype.push = function (a) {
        this.Ka([a]);
      };

      h.prototype.disable = function (a) {
        "undefined" === typeof a ? this.P.Vc = m : this.Ha = this.Ha.concat(a);
      };

      h.prototype.J = function (a, b, d) {
        "function" !== typeof d && (d = B());
        if (c.d(a)) k.error("No event name provided to mixpanel.track");else if (this.ob(a)) d(0);else {
          b = b || {};
          b.token = this.c("token");
          var e = this.persistence.nd(a);
          c.d(e) || (b.$duration = parseFloat(((new Date().getTime() - e) / 1E3).toFixed(3)));
          this.persistence.dc(document.referrer);
          this.c("store_google") && this.persistence.Ed();
          this.c("save_referrer") && this.persistence.ib(document.referrer);
          b = c.extend({}, c.info.ha(), this.persistence.ha(), b);

          try {
            if (this.c("autotrack") && "mp_page_view" !== a && "$create_alias" !== a) b = c.extend({}, b, this.F), this.F = {
              $__c: 0
            }, c.cookie.set("mp_" + this.c("name") + "__c", 0, 1, m);
          } catch (g) {
            k.error(g);
          }

          e = this.c("property_blacklist");
          c.isArray(e) ? c.a(e, function (a) {
            delete b[a];
          }) : k.error("Invalid value for property_blacklist config: " + e);
          a = c.truncate({
            event: a,
            properties: b
          }, 255);
          e = c.na(a);
          e = c.Ab(e);
          k.log("MIXPANEL REQUEST:");
          k.log(a);
          this.p(this.c("api_host") + "/track/", {
            data: e
          }, this.ta(d, a));
          return a;
        }
      };

      h.prototype.ac = function (a) {
        if (c.d(a)) a = document.location.href;
        this.J("mp_page_view", c.info.ld(a));
      };

      h.prototype.Dd = function () {
        return this.Pa.call(this, D, arguments);
      };

      h.prototype.Cd = function () {
        return this.Pa.call(this, I, arguments);
      };

      h.prototype.Ad = function (a) {
        c.d(a) ? k.error("No event name provided to mixpanel.time_event") : this.ob(a) || this.persistence.ud(a);
      };

      h.prototype.ia = function (a, b) {
        this.persistence.ia(a, b);
      };

      h.prototype.G = function (a, b, c) {
        this.persistence.G(a, b, c);
      };

      h.prototype.Ca = function (a) {
        this.persistence.Ca(a);
      };

      h.prototype.Oa = function (a, b) {
        var c = {};
        c[a] = b;
        this.ia(c);
      };

      h.prototype.Ya = function (a, b, c, e, g, j) {
        a !== this.T() && a !== this.xa("__alias") && (this.Ca("__alias"), this.Oa("distinct_id", a));
        this.kb(this.T());
        this.P.Za = m;
        this.people.sc(b, c, e, g, j);
      };

      h.prototype.reset = function () {
        this.persistence.clear();
        this.P.Za = r;
        this.G({
          distinct_id: c.jb()
        }, "");
      };

      h.prototype.T = function () {
        return this.xa("distinct_id");
      };

      h.prototype.Nc = function (a, b) {
        if (a === this.xa("$people_distinct_id")) return k.ca("Attempting to create alias for existing People user - aborting."), -2;
        var d = this;
        c.d(b) && (b = this.T());
        if (a !== b) return this.Oa("__alias", a), this.J("$create_alias", {
          alias: a,
          distinct_id: b
        }, function () {
          d.Ya(a);
        });
        k.error("alias matches current distinct_id - skipping api call.");
        this.Ya(a);
        return -1;
      };

      h.prototype.jd = function (a) {
        this.Oa("mp_name_tag", a);
      };

      h.prototype.Wb = function (a) {
        if (c.j(a)) c.extend(this.config, a), this.c("persistence_name") || (this.config.persistence_name = this.config.cookie_name), this.c("disable_persistence") || (this.config.disable_persistence = this.config.disable_cookie), this.persistence && this.persistence.cc(this.config), z = z || this.c("debug");
      };

      h.prototype.c = function (a) {
        return this.config[a];
      };

      h.prototype.xa = function (a) {
        return this.persistence.props[a];
      };

      h.prototype.toString = function () {
        var a = this.c("name");
        "mixpanel" !== a && (a = "mixpanel." + a);
        return a;
      };

      h.prototype.ob = function (a) {
        return c.Ob(t) || this.P.Vc || c.Lb(this.Ha, a);
      };

      h.prototype.kb = function (a) {
        if (a && !this.P.Za && !this.c("disable_notifications")) {
          k.log("MIXPANEL NOTIFICATION CHECK");
          var b = this;
          this.p(this.c("decide_host") + "/decide/", {
            verbose: m,
            version: "1",
            lib: "web",
            token: this.c("token"),
            distinct_id: a
          }, this.ta(function (a) {
            a.notifications && 0 < a.notifications.length && b.yb.call(b, a.notifications[0]);
          }));
        }
      };

      h.prototype.yb = function (a) {
        new f(a, this).show();
      };

      p.prototype.Na = function (a) {
        this.e = a;
      };

      p.prototype.set = function (a, b, d) {
        var e = {},
            g = {};
        c.j(a) ? (c.a(a, function (a, b) {
          this.$(b) || (g[b] = a);
        }, this), d = b) : g[a] = b;
        this.ra("save_referrer") && this.e.persistence.ib(document.referrer);
        g = c.extend({}, c.info.md(), this.e.persistence.cd(), g);
        e.$set = g;
        return this.p(e, d);
      };

      p.prototype.Xb = function (a, b, d) {
        var e = {},
            g = {};
        c.j(a) ? (c.a(a, function (a, b) {
          this.$(b) || (g[b] = a);
        }, this), d = b) : g[a] = b;
        e.$set_once = g;
        return this.p(e, d);
      };

      p.prototype.Mb = function (a, b, d) {
        var e = {},
            g = {};
        c.j(a) ? (c.a(a, function (a, b) {
          this.$(b) || (isNaN(parseFloat(a)) ? k.error("Invalid increment value passed to mixpanel.people.increment - must be a number") : g[b] = a);
        }, this), d = b) : (c.d(b) && (b = 1), g[a] = b);
        e.$add = g;
        return this.p(e, d);
      };

      p.prototype.append = function (a, b, d) {
        var e = {},
            g = {};
        c.j(a) ? (c.a(a, function (a, b) {
          this.$(b) || (g[b] = a);
        }, this), d = b) : g[a] = b;
        e.$append = g;
        return this.p(e, d);
      };

      p.prototype.bc = function (a, b, d) {
        var e = {},
            g = {};
        c.j(a) ? (c.a(a, function (a, b) {
          this.$(b) || (g[b] = c.isArray(a) ? a : [a]);
        }, this), d = b) : g[a] = c.isArray(b) ? b : [b];
        e.$union = g;
        return this.p(e, d);
      };

      p.prototype.Bd = function (a, b, d) {
        if (!c.hd(a) && (a = parseFloat(a), isNaN(a))) {
          k.error("Invalid value passed to mixpanel.people.track_charge - must be a number");
          return;
        }

        return this.append("$transactions", c.extend({
          $amount: a
        }, b), d);
      };

      p.prototype.Sc = function (a) {
        return this.set("$transactions", [], a);
      };

      p.prototype.Uc = function () {
        if (this.sb()) return this.p({
          $delete: this.e.T()
        });
        k.error("mixpanel.people.delete_user() requires you to call identify() first");
      };

      p.prototype.toString = function () {
        return this.e.toString() + ".people";
      };

      p.prototype.p = function (a, b) {
        a.$token = this.ra("token");
        a.$distinct_id = this.e.T();
        var d = c.Ib(a),
            e = c.truncate(d, 255),
            d = c.na(d),
            d = c.Ab(d);
        if (!this.sb()) return this.pc(a), c.d(b) || (this.ra("verbose") ? b({
          status: -1,
          error: n
        }) : b(-1)), e;
        k.log("MIXPANEL PEOPLE REQUEST:");
        k.log(e);
        this.e.p(this.ra("api_host") + "/engage/", {
          data: d
        }, this.e.ta(b, e));
        return e;
      };

      p.prototype.ra = function (a) {
        return this.e.c(a);
      };

      p.prototype.sb = function () {
        return this.e.P.Za === m;
      };

      p.prototype.pc = function (a) {
        "$set" in a ? this.e.persistence.B("$set", a) : "$set_once" in a ? this.e.persistence.B("$set_once", a) : "$add" in a ? this.e.persistence.B("$add", a) : "$append" in a ? this.e.persistence.B("$append", a) : "$union" in a ? this.e.persistence.B("$union", a) : k.error("Invalid call to _enqueue():", a);
      };

      p.prototype.sc = function (a, b, d, e, g) {
        var f = this,
            h = c.extend({}, this.e.persistence.R("$set")),
            i = c.extend({}, this.e.persistence.R("$set_once")),
            k = c.extend({}, this.e.persistence.R("$add")),
            o = this.e.persistence.R("$append"),
            q = c.extend({}, this.e.persistence.R("$union"));
        !c.d(h) && c.j(h) && !c.V(h) && (f.e.persistence.S("$set", h), this.set(h, function (b, d) {
          0 === b && f.e.persistence.B("$set", h);
          c.d(a) || a(b, d);
        }));
        !c.d(i) && c.j(i) && !c.V(i) && (f.e.persistence.S("$set_once", i), this.Xb(i, function (a, b) {
          0 === a && f.e.persistence.B("$set_once", i);
          c.d(e) || e(a, b);
        }));
        !c.d(k) && c.j(k) && !c.V(k) && (f.e.persistence.S("$add", k), this.Mb(k, function (a, d) {
          0 === a && f.e.persistence.B("$add", k);
          c.d(b) || b(a, d);
        }));
        !c.d(q) && c.j(q) && !c.V(q) && (f.e.persistence.S("$union", q), this.bc(q, function (a, b) {
          0 === a && f.e.persistence.B("$union", q);
          c.d(g) || g(a, b);
        }));

        if (!c.d(o) && c.isArray(o) && o.length) {
          for (var p, s = function s(a, b) {
            0 === a && f.e.persistence.B("$append", p);
            c.d(d) || d(a, b);
          }, t = o.length - 1; 0 <= t; t--) {
            p = o.pop(), f.append(p, s);
          }

          f.e.persistence.save();
        }
      };

      p.prototype.$ = function (a) {
        return "$distinct_id" === a || "$token" === a;
      };

      h.lc = function (a, b) {
        c.Cb(this);
        this.eb = b;
        this.gb = this.eb.persistence;
        this.D = c.u(a.id);
        this.Qb = c.u(a.message_id);
        this.body = (c.u(a.body) || "").replace(/\n/g, "<br/>");
        this.Tc = c.u(a.cta) || "Close";
        this.da = c.u(a.cta_url) || n;
        this.$a = c.u(a.image_url) || n;
        this.fa = c.u(a.type) || "takeover";
        this.style = c.u(a.style) || "light";
        this.L = c.u(a.thumb_image_url) || n;
        this.title = c.u(a.title) || "";
        this.Da = c.u(a.video_url) || n;
        this.ka = f.kc;
        this.X = f.jc;
        this.va = m;
        if (!this.da) this.da = "#dismiss", this.va = r;
        this.v = "mini" === this.fa;
        if (!this.v) this.fa = "takeover";
        this.kd = !this.v ? f.Y : f.Ea;
        this.xb();
        this.ya = this.zc();
        this.Cc();
      };

      f = h.lc;
      f.M = 200;
      f.z = "mixpanel-notification";
      f.la = 0.6;
      f.I = 25;
      f.oa = 200;
      f.Y = 388;
      f.Ea = 420;
      f.A = 85;
      f.Fa = 5;
      f.K = 60;
      f.Ga = Math.round(f.K / 2);
      f.kc = 595;
      f.jc = 334;

      f.prototype.show = function () {
        var a = this;
        this.xb();
        this.q ? (this.Bc(), this.Ac(), this.Gc(this.nc)) : setTimeout(function () {
          a.show();
        }, 300);
      };

      f.prototype.Ua = c.l(function () {
        this.Pb || this.vb({
          invisible: m
        });
        var a = this.xd ? this.i("video") : this.Q();
        if (this.ec) this.Ic("bg", "visible"), this.N(a, "exiting"), setTimeout(this.wb, f.M);else {
          var b, c, e;
          this.v ? (b = "right", c = 20, e = -100) : (b = "top", c = f.I, e = f.oa + f.I);
          this.pa([{
            s: this.i("bg"),
            m: "opacity",
            start: f.la,
            k: 0
          }, {
            s: a,
            m: "opacity",
            start: 1,
            k: 0
          }, {
            s: a,
            m: b,
            start: c,
            k: e
          }], f.M, this.wb);
        }
      });
      f.prototype.N = c.l(function (a, b) {
        b = f.z + "-" + b;
        "string" === typeof a && (a = this.i(a));
        a.className ? ~(" " + a.className + " ").indexOf(" " + b + " ") || (a.className += " " + b) : a.className = b;
      });
      f.prototype.Ic = c.l(function (a, b) {
        b = f.z + "-" + b;
        "string" === typeof a && (a = this.i(a));
        if (a.className) a.className = (" " + a.className + " ").replace(" " + b + " ", "").replace(/^[\s\xA0]+/, "").replace(/[\s\xA0]+$/, "");
      });
      f.prototype.pa = c.l(function (a, b, c, e) {
        var g = this,
            f = r,
            h,
            i;
        h = 1 * new Date();
        var k,
            e = e || h;
        k = h - e;

        for (h = 0; h < a.length; h++) {
          i = a[h];
          if ("undefined" === typeof i.H) i.H = i.start;

          if (i.H !== i.k) {
            var f = m,
                o = i.k >= i.start ? 1 : -1;
            i.H = i.start + (i.k - i.start) * k / b;
            if ("opacity" !== i.m) i.H = Math.round(i.H);
            if (0 < o && i.H >= i.k || 0 > o && i.H <= i.k) i.H = i.k;
          }
        }

        if (f) {
          for (h = 0; h < a.length; h++) {
            i = a[h], i.s && (i.s.style[i.m] = "" + i.H + ("opacity" === i.m ? "" : "px"));
          }

          setTimeout(function () {
            g.pa(a, b, c, e);
          }, 10);
        } else c && c();
      });
      f.prototype.nc = c.l(function () {
        var a = this;
        if (!this.yd && !this.rb()[this.D]) this.yd = m, this.q.appendChild(this.ga), setTimeout(function () {
          var b = a.Q();
          if (a.ec) a.v || a.N("bg", "visible"), a.N(b, "visible"), a.ub();else {
            var c, e, g;
            a.v ? (c = "right", e = -100, g = 20) : (c = "top", e = f.oa + f.I, g = f.I);
            a.pa([{
              s: a.i("bg"),
              m: "opacity",
              start: 0,
              k: f.la
            }, {
              s: b,
              m: "opacity",
              start: 0,
              k: 1
            }, {
              s: b,
              m: c,
              start: e,
              k: g
            }], f.M, a.ub);
          }
        }, 100), c.o(a.i("cancel"), "click", function (b) {
          b.preventDefault();
          a.Ua();
        }), c.o(a.i("button") || a.i("mini-content"), "click", function (b) {
          b.preventDefault();
          a.W ? (a.Qa("$campaign_open", {
            $resource_type: "video"
          }), a.Kc()) : (a.Ua(), a.va && a.Qa("$campaign_open", {
            $resource_type: "link"
          }, function () {
            window.location.href = a.da;
          }));
        });
      });

      f.prototype.i = function (a) {
        return document.getElementById(f.z + "-" + a);
      };

      f.prototype.Q = function () {
        return this.i(this.fa);
      };

      f.prototype.rb = function () {
        return this.gb.props.__cmpns || (this.gb.props.__cmpns = {});
      };

      f.prototype.O = function (a, b) {
        return this.C[a] && this.C[a] <= b;
      };

      f.prototype.zc = function () {
        var a = [];
        this.v ? (this.L = this.L || "//cdn.mxpnl.com/site_media/images/icons/notifications/mini-news-dark.png", a.push(this.L)) : (this.$a ? (a.push(this.$a), this.Kb = '<img id="img" src="' + this.$a + '"/>') : this.Kb = "", this.L ? (a.push(this.L), this.Zb = '<div id="thumbborder-wrapper"><div id="thumbborder"></div></div><img id="thumbnail" src="' + this.L + '" width="' + f.K + '" height="' + f.K + '"/><div id="thumbspacer"></div>') : this.Zb = "");
        return a;
      };

      f.prototype.Ac = function () {
        var a = "",
            b = "",
            c = "";
        this.ga = document.createElement("div");
        this.ga.id = f.z + "-wrapper";
        if (this.v) a = '<div id="mini"><div id="mainbox"><div id="cancel"><div id="cancel-icon"></div></div><div id="mini-content"><div id="mini-icon"><div id="mini-icon-img"></div></div><div id="body"><div id="body-text"><div>' + this.body + '</div></div></div></div></div><div id="mini-border"></div></div>';else {
          var a = this.va || this.W ? "" : '<div id="button-close"></div>',
              e = this.W ? '<div id="button-play"></div>' : "";
          this.O("ie", 7) && (e = a = "");
          a = '<div id="takeover">' + this.Zb + '<div id="mainbox"><div id="cancel"><div id="cancel-icon"></div></div><div id="content">' + this.Kb + '<div id="title">' + this.title + '</div><div id="body">' + this.body + '</div><div id="tagline"><a href="http://mixpanel.com?from=inapp" target="_blank">POWERED BY MIXPANEL</a></div></div><div id="button">' + a + '<a id="button-link" href="' + this.da + '">' + this.Tc + "</a>" + e + "</div></div></div>";
        }
        this.gc ? (b = "//www.youtube.com/embed/" + this.gc + "?wmode=transparent&showinfo=0&modestbranding=0&rel=0&autoplay=1&loop=0&vq=hd1080", this.hc && (b += "&enablejsapi=1&html5=1&controls=0", c = '<div id="video-controls"><div id="video-progress" class="video-progress-el"><div id="video-progress-total" class="video-progress-el"></div><div id="video-elapsed" class="video-progress-el"></div></div><div id="video-time" class="video-progress-el"></div></div>')) : this.fc && (b = "//player.vimeo.com/video/" + this.fc + "?autoplay=1&title=0&byline=0&portrait=0");
        if (this.W) this.Id = '<iframe id="' + f.z + '-video-frame" width="' + this.ka + '" height="' + this.X + '"  src="' + b + '" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen="1" scrolling="no"></iframe>', c = '<div id="video-' + (this.Xa ? "" : "no") + 'flip"><div id="video"><div id="video-holder"></div>' + c + "</div></div>";
        b = c + a;
        this.Xa && (b = (this.v ? a : "") + '<div id="flipcontainer"><div id="flipper">' + (this.v ? c : b) + "</div></div>");
        this.ga.innerHTML = ('<div id="overlay" class="' + this.fa + '"><div id="campaignid-' + this.D + '"><div id="bgwrapper"><div id="bg"></div>' + b + "</div></div></div>").replace(/class=\"/g, 'class="' + f.z + "-").replace(/id=\"/g, 'id="' + f.z + "-");
      };

      f.prototype.Bc = function () {
        this.h = "dark" === this.style ? {
          Sa: "#1d1f25",
          aa: "#282b32",
          ua: "#3a4147",
          Bb: "#4a5157",
          Oc: "#32353c",
          Fb: "0.4",
          cb: "#2a3137",
          Ba: "#fff",
          hb: "#9498a3",
          Yb: "#464851",
          Aa: "#ddd"
        } : {
          Sa: "#fff",
          aa: "#e7eaee",
          ua: "#eceff3",
          Bb: "#f5f5f5",
          Oc: "#e4ecf2",
          Fb: "1.0",
          cb: "#fafafa",
          Ba: "#5c6578",
          hb: "#8b949b",
          Yb: "#ced9e6",
          Aa: "#7c8598"
        };
        var a = "0px 0px 35px 0px rgba(45, 49, 56, 0.7)",
            b = a,
            d = a,
            e = f.K + 2 * f.Fa,
            g = f.M / 1E3 + "s";
        this.v && (a = "none");
        var j = {};
        j["@media only screen and (max-width: " + (f.Ea + 20 - 1) + "px)"] = {
          "#overlay": {
            display: "none"
          }
        };
        a = {
          ".flipped": {
            transform: "rotateY(180deg)"
          },
          "#overlay": {
            position: "fixed",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%",
            overflow: "auto",
            "text-align": "center",
            "z-index": "10000",
            "font-family": '"Helvetica", "Arial", sans-serif',
            "-webkit-font-smoothing": "antialiased",
            "-moz-osx-font-smoothing": "grayscale"
          },
          "#overlay.mini": {
            height: "0",
            overflow: "visible"
          },
          "#overlay a": {
            width: "initial",
            padding: "0",
            "text-decoration": "none",
            "text-transform": "none",
            color: "inherit"
          },
          "#bgwrapper": {
            position: "relative",
            width: "100%",
            height: "100%"
          },
          "#bg": {
            position: "fixed",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%",
            "min-width": 4 * this.Xc + "px",
            "min-height": 4 * this.Wc + "px",
            "background-color": "black",
            opacity: "0.0",
            "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=60)",
            filter: "alpha(opacity=60)",
            transition: "opacity " + g
          },
          "#bg.visible": {
            opacity: f.la
          },
          ".mini #bg": {
            width: "0",
            height: "0",
            "min-width": "0"
          },
          "#flipcontainer": {
            perspective: "1000px",
            position: "absolute",
            width: "100%"
          },
          "#flipper": {
            position: "relative",
            "transform-style": "preserve-3d",
            transition: "0.3s"
          },
          "#takeover": {
            position: "absolute",
            left: "50%",
            width: f.Y + "px",
            "margin-left": Math.round(-f.Y / 2) + "px",
            "backface-visibility": "hidden",
            transform: "rotateY(0deg)",
            opacity: "0.0",
            top: f.oa + "px",
            transition: "opacity " + g + ", top " + g
          },
          "#takeover.visible": {
            opacity: "1.0",
            top: f.I + "px"
          },
          "#takeover.exiting": {
            opacity: "0.0",
            top: f.oa + "px"
          },
          "#thumbspacer": {
            height: f.Ga + "px"
          },
          "#thumbborder-wrapper": {
            position: "absolute",
            top: -f.Fa + "px",
            left: f.Y / 2 - f.Ga - f.Fa + "px",
            width: e + "px",
            height: e / 2 + "px",
            overflow: "hidden"
          },
          "#thumbborder": {
            position: "absolute",
            width: e + "px",
            height: e + "px",
            "border-radius": e + "px",
            "background-color": this.h.aa,
            opacity: "0.5"
          },
          "#thumbnail": {
            position: "absolute",
            top: "0px",
            left: f.Y / 2 - f.Ga + "px",
            width: f.K + "px",
            height: f.K + "px",
            overflow: "hidden",
            "z-index": "100",
            "border-radius": f.K + "px"
          },
          "#mini": {
            position: "absolute",
            right: "20px",
            top: f.I + "px",
            width: this.kd + "px",
            height: 2 * f.A + "px",
            "margin-top": 20 - f.A + "px",
            "backface-visibility": "hidden",
            opacity: "0.0",
            transform: "rotateX(90deg)",
            transition: "opacity 0.3s, transform 0.3s, right 0.3s"
          },
          "#mini.visible": {
            opacity: "1.0",
            transform: "rotateX(0deg)"
          },
          "#mini.exiting": {
            opacity: "0.0",
            right: "-150px"
          },
          "#mainbox": {
            "border-radius": "4px",
            "box-shadow": a,
            "text-align": "center",
            "background-color": this.h.Sa,
            "font-size": "14px",
            color: this.h.hb
          },
          "#mini #mainbox": {
            height: f.A + "px",
            "margin-top": f.A + "px",
            "border-radius": "3px",
            transition: "background-color " + g
          },
          "#mini-border": {
            height: f.A + 6 + "px",
            width: f.Ea + 6 + "px",
            position: "absolute",
            top: "-3px",
            left: "-3px",
            "margin-top": f.A + "px",
            "border-radius": "6px",
            opacity: "0.25",
            "background-color": "#fff",
            "z-index": "-1",
            "box-shadow": d
          },
          "#mini-icon": {
            position: "relative",
            display: "inline-block",
            width: "75px",
            height: f.A + "px",
            "border-radius": "3px 0 0 3px",
            "background-color": this.h.aa,
            background: "linear-gradient(135deg, " + this.h.Bb + " 0%, " + this.h.aa + " 100%)",
            transition: "background-color " + g
          },
          "#mini:hover #mini-icon": {
            "background-color": this.h.cb
          },
          "#mini:hover #mainbox": {
            "background-color": this.h.cb
          },
          "#mini-icon-img": {
            position: "absolute",
            "background-image": "url(" + this.L + ")",
            width: "48px",
            height: "48px",
            top: "20px",
            left: "12px"
          },
          "#content": {
            padding: "30px 20px 0px 20px"
          },
          "#mini-content": {
            "text-align": "left",
            height: f.A + "px",
            cursor: "pointer"
          },
          "#img": {
            width: "328px",
            "margin-top": "30px",
            "border-radius": "5px"
          },
          "#title": {
            "max-height": "600px",
            overflow: "hidden",
            "word-wrap": "break-word",
            padding: "25px 0px 20px 0px",
            "font-size": "19px",
            "font-weight": "bold",
            color: this.h.Ba
          },
          "#body": {
            "max-height": "600px",
            "margin-bottom": "25px",
            overflow: "hidden",
            "word-wrap": "break-word",
            "line-height": "21px",
            "font-size": "15px",
            "font-weight": "normal",
            "text-align": "left"
          },
          "#mini #body": {
            display: "inline-block",
            "max-width": "250px",
            margin: "0 0 0 30px",
            height: f.A + "px",
            "font-size": "16px",
            "letter-spacing": "0.8px",
            color: this.h.Ba
          },
          "#mini #body-text": {
            display: "table",
            height: f.A + "px"
          },
          "#mini #body-text div": {
            display: "table-cell",
            "vertical-align": "middle"
          },
          "#tagline": {
            "margin-bottom": "15px",
            "font-size": "10px",
            "font-weight": "600",
            "letter-spacing": "0.8px",
            color: "#ccd7e0",
            "text-align": "left"
          },
          "#tagline a": {
            color: this.h.Yb,
            transition: "color " + g
          },
          "#tagline a:hover": {
            color: this.h.Aa
          },
          "#cancel": {
            position: "absolute",
            right: "0",
            width: "8px",
            height: "8px",
            padding: "10px",
            "border-radius": "20px",
            margin: "12px 12px 0 0",
            "box-sizing": "content-box",
            cursor: "pointer",
            transition: "background-color " + g
          },
          "#mini #cancel": {
            margin: "7px 7px 0 0"
          },
          "#cancel-icon": {
            width: "8px",
            height: "8px",
            overflow: "hidden",
            "background-image": "url(//cdn.mxpnl.com/site_media/images/icons/notifications/cancel-x.png)",
            opacity: this.h.Fb
          },
          "#cancel:hover": {
            "background-color": this.h.ua
          },
          "#button": {
            display: "block",
            height: "60px",
            "line-height": "60px",
            "text-align": "center",
            "background-color": this.h.aa,
            "border-radius": "0 0 4px 4px",
            overflow: "hidden",
            cursor: "pointer",
            transition: "background-color " + g
          },
          "#button-close": {
            display: "inline-block",
            width: "9px",
            height: "60px",
            "margin-right": "8px",
            "vertical-align": "top",
            "background-image": "url(//cdn.mxpnl.com/site_media/images/icons/notifications/close-x-" + this.style + ".png)",
            "background-repeat": "no-repeat",
            "background-position": "0px 25px"
          },
          "#button-play": {
            display: "inline-block",
            width: "30px",
            height: "60px",
            "margin-left": "15px",
            "background-image": "url(//cdn.mxpnl.com/site_media/images/icons/notifications/play-" + this.style + "-small.png)",
            "background-repeat": "no-repeat",
            "background-position": "0px 15px"
          },
          "a#button-link": {
            display: "inline-block",
            "vertical-align": "top",
            "text-align": "center",
            "font-size": "17px",
            "font-weight": "bold",
            overflow: "hidden",
            "word-wrap": "break-word",
            color: this.h.Ba,
            transition: "color " + g
          },
          "#button:hover": {
            "background-color": this.h.ua,
            color: this.h.Aa
          },
          "#button:hover a": {
            color: this.h.Aa
          },
          "#video-noflip": {
            position: "relative",
            top: 2 * -this.X + "px"
          },
          "#video-flip": {
            "backface-visibility": "hidden",
            transform: "rotateY(180deg)"
          },
          "#video": {
            position: "absolute",
            width: this.ka - 1 + "px",
            height: this.X + "px",
            top: f.I + "px",
            "margin-top": "100px",
            left: "50%",
            "margin-left": Math.round(-this.ka / 2) + "px",
            overflow: "hidden",
            "border-radius": "5px",
            "box-shadow": b,
            transform: "translateZ(1px)",
            transition: "opacity " + g + ", top " + g
          },
          "#video.exiting": {
            opacity: "0.0",
            top: this.X + "px"
          },
          "#video-holder": {
            position: "absolute",
            width: this.ka - 1 + "px",
            height: this.X + "px",
            overflow: "hidden",
            "border-radius": "5px"
          },
          "#video-frame": {
            "margin-left": "-1px",
            width: this.ka + "px"
          },
          "#video-controls": {
            opacity: "0",
            transition: "opacity 0.5s"
          },
          "#video:hover #video-controls": {
            opacity: "1.0"
          },
          "#video .video-progress-el": {
            position: "absolute",
            bottom: "0",
            height: "25px",
            "border-radius": "0 0 0 5px"
          },
          "#video-progress": {
            width: "90%"
          },
          "#video-progress-total": {
            width: "100%",
            "background-color": this.h.Sa,
            opacity: "0.7"
          },
          "#video-elapsed": {
            width: "0",
            "background-color": "#6cb6f5",
            opacity: "0.9"
          },
          "#video #video-time": {
            width: "10%",
            right: "0",
            "font-size": "11px",
            "line-height": "25px",
            color: this.h.hb,
            "background-color": "#666",
            "border-radius": "0 0 5px 0"
          }
        };
        this.O("ie", 8) && c.extend(a, {
          "* html #overlay": {
            position: "absolute"
          },
          "* html #bg": {
            position: "absolute"
          },
          "html, body": {
            height: "100%"
          }
        });
        this.O("ie", 7) && c.extend(a, {
          "#mini #body": {
            display: "inline",
            zoom: "1",
            border: "1px solid " + this.h.ua
          },
          "#mini #body-text": {
            padding: "20px"
          },
          "#mini #mini-icon": {
            display: "none"
          }
        });
        var b = "backface-visibility,border-radius,box-shadow,opacity,perspective,transform,transform-style,transition".split(","),
            d = ["khtml", "moz", "ms", "o", "webkit"],
            h;

        for (h in a) {
          for (e = 0; e < b.length; e++) {
            if (g = b[e], g in a[h]) for (var i = a[h][g], k = 0; k < d.length; k++) {
              a[h]["-" + d[k] + "-" + g] = i;
            }
          }
        }

        (function (a, b) {
          function c(a) {
            var b = "",
                d;

            for (d in a) {
              var e = d.replace(/#/g, "#" + f.z + "-").replace(/\./g, "." + f.z + "-"),
                  b = b + ("\n" + e + " {"),
                  e = a[d],
                  g;

              for (g in e) {
                b += g + ":" + e[g] + ";";
              }

              b += "}";
            }

            return b;
          }

          var d = c(a) + function (a) {
            var b = "",
                d;

            for (d in a) {
              b += "\n" + d + " {" + c(a[d]) + "\n}";
            }

            return b;
          }(b),
              e = document.head || document.getElementsByTagName("head")[0] || document.documentElement,
              g = document.createElement("style");

          e.appendChild(g);
          g.setAttribute("type", "text/css");
          g.styleSheet ? g.styleSheet.cssText = d : g.textContent = d;
        })(a, j);
      };

      f.prototype.Cc = c.l(function () {
        if (this.Da) {
          var a = this;
          a.hc = "postMessage" in window;
          a.da = a.Da;
          var b = a.Da.match(/(?:youtube(?:-nocookie)?\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/ ]{11})/i),
              c = a.Da.match(/vimeo\.com\/.*?(\d+)/i);

          if (b) {
            if (a.W = m, a.gc = b[1], a.hc) window.onYouTubeIframeAPIReady = function () {
              a.i("video-frame") && a.zb();
            }, b = document.createElement("script"), b.src = "//www.youtube.com/iframe_api", c = document.getElementsByTagName("script")[0], c.parentNode.insertBefore(b, c);
          } else if (c) a.W = m, a.fc = c[1];

          if (a.O("ie", 7) || a.O("firefox", 3)) a.W = r, a.va = m;
        }
      });
      f.prototype.ub = c.l(function () {
        function a(a, b) {
          var c = {};
          if (document.defaultView && document.defaultView.getComputedStyle) c = document.defaultView.getComputedStyle(a, n);else if (a.currentStyle) c = a.currentStyle;
          return c[b];
        }

        var b = this;
        c.o(b.i("bg"), "click", function () {
          b.Ua();
        });

        if (this.D) {
          var d = this.i("overlay");
          d && "hidden" !== a(d, "visibility") && "none" !== a(d, "display") && this.vb();
        }
      });
      f.prototype.vb = c.l(function (a) {
        if (!this.Pb) this.Pb = m, this.D && (this.rb()[this.D] = 1 * new Date(), this.gb.save()), this.Qa("$campaign_delivery", a), this.eb.people.append({
          $campaigns: this.D,
          $notifications: {
            campaign_id: this.D,
            message_id: this.Qb,
            type: "web",
            time: new Date()
          }
        });
      });

      f.prototype.Gc = function (a) {
        var b = this;
        if (0 === this.ya.length) a();else {
          for (var c = 0, e = [], g = function g() {
            c++;
            c === b.ya.length && a && (a(), a = n);
          }, f = 0; f < this.ya.length; f++) {
            var h = new Image();
            h.onload = g;
            h.src = this.ya[f];
            h.complete && g();
            e.push(h);
          }

          this.O("ie", 7) && setTimeout(function () {
            var b = m;

            for (f = 0; f < e.length; f++) {
              e[f].complete || (b = r);
            }

            b && a && (a(), a = n);
          }, 500);
        }
      };

      f.prototype.wb = c.l(function () {
        window.clearInterval(this.Mc);
        this.ga.style.visibility = "hidden";
        this.q.removeChild(this.ga);
      });

      f.prototype.xb = function () {
        function a(a) {
          if (a in e) return m;
          if (!c) for (var a = a[0].toUpperCase() + a.slice(1), a = ["O" + a, "Webkit" + a, "Moz" + a], b = 0; b < a.length; b++) {
            if (a[b] in e) return m;
          }
          return r;
        }

        function b(a) {
          return (a = navigator.userAgent.match(a)) && a[1];
        }

        this.C = {};
        this.C.chrome = b(/Chrome\/(\d+)/);
        this.C.firefox = b(/Firefox\/(\d+)/);
        this.C.ie = b(/MSIE (\d+).+/);
        !this.C.ie && !window.ActiveXObject && "ActiveXObject" in window && (this.C.ie = 11);
        if (this.q = document.body || document.getElementsByTagName("body")[0]) this.Xc = Math.max(this.q.scrollWidth, document.documentElement.scrollWidth, this.q.offsetWidth, document.documentElement.offsetWidth, this.q.clientWidth, document.documentElement.clientWidth), this.Wc = Math.max(this.q.scrollHeight, document.documentElement.scrollHeight, this.q.offsetHeight, document.documentElement.offsetHeight, this.q.clientHeight, document.documentElement.clientHeight);
        var c = this.C.ie,
            e = document.createElement("div").style;
        this.ec = this.q && a("transition") && a("transform");
        this.Xa = (33 <= this.C.chrome || 15 <= this.C.firefox) && this.q && a("backfaceVisibility") && a("perspective") && a("transform");
      };

      f.prototype.Kc = c.l(function () {
        function a() {
          window.YT && window.YT.loaded && b.zb();
          b.xd = m;
          b.Q().style.visibility = "hidden";
        }

        var b = this,
            c = [{
          s: b.Q(),
          m: "opacity",
          start: 1,
          k: 0
        }, {
          s: b.Q(),
          m: "top",
          start: f.I,
          k: -500
        }, {
          s: b.i("video-noflip"),
          m: "opacity",
          start: 0,
          k: 1
        }, {
          s: b.i("video-noflip"),
          m: "top",
          start: 2 * -b.X,
          k: 0
        }];

        if (b.v) {
          var e = b.i("bg"),
              g = b.i("overlay");
          e.style.width = "100%";
          e.style.height = "100%";
          g.style.width = "100%";
          b.N(b.Q(), "exiting");
          b.N(e, "visible");
          c.push({
            s: b.i("bg"),
            m: "opacity",
            start: 0,
            k: f.la
          });
        }

        b.i("video-holder").innerHTML = b.Id;
        b.Xa ? (b.N("flipper", "flipped"), setTimeout(a, f.M)) : b.pa(c, f.M, a);
      });

      f.prototype.Qa = function (a, b, d) {
        this.D ? (b = b || {}, b = c.extend(b, {
          campaign_id: this.D,
          message_id: this.Qb,
          message_type: "web_inapp",
          message_subtype: this.fa
        }), this.eb.track(a, b, d)) : d && d.call();
      };

      f.prototype.zb = c.l(function () {
        var a = this;

        if (!a.Jd) {
          a.Jd = m;
          var b = a.i("video-elapsed"),
              d = a.i("video-time"),
              e = a.i("video-progress");
          new window.YT.Player(f.z + "-video-frame", {
            events: {
              onReady: function onReady(g) {
                function f(a) {
                  var a = Math.round(i - a),
                      b = Math.floor(a / 60),
                      c = Math.floor(b / 60),
                      a = a - 60 * b;
                  d.innerHTML = "-" + (c ? c + ":" : "") + ("00" + (b - 60 * c)).slice(-2) + ":" + ("00" + a).slice(-2);
                }

                var h = g.target,
                    i = h.getDuration();
                f(0);
                a.Mc = window.setInterval(function () {
                  var a = h.getCurrentTime();
                  b.style.width = 100 * (a / i) + "%";
                  f(a);
                }, 250);
                c.o(e, "click", function (a) {
                  a = Math.max(0, a.pageX - e.getBoundingClientRect().left);
                  h.seekTo(i * a / e.clientWidth, m);
                });
              }
            }
          });
        }
      });
      h.prototype.init = h.prototype.U;
      h.prototype.reset = h.prototype.reset;
      h.prototype.disable = h.prototype.disable;
      h.prototype.time_event = h.prototype.Ad;
      h.prototype.track = h.prototype.J;
      h.prototype.track_links = h.prototype.Dd;
      h.prototype.track_forms = h.prototype.Cd;
      h.prototype.track_pageview = h.prototype.ac;
      h.prototype.register = h.prototype.ia;
      h.prototype.register_once = h.prototype.G;
      h.prototype.unregister = h.prototype.Ca;
      h.prototype.identify = h.prototype.Ya;
      h.prototype.alias = h.prototype.Nc;
      h.prototype.name_tag = h.prototype.jd;
      h.prototype.set_config = h.prototype.Wb;
      h.prototype.get_config = h.prototype.c;
      h.prototype.get_property = h.prototype.xa;
      h.prototype.get_distinct_id = h.prototype.T;
      h.prototype.toString = h.prototype.toString;
      h.prototype._check_and_handle_notifications = h.prototype.kb;
      h.prototype._show_notification = h.prototype.yb;
      o.prototype.properties = o.prototype.ha;
      o.prototype.update_search_keyword = o.prototype.dc;
      o.prototype.update_referrer_info = o.prototype.ib;
      o.prototype.get_cross_subdomain = o.prototype.bd;
      o.prototype.clear = o.prototype.clear;
      p.prototype.set = p.prototype.set;
      p.prototype.set_once = p.prototype.Xb;
      p.prototype.increment = p.prototype.Mb;
      p.prototype.append = p.prototype.append;
      p.prototype.union = p.prototype.bc;
      p.prototype.track_charge = p.prototype.Bd;
      p.prototype.clear_charges = p.prototype.Sc;
      p.prototype.delete_user = p.prototype.Uc;
      p.prototype.toString = p.prototype.toString;
      c.od(h);
      var y = {};

      (function () {
        L = 1;
        s = window.mixpanel;
        c.d(s) ? k.ca('"mixpanel" object not initialized. Ensure you are using the latest version of the Mixpanel JS Library along with the snippet we provide.') : s.__loaded || s.config && s.persistence ? k.error("Mixpanel library has already been downloaded at least once.") : 1.1 > (s.__SV || 0) ? k.ca("Version mismatch; please ensure you're using the latest version of the Mixpanel code snippet.") : (c.a(s._i, function (a) {
          a && c.isArray(a) && (y[a[a.length - 1]] = H.apply(this, a));
        }), X(), s.init(), c.a(y, function (a) {
          a.sa();
        }), W());
      })();
    })();
  })(); // end http://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js

}
/* eslint-enable */

/* jshint ignore:end */

/**
 * @param {string} mixpanelToken
 * @returns {object} mixpanel
 */


module.exports.init = function () {
  window.mixpanel.init.apply(window, arguments);
  return window.mixpanel;
};
}, {}];
window.modules["170"] = [function(require,module,exports){"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-disable */
// Dependencies from Omniture.

/*
 ============== DO NOT ALTER ANYTHING BELOW THIS LINE ! ============

 Adobe Visitor API for JavaScript version: 1.3.2
 Copyright 1996-2013 Adobe, Inc. All Rights Reserved
 More info available at http://www.omniture.com
*/
function Visitor(k, s) {
  if (!k) throw "Visitor requires Adobe Marketing Cloud Org ID";
  var a = this;
  a.version = "1.3.2";
  var h = window,
      m = h.Visitor;
  h.s_c_in || (h.s_c_il = [], h.s_c_in = 0);
  a._c = "Visitor";
  a._il = h.s_c_il;
  a._in = h.s_c_in;
  a._il[a._in] = a;
  h.s_c_in++;
  var x = h.document,
      j = h.O;
  j || (j = null);
  var i = h.P;
  i || (i = !0);
  var q = h.N;
  q || (q = !1);

  a.C = function (a) {
    var c = 0,
        b,
        e;
    if (a) for (b = 0; b < a.length; b++) {
      e = a.charCodeAt(b), c = (c << 5) - c + e, c &= c;
    }
    return c;
  };

  a.m = function (a) {
    var c = "0123456789",
        b = "",
        e = "",
        f,
        g = 8,
        h = 10,
        i = 10;

    if (1 == a) {
      c += "ABCDEF";

      for (a = 0; 16 > a; a++) {
        f = Math.floor(Math.random() * g), b += c.substring(f, f + 1), f = Math.floor(Math.random() * g), e += c.substring(f, f + 1), g = 16;
      }

      return b + "-" + e;
    }

    for (a = 0; 19 > a; a++) {
      f = Math.floor(Math.random() * h), b += c.substring(f, f + 1), 0 == a && 9 == f ? h = 3 : (1 == a || 2 == a) && 10 != h && 2 > f ? h = 10 : 2 < a && (h = 10), f = Math.floor(Math.random() * i), e += c.substring(f, f + 1), 0 == a && 9 == f ? i = 3 : (1 == a || 2 == a) && 10 != i && 2 > f ? i = 10 : 2 < a && (i = 10);
    }

    return b + e;
  };

  a.I = function () {
    var a;
    !a && h.location && (a = h.location.hostname);
    if (a) if (/^[0-9.]+$/.test(a)) a = "";else {
      var c = a.split("."),
          b = c.length - 1,
          e = b - 1;
      1 < b && 2 >= c[b].length && (2 == c[b - 1].length || 0 > ",ac,ad,ae,af,ag,ai,al,am,an,ao,aq,ar,as,at,au,aw,ax,az,ba,bb,be,bf,bg,bh,bi,bj,bm,bo,br,bs,bt,bv,bw,by,bz,ca,cc,cd,cf,cg,ch,ci,cl,cm,cn,co,cr,cu,cv,cw,cx,cz,de,dj,dk,dm,do,dz,ec,ee,eg,es,eu,fi,fm,fo,fr,ga,gb,gd,ge,gf,gg,gh,gi,gl,gm,gn,gp,gq,gr,gs,gt,gw,gy,hk,hm,hn,hr,ht,hu,id,ie,im,in,io,iq,ir,is,it,je,jo,jp,kg,ki,km,kn,kp,kr,ky,kz,la,lb,lc,li,lk,lr,ls,lt,lu,lv,ly,ma,mc,md,me,mg,mh,mk,ml,mn,mo,mp,mq,mr,ms,mt,mu,mv,mw,mx,my,na,nc,ne,nf,ng,nl,no,nr,nu,nz,om,pa,pe,pf,ph,pk,pl,pm,pn,pr,ps,pt,pw,py,qa,re,ro,rs,ru,rw,sa,sb,sc,sd,se,sg,sh,si,sj,sk,sl,sm,sn,so,sr,st,su,sv,sx,sy,sz,tc,td,tf,tg,th,tj,tk,tl,tm,tn,to,tp,tt,tv,tw,tz,ua,ug,uk,us,uy,uz,va,vc,ve,vg,vi,vn,vu,wf,ws,yt,nd,".indexOf("," + c[b] + ",")) && e--;
      if (0 < e) for (a = ""; b >= e;) {
        a = c[b] + (a ? "." : "") + a, b--;
      }
    }
    return a;
  };

  a.cookieRead = function (a) {
    var a = encodeURIComponent(a),
        c = (";" + x.cookie).split(" ").join(";"),
        b = c.indexOf(";" + a + "="),
        e = 0 > b ? b : c.indexOf(";", b + 1);
    return 0 > b ? "" : decodeURIComponent(c.substring(b + 2 + a.length, 0 > e ? c.length : e));
  };

  a.cookieWrite = function (d, c, b) {
    var e = a.cookieLifetime,
        f,
        c = "" + c,
        e = e ? ("" + e).toUpperCase() : "";
    b && "SESSION" != e && "NONE" != e ? (f = "" != c ? parseInt(e ? e : 0) : -60) ? (b = new Date(), b.setTime(b.getTime() + 1E3 * f)) : 1 == b && (b = new Date(), f = b.getYear(), b.setYear(f + 2 + (1900 > f ? 1900 : 0))) : b = 0;
    return d && "NONE" != e ? (x.cookie = encodeURIComponent(d) + "=" + encodeURIComponent(c) + "; path=/;" + (b ? " expires=" + b.toGMTString() + ";" : "") + (a.cookieDomain ? " domain=" + a.cookieDomain + ";" : ""), a.cookieRead(d) == c) : 0;
  };

  a.e = j;

  a.w = function (a, c) {
    try {
      "function" == typeof a ? a.apply(h, c) : a[1].apply(a[0], c);
    } catch (b) {}
  };

  a.L = function (d, c) {
    c && (a.e == j && (a.e = {}), void 0 == a.e[d] && (a.e[d] = []), a.e[d].push(c));
  };

  a.l = function (d, c) {
    if (a.e != j) {
      var b = a.e[d];
      if (b) for (; 0 < b.length;) {
        a.w(b.shift(), c);
      }
    }
  };

  a.j = j;

  a.J = function (d, c, b) {
    !c && b && b();
    var e = x.getElementsByTagName("HEAD")[0],
        f = x.createElement("SCRIPT");
    f.type = "text/javascript";
    f.setAttribute("async", "async");
    f.src = c;
    e.firstChild ? e.insertBefore(f, e.firstChild) : e.appendChild(f);
    b && (a.j == j && (a.j = {}), a.j[d] = setTimeout(b, a.loadTimeout));
  };

  a.H = function (d) {
    a.j != j && a.j[d] && (clearTimeout(a.j[d]), a.j[d] = 0);
  };

  a.D = q;
  a.F = q;

  a.isAllowed = function () {
    if (!a.D && (a.D = i, a.cookieRead(a.cookieName) || a.cookieWrite(a.cookieName, "T", 1))) a.F = i;
    return a.F;
  };

  a.a = j;
  a.c = j;
  var v = a.V;
  v || (v = "MC");
  var n = a.Y;
  n || (n = "MCMID");
  var w = a.X;
  w || (w = "MCCIDH");
  var y = a.W;
  y || (y = "MCAS");
  var t = a.T;
  t || (t = "A");
  var l = a.Q;
  l || (l = "MCAID");
  var u = a.U;
  u || (u = "AAM");
  var r = a.S;
  r || (r = "MCAAMLH");
  var o = a.R;
  o || (o = "MCAAMB");
  var p = a.Z;
  p || (p = "NONE");
  a.t = 0;

  a.B = function () {
    if (!a.t) {
      var d = a.version;
      a.audienceManagerServer && (d += "|" + a.audienceManagerServer);
      a.audienceManagerServerSecure && (d += "|" + a.audienceManagerServerSecure);
      if (a.audienceManagerCustomerIDDPIDs) for (var c in a.audienceManagerCustomerIDDPIDs) {
        !Object.prototype[c] && a.audienceManagerCustomerIDDPIDs[c] && (d += c + "=" + a.audienceManagerCustomerIDDPIDs[c]);
      }
      a.t = a.C(d);
    }

    return a.t;
  };

  a.G = q;

  a.h = function () {
    if (!a.G) {
      a.G = i;
      var d = a.B(),
          c = q,
          b = a.cookieRead(a.cookieName),
          e,
          f,
          g,
          h = new Date();
      a.a == j && (a.a = {});

      if (b && "T" != b) {
        b = b.split("|");
        b[0].match(/^[\-0-9]+$/) && (parseInt(b[0]) != d && (c = i), b.shift());
        1 == b.length % 2 && b.pop();

        for (d = 0; d < b.length; d += 2) {
          e = b[d].split("-"), f = e[0], g = b[d + 1], e = 1 < e.length ? parseInt(e[1]) : 0, c && (f == w && (g = ""), 0 < e && (e = h.getTime() / 1E3 - 60)), f && g && (a.d(f, g, 1), 0 < e && (a.a["expire" + f] = e, h.getTime() >= 1E3 * e && (a.c || (a.c = {}), a.c[f] = i)));
        }
      }

      if (!a.b(l) && (b = a.cookieRead("s_vi"))) b = b.split("|"), 1 < b.length && 0 <= b[0].indexOf("v1") && (g = b[1], d = g.indexOf("["), 0 <= d && (g = g.substring(0, d)), g && g.match(/^[0-9a-fA-F\-]+$/) && a.d(l, g));
    }
  };

  a.M = function () {
    var d = a.B(),
        c,
        b;

    for (c in a.a) {
      !Object.prototype[c] && a.a[c] && "expire" != c.substring(0, 6) && (b = a.a[c], d += (d ? "|" : "") + c + (a.a["expire" + c] ? "-" + a.a["expire" + c] : "") + "|" + b);
    }

    a.cookieWrite(a.cookieName, d, 1);
  };

  a.b = function (d, c) {
    return a.a != j && (c || !a.c || !a.c[d]) ? a.a[d] : j;
  };

  a.d = function (d, c, b) {
    a.a == j && (a.a = {});
    a.a[d] = c;
    b || a.M();
  };

  a.p = function (d, c) {
    var b = new Date();
    b.setTime(b.getTime() + 1E3 * c);
    a.a == j && (a.a = {});
    a.a["expire" + d] = Math.floor(b.getTime() / 1E3);
    0 > c && (a.c || (a.c = {}), a.c[d] = i);
  };

  a.A = function (a) {
    if (a && ("object" == _typeof(a) && (a = a.d_mid ? a.d_mid : a.visitorID ? a.visitorID : a.id ? a.id : a.uuid ? a.uuid : "" + a), a && (a = a.toUpperCase(), "NOTARGET" == a && (a = p)), !a || a != p && !a.match(/^[0-9a-fA-F\-]+$/))) a = "";
    return a;
  };

  a.i = function (d, c) {
    a.H(d);
    a.g != j && (a.g[d] = q);

    if (d == v) {
      var b = a.b(n);

      if (!b) {
        b = "object" == _typeof(c) && c.mid ? c.mid : a.A(c);

        if (!b) {
          if (a.r) {
            a.getAnalyticsVisitorID(null, !1, !0);
            return;
          }

          b = a.m();
        }

        a.d(n, b);
      }

      if (!b || b == p) b = "";
      "object" == _typeof(c) && ((c.d_region || c.dcs_region || c.d_blob || c.blob) && a.i(u, c), a.r && c.mid && a.i(t, {
        id: c.id
      }));
      a.l(n, [b]);
    }

    if (d == u && "object" == _typeof(c)) {
      b = 604800;
      void 0 != c.id_sync_ttl && c.id_sync_ttl && (b = parseInt(c.id_sync_ttl));
      var e = a.b(r);
      e || ((e = c.d_region) || (e = c.dcs_region), e && (a.p(r, b), a.d(r, e)));
      e || (e = "");
      a.l(r, [e]);
      e = a.b(o);
      if (c.d_blob || c.blob) (e = c.d_blob) || (e = c.blob), a.p(o, b), a.d(o, e);
      e || (e = "");
      a.l(o, [e]);
      !c.error_msg && a.o && a.d(w, a.o);
    }

    if (d == t) {
      b = a.b(l);
      b || ((b = a.A(c)) ? a.p(o, -1) : b = p, a.d(l, b));
      if (!b || b == p) b = "";
      a.l(l, [b]);
    }
  };

  a.g = j;

  a.n = function (d, c, b, e) {
    var f = "",
        g;

    if (a.isAllowed() && (a.h(), f = a.b(d), !f && (d == n ? g = v : d == r || d == o ? g = u : d == l && (g = t), g))) {
      if (c && (a.g == j || !a.g[g])) a.g == j && (a.g = {}), a.g[g] = i, a.J(g, c, function () {
        if (!a.b(d)) {
          var b = "";
          d == n && (b = a.m());
          a.i(g, b);
        }
      });
      a.L(d, b);
      c || a.i(g, {
        id: p
      });
      return "";
    }

    if ((d == n || d == l) && f == p) f = "", e = i;
    b && e && a.w(b, [f]);
    return f;
  };

  a._setMarketingCloudFields = function (d) {
    a.h();
    a.i(v, d);
  };

  a.setMarketingCloudVisitorID = function (d) {
    a._setMarketingCloudFields(d);
  };

  a.r = q;

  a.getMarketingCloudVisitorID = function (d, c) {
    return a.isAllowed() ? (a.marketingCloudServer && 0 > a.marketingCloudServer.indexOf(".demdex.net") && (a.r = i), a.n(n, a.s("_setMarketingCloudFields"), d, c)) : "";
  };

  a.K = function () {
    a.getAudienceManagerBlob();
  };

  a.f = {};
  a.z = q;
  a.o = "";

  a.setCustomerIDs = function (d) {
    a.f = d;

    if (a.isAllowed()) {
      a.h();
      var d = a.b(w),
          c = "",
          b,
          e;
      d || (d = 0);

      for (b in a.f) {
        e = a.f[b], !Object.prototype[b] && e && (c += (c ? "|" : "") + b + "|" + e);
      }

      a.o = a.C(c);
      a.o != d && (a.z = i, a.K());
    }
  };

  a.getCustomerIDs = function () {
    return a.f;
  };

  a._setAnalyticsFields = function (d) {
    a.h();
    a.i(t, d);
  };

  a.setAnalyticsVisitorID = function (d) {
    a._setAnalyticsFields(d);
  };

  a.getAnalyticsVisitorID = function (d, c, b) {
    if (a.isAllowed()) {
      var e = "";
      b || (e = a.getMarketingCloudVisitorID(function () {
        a.getAnalyticsVisitorID(d, i);
      }));

      if (e || b) {
        var f = b ? a.marketingCloudServer : a.trackingServer,
            g = "";
        a.loadSSL && (b ? a.marketingCloudServerSecure && (f = a.marketingCloudServerSecure) : a.trackingServerSecure && (f = a.trackingServerSecure));
        f && (g = "http" + (a.loadSSL ? "s" : "") + "://" + f + "/id?callback=s_c_il%5B" + a._in + "%5D._set" + (b ? "MarketingCloud" : "Analytics") + "Fields&mcorgid=" + encodeURIComponent(a.marketingCloudOrgID) + (e ? "&mid=" + e : ""));
        return a.n(b ? n : l, g, d, c);
      }
    }

    return "";
  };

  a._setAudienceManagerFields = function (d) {
    a.h();
    a.i(u, d);
  };

  a.s = function (d) {
    var c = a.audienceManagerServer,
        b = "",
        e = a.b(n),
        f = a.b(o, i),
        g = a.b(l),
        g = g && g != p ? "&d_cid_ic=AVID%01" + encodeURIComponent(g) : "",
        h = "",
        j,
        k;
    a.loadSSL && a.audienceManagerServerSecure && (c = a.audienceManagerServerSecure);

    if (c) {
      if (a.f) for (j in a.f) {
        if (!Object.prototype[j] && (b = a.f[j])) g += "&d_cid_ic=" + encodeURIComponent(j) + "%01" + encodeURIComponent(b), a.audienceManagerCustomerIDDPIDs && (k = a.audienceManagerCustomerIDDPIDs[j]) && (h += "&d_cid=" + k + "%01" + encodeURIComponent(b));
      }
      d || (d = "_setAudienceManagerFields");
      b = "http" + (a.loadSSL ? "s" : "") + "://" + c + "/id?d_rtbd=json&d_ver=2" + (!e && a.r ? "&d_verify=1" : "") + "&d_orgid=" + encodeURIComponent(a.marketingCloudOrgID) + (e ? "&d_mid=" + e : "") + (f ? "&d_blob=" + encodeURIComponent(f) : "") + g + h + "&d_cb=s_c_il%5B" + a._in + "%5D." + d;
    }

    return b;
  };

  a.getAudienceManagerLocationHint = function (d, c) {
    if (a.isAllowed() && a.getMarketingCloudVisitorID(function () {
      a.getAudienceManagerLocationHint(d, i);
    })) {
      var b = a.b(l);
      b || (b = a.getAnalyticsVisitorID(function () {
        a.getAudienceManagerLocationHint(d, i);
      }));
      if (b) return a.n(r, a.s(), d, c);
    }

    return "";
  };

  a.getAudienceManagerBlob = function (d, c) {
    if (a.isAllowed() && a.getMarketingCloudVisitorID(function () {
      a.getAudienceManagerBlob(d, i);
    })) {
      var b = a.b(l);
      b || (b = a.getAnalyticsVisitorID(function () {
        a.getAudienceManagerBlob(d, i);
      }));
      if (b) return b = a.s(), a.z && a.p(o, -1), a.n(o, b, d, c);
    }

    return "";
  };

  m.AUTH_STATE_UNAUTHENTICATED = 0;
  m.AUTH_STATE_AUTHENTICATED = 1;
  m.AUTH_STATE_ASSUMED_AUTHENTICATED = 2;
  m.AUTH_STATE_LOGGEDOUT = 3;

  a.setAuthState = function (d) {
    a.isAllowed() && (a.h(), a.d(y, d));
  };

  a.getAuthState = function () {
    return a.isAllowed() ? (a.h(), a.b(y)) : 0;
  };

  a.k = "";
  a.q = {};
  a.u = "";
  a.v = {};

  a.getSupplementalDataID = function (d, c) {
    !a.k && !c && (a.k = a.m(1));
    var b = a.k;
    a.u && !a.v[d] ? (b = a.u, a.v[d] = i) : b && (a.q[d] && (a.u = a.k, a.v = a.q, a.k = b = !c ? a.m(1) : "", a.q = {}), b && (a.q[d] = i));
    return b;
  };

  0 > k.indexOf("@") && (k += "@AdobeOrg");
  a.marketingCloudOrgID = k;
  a.namespace = s;
  a.cookieName = "AMCV_" + k;
  a.cookieDomain = a.I();
  a.cookieDomain == h.location.hostname && (a.cookieDomain = "");

  if (s) {
    var m = "AMCV_" + s,
        A = a.cookieRead(a.cookieName),
        z = a.cookieRead(m);
    !A && z && (a.cookieWrite(a.cookieName, z, 1), a.cookieWrite(m, "", -60));
  }

  a.loadSSL = 0 <= h.location.protocol.toLowerCase().indexOf("https");
  a.loadTimeout = 500;
  a.marketingCloudServer = a.audienceManagerServer = "dpm.demdex.net";
}

Visitor.getInstance = function (k, s) {
  var a,
      h = window.s_c_il,
      m;
  0 > k.indexOf("@") && (k += "@AdobeOrg");
  if (h) for (m = 0; m < h.length; m++) {
    if ((a = h[m]) && "Visitor" == a._c && (a.marketingCloudOrgID == k || s && a.namespace == s)) return a;
  }
  return new Visitor(k, s);
};
/*
 ============== DO NOT ALTER ANYTHING BELOW THIS LINE ! ===============

 AppMeasurement for JavaScript version: 1.4.1
 Copyright 1996-2013 Adobe, Inc. All Rights Reserved
 More info available at http://www.omniture.com
*/


function AppMeasurement() {
  var s = this;
  s.version = "1.4.1";
  var w = window;
  if (!w.s_c_in) w.s_c_il = [], w.s_c_in = 0;
  s._il = w.s_c_il;
  s._in = w.s_c_in;
  s._il[s._in] = s;
  w.s_c_in++;
  s._c = "s_c";
  var k = w.sb;
  k || (k = null);
  var m = w,
      i,
      o;

  try {
    i = m.parent;

    for (o = m.location; i && i.location && o && "" + i.location != "" + o && m.location && "" + i.location != "" + m.location && i.location.host == o.host;) {
      m = i, i = m.parent;
    }
  } catch (p) {}

  s.eb = function (s) {
    try {
      console.log(s);
    } catch (a) {}
  };

  s.ta = function (s) {
    return "" + parseInt(s) == "" + s;
  };

  s.replace = function (s, a, c) {
    if (!s || s.indexOf(a) < 0) return s;
    return s.split(a).join(c);
  };

  s.escape = function (b) {
    var a, c;
    if (!b) return b;
    b = encodeURIComponent(b);

    for (a = 0; a < 7; a++) {
      c = "+~!*()'".substring(a, a + 1), b.indexOf(c) >= 0 && (b = s.replace(b, c, "%" + c.charCodeAt(0).toString(16).toUpperCase()));
    }

    return b;
  };

  s.unescape = function (b) {
    if (!b) return b;
    b = b.indexOf("+") >= 0 ? s.replace(b, "+", " ") : b;

    try {
      return decodeURIComponent(b);
    } catch (a) {}

    return unescape(b);
  };

  s.Va = function () {
    var b = w.location.hostname,
        a = s.fpCookieDomainPeriods,
        c;
    if (!a) a = s.cookieDomainPeriods;

    if (b && !s.cookieDomain && !/^[0-9.]+$/.test(b) && (a = a ? parseInt(a) : 2, a = a > 2 ? a : 2, c = b.lastIndexOf("."), c >= 0)) {
      for (; c >= 0 && a > 1;) {
        c = b.lastIndexOf(".", c - 1), a--;
      }

      s.cookieDomain = c > 0 ? b.substring(c) : b;
    }

    return s.cookieDomain;
  };

  s.c_r = s.cookieRead = function (b) {
    b = s.escape(b);
    var a = " " + s.d.cookie,
        c = a.indexOf(" " + b + "="),
        e = c < 0 ? c : a.indexOf(";", c);
    b = c < 0 ? "" : s.unescape(a.substring(c + 2 + b.length, e < 0 ? a.length : e));
    return b != "[[B]]" ? b : "";
  };

  s.c_w = s.cookieWrite = function (b, a, c) {
    var e = s.Va(),
        d = s.cookieLifetime,
        f;
    a = "" + a;
    d = d ? ("" + d).toUpperCase() : "";
    c && d != "SESSION" && d != "NONE" && ((f = a != "" ? parseInt(d ? d : 0) : -60) ? (c = new Date(), c.setTime(c.getTime() + f * 1E3)) : c == 1 && (c = new Date(), f = c.getYear(), c.setYear(f + 5 + (f < 1900 ? 1900 : 0))));
    if (b && d != "NONE") return s.d.cookie = b + "=" + s.escape(a != "" ? a : "[[B]]") + "; path=/;" + (c && d != "SESSION" ? " expires=" + c.toGMTString() + ";" : "") + (e ? " domain=" + e + ";" : ""), s.cookieRead(b) == a;
    return 0;
  };

  s.C = [];

  s.B = function (b, a, c) {
    if (s.ma) return 0;
    if (!s.maxDelay) s.maxDelay = 250;
    var e = 0,
        d = new Date().getTime() + s.maxDelay,
        f = s.d.qb,
        g = ["webkitvisibilitychange", "visibilitychange"];
    if (!f) f = s.d.rb;

    if (f && f == "prerender") {
      if (!s.X) {
        s.X = 1;

        for (c = 0; c < g.length; c++) {
          s.d.addEventListener(g[c], function () {
            var a = s.d.qb;
            if (!a) a = s.d.rb;
            if (a == "visible") s.X = 0, s.delayReady();
          });
        }
      }

      e = 1;
      d = 0;
    } else c || s.q("_d") && (e = 1);

    e && (s.C.push({
      m: b,
      a: a,
      t: d
    }), s.X || setTimeout(s.delayReady, s.maxDelay));
    return e;
  };

  s.delayReady = function () {
    var b = new Date().getTime(),
        a = 0,
        c;

    for (s.q("_d") && (a = 1); s.C.length > 0;) {
      c = s.C.shift();

      if (a && !c.t && c.t > b) {
        s.C.unshift(c);
        setTimeout(s.delayReady, parseInt(s.maxDelay / 2));
        break;
      }

      s.ma = 1;
      s[c.m].apply(s, c.a);
      s.ma = 0;
    }
  };

  s.setAccount = s.sa = function (b) {
    var a, c;
    if (!s.B("setAccount", arguments)) if (s.account = b, s.allAccounts) {
      a = s.allAccounts.concat(b.split(","));
      s.allAccounts = [];
      a.sort();

      for (c = 0; c < a.length; c++) {
        (c == 0 || a[c - 1] != a[c]) && s.allAccounts.push(a[c]);
      }
    } else s.allAccounts = b.split(",");
  };

  s.foreachVar = function (b, a) {
    var c,
        e,
        d,
        f,
        g = "";
    d = e = "";
    if (s.lightProfileID) c = s.H, (g = s.lightTrackVars) && (g = "," + g + "," + s.ba.join(",") + ",");else {
      c = s.c;
      if (s.pe || s.linkType) if (g = s.linkTrackVars, e = s.linkTrackEvents, s.pe && (d = s.pe.substring(0, 1).toUpperCase() + s.pe.substring(1), s[d])) g = s[d].pb, e = s[d].ob;
      g && (g = "," + g + "," + s.z.join(",") + ",");
      e && g && (g += ",events,");
    }
    a && (a = "," + a + ",");

    for (e = 0; e < c.length; e++) {
      d = c[e], (f = s[d]) && (!g || g.indexOf("," + d + ",") >= 0) && (!a || a.indexOf("," + d + ",") >= 0) && b(d, f);
    }
  };

  s.J = function (b, a, c, e, d) {
    var f = "",
        g,
        j,
        w,
        q,
        i = 0;
    b == "contextData" && (b = "c");

    if (a) {
      for (g in a) {
        if (!Object.prototype[g] && (!d || g.substring(0, d.length) == d) && a[g] && (!c || c.indexOf("," + (e ? e + "." : "") + g + ",") >= 0)) {
          w = !1;
          if (i) for (j = 0; j < i.length; j++) {
            g.substring(0, i[j].length) == i[j] && (w = !0);
          }
          if (!w && (f == "" && (f += "&" + b + "."), j = a[g], d && (g = g.substring(d.length)), g.length > 0)) if (w = g.indexOf("."), w > 0) j = g.substring(0, w), w = (d ? d : "") + j + ".", i || (i = []), i.push(w), f += s.J(j, a, c, e, w);else if (typeof j == "boolean" && (j = j ? "true" : "false"), j) {
            if (e == "retrieveLightData" && d.indexOf(".contextData.") < 0) switch (w = g.substring(0, 4), q = g.substring(4), g) {
              case "transactionID":
                g = "xact";
                break;

              case "channel":
                g = "ch";
                break;

              case "campaign":
                g = "v0";
                break;

              default:
                s.ta(q) && (w == "prop" ? g = "c" + q : w == "eVar" ? g = "v" + q : w == "list" ? g = "l" + q : w == "hier" && (g = "h" + q, j = j.substring(0, 255)));
            }
            f += "&" + s.escape(g) + "=" + s.escape(j);
          }
        }
      }

      f != "" && (f += "&." + b);
    }

    return f;
  };

  s.Xa = function () {
    var b = "",
        a,
        c,
        e,
        d,
        f,
        g,
        j,
        w,
        i = "",
        k = "",
        m = c = "";
    if (s.lightProfileID) a = s.H, (i = s.lightTrackVars) && (i = "," + i + "," + s.ba.join(",") + ",");else {
      a = s.c;
      if (s.pe || s.linkType) if (i = s.linkTrackVars, k = s.linkTrackEvents, s.pe && (c = s.pe.substring(0, 1).toUpperCase() + s.pe.substring(1), s[c])) i = s[c].pb, k = s[c].ob;
      i && (i = "," + i + "," + s.z.join(",") + ",");
      k && (k = "," + k + ",", i && (i += ",events,"));
      s.events2 && (m += (m != "" ? "," : "") + s.events2);
    }
    s.AudienceManagement && s.AudienceManagement.isReady() && (b += s.J("d", s.AudienceManagement.getEventCallConfigParams()));

    for (c = 0; c < a.length; c++) {
      d = a[c];
      f = s[d];
      e = d.substring(0, 4);
      g = d.substring(4);
      !f && d == "events" && m && (f = m, m = "");

      if (f && (!i || i.indexOf("," + d + ",") >= 0)) {
        switch (d) {
          case "supplementalDataID":
            d = "sdid";
            break;

          case "timestamp":
            d = "ts";
            break;

          case "dynamicVariablePrefix":
            d = "D";
            break;

          case "visitorID":
            d = "vid";
            break;

          case "marketingCloudVisitorID":
            d = "mid";
            break;

          case "analyticsVisitorID":
            d = "aid";
            break;

          case "audienceManagerLocationHint":
            d = "aamlh";
            break;

          case "audienceManagerBlob":
            d = "aamb";
            break;

          case "authState":
            d = "as";
            break;

          case "pageURL":
            d = "g";
            if (f.length > 255) s.pageURLRest = f.substring(255), f = f.substring(0, 255);
            break;

          case "pageURLRest":
            d = "-g";
            break;

          case "referrer":
            d = "r";
            break;

          case "vmk":
          case "visitorMigrationKey":
            d = "vmt";
            break;

          case "visitorMigrationServer":
            d = "vmf";
            s.ssl && s.visitorMigrationServerSecure && (f = "");
            break;

          case "visitorMigrationServerSecure":
            d = "vmf";
            !s.ssl && s.visitorMigrationServer && (f = "");
            break;

          case "charSet":
            d = "ce";
            break;

          case "visitorNamespace":
            d = "ns";
            break;

          case "cookieDomainPeriods":
            d = "cdp";
            break;

          case "cookieLifetime":
            d = "cl";
            break;

          case "variableProvider":
            d = "vvp";
            break;

          case "currencyCode":
            d = "cc";
            break;

          case "channel":
            d = "ch";
            break;

          case "transactionID":
            d = "xact";
            break;

          case "campaign":
            d = "v0";
            break;

          case "latitude":
            d = "lat";
            break;

          case "longitude":
            d = "lon";
            break;

          case "resolution":
            d = "s";
            break;

          case "colorDepth":
            d = "c";
            break;

          case "javascriptVersion":
            d = "j";
            break;

          case "javaEnabled":
            d = "v";
            break;

          case "cookiesEnabled":
            d = "k";
            break;

          case "browserWidth":
            d = "bw";
            break;

          case "browserHeight":
            d = "bh";
            break;

          case "connectionType":
            d = "ct";
            break;

          case "homepage":
            d = "hp";
            break;

          case "events":
            m && (f += (f != "" ? "," : "") + m);

            if (k) {
              g = f.split(",");
              f = "";

              for (e = 0; e < g.length; e++) {
                j = g[e], w = j.indexOf("="), w >= 0 && (j = j.substring(0, w)), w = j.indexOf(":"), w >= 0 && (j = j.substring(0, w)), k.indexOf("," + j + ",") >= 0 && (f += (f ? "," : "") + g[e]);
              }
            }

            break;

          case "events2":
            f = "";
            break;

          case "contextData":
            b += s.J("c", s[d], i, d);
            f = "";
            break;

          case "lightProfileID":
            d = "mtp";
            break;

          case "lightStoreForSeconds":
            d = "mtss";
            s.lightProfileID || (f = "");
            break;

          case "lightIncrementBy":
            d = "mti";
            s.lightProfileID || (f = "");
            break;

          case "retrieveLightProfiles":
            d = "mtsr";
            break;

          case "deleteLightProfiles":
            d = "mtsd";
            break;

          case "retrieveLightData":
            s.retrieveLightProfiles && (b += s.J("mts", s[d], i, d));
            f = "";
            break;

          default:
            s.ta(g) && (e == "prop" ? d = "c" + g : e == "eVar" ? d = "v" + g : e == "list" ? d = "l" + g : e == "hier" && (d = "h" + g, f = f.substring(0, 255)));
        }

        f && (b += "&" + d + "=" + (d.substring(0, 3) != "pev" ? s.escape(f) : f));
      }

      d == "pev3" && s.g && (b += s.g);
    }

    return b;
  };

  s.u = function (s) {
    var a = s.tagName;
    if ("" + s.wb != "undefined" || "" + s.ib != "undefined" && ("" + s.ib).toUpperCase() != "HTML") return "";
    a = a && a.toUpperCase ? a.toUpperCase() : "";
    a == "SHAPE" && (a = "");
    a && ((a == "INPUT" || a == "BUTTON") && s.type && s.type.toUpperCase ? a = s.type.toUpperCase() : !a && s.href && (a = "A"));
    return a;
  };

  s.oa = function (s) {
    var a = s.href ? s.href : "",
        c,
        e,
        d;
    c = a.indexOf(":");
    e = a.indexOf("?");
    d = a.indexOf("/");
    if (a && (c < 0 || e >= 0 && c > e || d >= 0 && c > d)) e = s.protocol && s.protocol.length > 1 ? s.protocol : l.protocol ? l.protocol : "", c = l.pathname.lastIndexOf("/"), a = (e ? e + "//" : "") + (s.host ? s.host : l.host ? l.host : "") + (h.substring(0, 1) != "/" ? l.pathname.substring(0, c < 0 ? 0 : c) + "/" : "") + a;
    return a;
  };

  s.D = function (b) {
    var a = s.u(b),
        c,
        e,
        d = "",
        f = 0;

    if (a) {
      c = b.protocol;
      e = b.onclick;
      if (b.href && (a == "A" || a == "AREA") && (!e || !c || c.toLowerCase().indexOf("javascript") < 0)) d = s.oa(b);else if (e) d = s.replace(s.replace(s.replace(s.replace("" + e, "\r", ""), "\n", ""), "\t", ""), " ", ""), f = 2;else if (a == "INPUT" || a == "SUBMIT") {
        if (b.value) d = b.value;else if (b.innerText) d = b.innerText;else if (b.textContent) d = b.textContent;
        f = 3;
      } else if (b.src && a == "IMAGE") d = b.src;
      if (d) return {
        id: d.substring(0, 100),
        type: f
      };
    }

    return 0;
  };

  s.tb = function (b) {
    for (var a = s.u(b), c = s.D(b); b && !c && a != "BODY";) {
      if (b = b.parentElement ? b.parentElement : b.parentNode) a = s.u(b), c = s.D(b);
    }

    if (!c || a == "BODY") b = 0;
    if (b && (a = b.onclick ? "" + b.onclick : "", a.indexOf(".tl(") >= 0 || a.indexOf(".trackLink(") >= 0)) b = 0;
    return b;
  };

  s.hb = function () {
    var b,
        a,
        c = s.linkObject,
        e = s.linkType,
        d = s.linkURL,
        f,
        g;
    s.ca = 1;
    if (!c) s.ca = 0, c = s.clickObject;

    if (c) {
      b = s.u(c);

      for (a = s.D(c); c && !a && b != "BODY";) {
        if (c = c.parentElement ? c.parentElement : c.parentNode) b = s.u(c), a = s.D(c);
      }

      if (!a || b == "BODY") c = 0;

      if (c) {
        var j = c.onclick ? "" + c.onclick : "";
        if (j.indexOf(".tl(") >= 0 || j.indexOf(".trackLink(") >= 0) c = 0;
      }
    } else s.ca = 1;

    !d && c && (d = s.oa(c));
    d && !s.linkLeaveQueryString && (f = d.indexOf("?"), f >= 0 && (d = d.substring(0, f)));

    if (!e && d) {
      var i = 0,
          k = 0,
          m;

      if (s.trackDownloadLinks && s.linkDownloadFileTypes) {
        j = d.toLowerCase();
        f = j.indexOf("?");
        g = j.indexOf("#");
        f >= 0 ? g >= 0 && g < f && (f = g) : f = g;
        f >= 0 && (j = j.substring(0, f));
        f = s.linkDownloadFileTypes.toLowerCase().split(",");

        for (g = 0; g < f.length; g++) {
          (m = f[g]) && j.substring(j.length - (m.length + 1)) == "." + m && (e = "d");
        }
      }

      if (s.trackExternalLinks && !e && (j = d.toLowerCase(), s.ra(j))) {
        if (!s.linkInternalFilters) s.linkInternalFilters = w.location.hostname;
        f = 0;
        s.linkExternalFilters ? (f = s.linkExternalFilters.toLowerCase().split(","), i = 1) : s.linkInternalFilters && (f = s.linkInternalFilters.toLowerCase().split(","));

        if (f) {
          for (g = 0; g < f.length; g++) {
            m = f[g], j.indexOf(m) >= 0 && (k = 1);
          }

          k ? i && (e = "e") : i || (e = "e");
        }
      }
    }

    s.linkObject = c;
    s.linkURL = d;
    s.linkType = e;
    if (s.trackClickMap || s.trackInlineStats) if (s.g = "", c) {
      e = s.pageName;
      d = 1;
      c = c.sourceIndex;
      if (!e) e = s.pageURL, d = 0;
      if (w.s_objectID) a.id = w.s_objectID, c = a.type = 1;
      if (e && a && a.id && b) s.g = "&pid=" + s.escape(e.substring(0, 255)) + (d ? "&pidt=" + d : "") + "&oid=" + s.escape(a.id.substring(0, 100)) + (a.type ? "&oidt=" + a.type : "") + "&ot=" + b + (c ? "&oi=" + c : "");
    }
  };

  s.Ya = function () {
    var b = s.ca,
        a = s.linkType,
        c = s.linkURL,
        e = s.linkName;
    if (a && (c || e)) a = a.toLowerCase(), a != "d" && a != "e" && (a = "o"), s.pe = "lnk_" + a, s.pev1 = c ? s.escape(c) : "", s.pev2 = e ? s.escape(e) : "", b = 1;
    s.abort && (b = 0);

    if (s.trackClickMap || s.trackInlineStats) {
      a = {};
      c = 0;
      var d = s.cookieRead("s_sq"),
          f = d ? d.split("&") : 0,
          g,
          j,
          w;
      d = 0;
      if (f) for (g = 0; g < f.length; g++) {
        j = f[g].split("="), e = s.unescape(j[0]).split(","), j = s.unescape(j[1]), a[j] = e;
      }
      e = s.account.split(",");

      if (b || s.g) {
        b && !s.g && (d = 1);

        for (j in a) {
          if (!Object.prototype[j]) for (g = 0; g < e.length; g++) {
            d && (w = a[j].join(","), w == s.account && (s.g += (j.charAt(0) != "&" ? "&" : "") + j, a[j] = [], c = 1));

            for (f = 0; f < a[j].length; f++) {
              w = a[j][f], w == e[g] && (d && (s.g += "&u=" + s.escape(w) + (j.charAt(0) != "&" ? "&" : "") + j + "&u=0"), a[j].splice(f, 1), c = 1);
            }
          }
        }

        b || (c = 1);

        if (c) {
          d = "";
          g = 2;
          !b && s.g && (d = s.escape(e.join(",")) + "=" + s.escape(s.g), g = 1);

          for (j in a) {
            !Object.prototype[j] && g > 0 && a[j].length > 0 && (d += (d ? "&" : "") + s.escape(a[j].join(",")) + "=" + s.escape(j), g--);
          }

          s.cookieWrite("s_sq", d);
        }
      }
    }

    return b;
  };

  s.Za = function () {
    if (!s.nb) {
      var b = new Date(),
          a = m.location,
          c,
          e,
          d = e = c = "",
          f = "",
          g = "",
          w = "1.2",
          i = s.cookieWrite("s_cc", "true", 0) ? "Y" : "N",
          k = "",
          n = "";

      if (b.setUTCDate && (w = "1.3", (0) .toPrecision && (w = "1.5", b = [], b.forEach))) {
        w = "1.6";
        e = 0;
        c = {};

        try {
          e = new Iterator(c), e.next && (w = "1.7", b.reduce && (w = "1.8", w.trim && (w = "1.8.1", Date.parse && (w = "1.8.2", Object.create && (w = "1.8.5")))));
        } catch (o) {}
      }

      c = screen.width + "x" + screen.height;
      d = navigator.javaEnabled() ? "Y" : "N";
      e = screen.pixelDepth ? screen.pixelDepth : screen.colorDepth;
      f = s.w.innerWidth ? s.w.innerWidth : s.d.documentElement.offsetWidth;
      g = s.w.innerHeight ? s.w.innerHeight : s.d.documentElement.offsetHeight;

      try {
        s.b.addBehavior("#default#homePage"), k = s.b.ub(a) ? "Y" : "N";
      } catch (p) {}

      try {
        s.b.addBehavior("#default#clientCaps"), n = s.b.connectionType;
      } catch (r) {}

      s.resolution = c;
      s.colorDepth = e;
      s.javascriptVersion = w;
      s.javaEnabled = d;
      s.cookiesEnabled = i;
      s.browserWidth = f;
      s.browserHeight = g;
      s.connectionType = n;
      s.homepage = k;
      s.nb = 1;
    }
  };

  s.I = {};

  s.loadModule = function (b, a) {
    var c = s.I[b];

    if (!c) {
      c = w["AppMeasurement_Module_" + b] ? new w["AppMeasurement_Module_" + b](s) : {};
      s.I[b] = s[b] = c;

      c.Fa = function () {
        return c.Ja;
      };

      c.Ka = function (a) {
        if (c.Ja = a) s[b + "_onLoad"] = a, s.B(b + "_onLoad", [s, c], 1) || a(s, c);
      };

      try {
        Object.defineProperty ? Object.defineProperty(c, "onLoad", {
          get: c.Fa,
          set: c.Ka
        }) : c._olc = 1;
      } catch (e) {
        c._olc = 1;
      }
    }

    a && (s[b + "_onLoad"] = a, s.B(b + "_onLoad", [s, c], 1) || a(s, c));
  };

  s.q = function (b) {
    var a, c;

    for (a in s.I) {
      if (!Object.prototype[a] && (c = s.I[a])) {
        if (c._olc && c.onLoad) c._olc = 0, c.onLoad(s, c);
        if (c[b] && c[b]()) return 1;
      }
    }

    return 0;
  };

  s.bb = function () {
    var b = Math.floor(Math.random() * 1E13),
        a = s.visitorSampling,
        c = s.visitorSamplingGroup;
    c = "s_vsn_" + (s.visitorNamespace ? s.visitorNamespace : s.account) + (c ? "_" + c : "");
    var e = s.cookieRead(c);

    if (a) {
      e && (e = parseInt(e));

      if (!e) {
        if (!s.cookieWrite(c, b)) return 0;
        e = b;
      }

      if (e % 1E4 > v) return 0;
    }

    return 1;
  };

  s.K = function (b, a) {
    var c, e, d, f, g, w;

    for (c = 0; c < 2; c++) {
      e = c > 0 ? s.ia : s.c;

      for (d = 0; d < e.length; d++) {
        if (f = e[d], (g = b[f]) || b["!" + f]) {
          if (!a && (f == "contextData" || f == "retrieveLightData") && s[f]) for (w in s[f]) {
            g[w] || (g[w] = s[f][w]);
          }
          s[f] = g;
        }
      }
    }
  };

  s.Aa = function (b, a) {
    var c, e, d, f;

    for (c = 0; c < 2; c++) {
      e = c > 0 ? s.ia : s.c;

      for (d = 0; d < e.length; d++) {
        f = e[d], b[f] = s[f], !a && !b[f] && (b["!" + f] = 1);
      }
    }
  };

  s.Ua = function (s) {
    var a,
        c,
        e,
        d,
        f,
        g = 0,
        w,
        i = "",
        k = "";

    if (s && s.length > 255 && (a = "" + s, c = a.indexOf("?"), c > 0 && (w = a.substring(c + 1), a = a.substring(0, c), d = a.toLowerCase(), e = 0, d.substring(0, 7) == "http://" ? e += 7 : d.substring(0, 8) == "https://" && (e += 8), c = d.indexOf("/", e), c > 0 && (d = d.substring(e, c), f = a.substring(c), a = a.substring(0, c), d.indexOf("google") >= 0 ? g = ",q,ie,start,search_key,word,kw,cd," : d.indexOf("yahoo.co") >= 0 && (g = ",p,ei,"), g && w)))) {
      if ((s = w.split("&")) && s.length > 1) {
        for (e = 0; e < s.length; e++) {
          d = s[e], c = d.indexOf("="), c > 0 && g.indexOf("," + d.substring(0, c) + ",") >= 0 ? i += (i ? "&" : "") + d : k += (k ? "&" : "") + d;
        }

        i && k ? w = i + "&" + k : k = "";
      }

      c = 253 - (w.length - k.length) - a.length;
      s = a + (c > 0 ? f.substring(0, c) : "") + "?" + w;
    }

    return s;
  };

  s.U = !1;
  s.O = !1;

  s.Ia = function (b) {
    s.marketingCloudVisitorID = b;
    s.O = !0;
    s.k();
  };

  s.R = !1;
  s.L = !1;

  s.Ca = function (b) {
    s.analyticsVisitorID = b;
    s.L = !0;
    s.k();
  };

  s.T = !1;
  s.N = !1;

  s.Ea = function (b) {
    s.audienceManagerLocationHint = b;
    s.N = !0;
    s.k();
  };

  s.S = !1;
  s.M = !1;

  s.Da = function (b) {
    s.audienceManagerBlob = b;
    s.M = !0;
    s.k();
  };

  s.isReadyToTrack = function () {
    var b = !0,
        a = s.visitor;

    if (a && a.isAllowed()) {
      if (!s.U && !s.marketingCloudVisitorID && a.getMarketingCloudVisitorID && (s.U = !0, s.marketingCloudVisitorID = a.getMarketingCloudVisitorID([s, s.Ia]), s.marketingCloudVisitorID)) s.O = !0;
      if (!s.R && !s.analyticsVisitorID && a.getAnalyticsVisitorID && (s.R = !0, s.analyticsVisitorID = a.getAnalyticsVisitorID([s, s.Ca]), s.analyticsVisitorID)) s.L = !0;
      if (!s.T && !s.audienceManagerLocationHint && a.getAudienceManagerLocationHint && (s.T = !0, s.audienceManagerLocationHint = a.getAudienceManagerLocationHint([s, s.Ea]), s.audienceManagerLocationHint)) s.N = !0;
      if (!s.S && !s.audienceManagerBlob && a.getAudienceManagerBlob && (s.S = !0, s.audienceManagerBlob = a.getAudienceManagerBlob([s, s.Da]), s.audienceManagerBlob)) s.M = !0;
      if (s.U && !s.O && !s.marketingCloudVisitorID || s.R && !s.L && !s.analyticsVisitorID || s.T && !s.N && !s.audienceManagerLocationHint || s.S && !s.M && !s.audienceManagerBlob) b = !1;
    }

    return b;
  };

  s.j = k;
  s.l = 0;

  s.callbackWhenReadyToTrack = function (b, a, c) {
    var e;
    e = {};
    e.Oa = b;
    e.Na = a;
    e.La = c;
    if (s.j == k) s.j = [];
    s.j.push(e);
    if (s.l == 0) s.l = setInterval(s.k, 100);
  };

  s.k = function () {
    var b;

    if (s.isReadyToTrack()) {
      if (s.l) clearInterval(s.l), s.l = 0;
      if (s.j != k) for (; s.j.length > 0;) {
        b = s.j.shift(), b.Na.apply(b.Oa, b.La);
      }
    }
  };

  s.Ga = function (b) {
    var a,
        c,
        e = k,
        d = k;

    if (!s.isReadyToTrack()) {
      a = [];
      if (b != k) for (c in (e = {}, b)) {
        e[c] = b[c];
      }
      d = {};
      s.Aa(d, !0);
      a.push(e);
      a.push(d);
      s.callbackWhenReadyToTrack(s, s.track, a);
      return !0;
    }

    return !1;
  };

  s.Wa = function () {
    var b = s.cookieRead("s_fid"),
        a = "",
        c = "",
        e;
    e = 8;
    var d = 4;

    if (!b || b.indexOf("-") < 0) {
      for (b = 0; b < 16; b++) {
        e = Math.floor(Math.random() * e), a += "0123456789ABCDEF".substring(e, e + 1), e = Math.floor(Math.random() * d), c += "0123456789ABCDEF".substring(e, e + 1), e = d = 16;
      }

      b = a + "-" + c;
    }

    s.cookieWrite("s_fid", b, 1) || (b = 0);
    return b;
  };

  s.t = s.track = function (b, a) {
    var c,
        e = new Date(),
        d = "s" + Math.floor(e.getTime() / 108E5) % 10 + Math.floor(Math.random() * 1E13),
        f = e.getYear();
    f = "t=" + s.escape(e.getDate() + "/" + e.getMonth() + "/" + (f < 1900 ? f + 1900 : f) + " " + e.getHours() + ":" + e.getMinutes() + ":" + e.getSeconds() + " " + e.getDay() + " " + e.getTimezoneOffset());

    if (s.visitor) {
      if (s.visitor.getAuthState) s.authState = s.visitor.getAuthState();
      if (!s.supplementalDataID && s.visitor.getSupplementalDataID) s.supplementalDataID = s.visitor.getSupplementalDataID("AppMeasurement:" + s._in, s.expectSupplementalData ? !1 : !0);
    }

    s.q("_s");

    if (!s.B("track", arguments)) {
      if (!s.Ga(b)) {
        a && s.K(a);
        b && (c = {}, s.Aa(c, 0), s.K(b));

        if (s.bb()) {
          if (!s.analyticsVisitorID && !s.marketingCloudVisitorID) s.fid = s.Wa();
          s.hb();
          s.usePlugins && s.doPlugins && s.doPlugins(s);

          if (s.account) {
            if (!s.abort) {
              if (s.trackOffline && !s.timestamp) s.timestamp = Math.floor(e.getTime() / 1E3);
              e = w.location;
              if (!s.pageURL) s.pageURL = e.href ? e.href : e;
              if (!s.referrer && !s.Ba) s.referrer = m.document.referrer, s.Ba = 1;
              s.referrer = s.Ua(s.referrer);
              s.q("_g");
            }

            if (s.Ya() && !s.abort) s.Za(), f += s.Xa(), s.gb(d, f), s.q("_t"), s.referrer = "";
          }
        }

        b && s.K(c, 1);
      }

      s.abort = s.supplementalDataID = s.timestamp = s.pageURLRest = s.linkObject = s.clickObject = s.linkURL = s.linkName = s.linkType = w.vb = s.pe = s.pev1 = s.pev2 = s.pev3 = s.g = 0;
    }
  };

  s.tl = s.trackLink = function (b, a, c, e, d) {
    s.linkObject = b;
    s.linkType = a;
    s.linkName = c;
    if (d) s.i = b, s.p = d;
    return s.track(e);
  };

  s.trackLight = function (b, a, c, e) {
    s.lightProfileID = b;
    s.lightStoreForSeconds = a;
    s.lightIncrementBy = c;
    return s.track(e);
  };

  s.clearVars = function () {
    var b, a;

    for (b = 0; b < s.c.length; b++) {
      if (a = s.c[b], a.substring(0, 4) == "prop" || a.substring(0, 4) == "eVar" || a.substring(0, 4) == "hier" || a.substring(0, 4) == "list" || a == "channel" || a == "events" || a == "eventList" || a == "products" || a == "productList" || a == "purchaseID" || a == "transactionID" || a == "state" || a == "zip" || a == "campaign") s[a] = void 0;
    }
  };

  s.tagContainerMarker = "";

  s.gb = function (b, a) {
    var c,
        e = s.trackingServer;
    c = "";
    var d = s.dc,
        f = "sc.",
        w = s.visitorNamespace;

    if (e) {
      if (s.trackingServerSecure && s.ssl) e = s.trackingServerSecure;
    } else {
      if (!w) w = s.account, e = w.indexOf(","), e >= 0 && (w = w.substring(0, e)), w = w.replace(/[^A-Za-z0-9]/g, "");
      c || (c = "2o7.net");
      d = d ? ("" + d).toLowerCase() : "d1";
      c == "2o7.net" && (d == "d1" ? d = "112" : d == "d2" && (d = "122"), f = "");
      e = w + "." + d + "." + f + c;
    }

    c = s.ssl ? "https://" : "http://";
    d = s.AudienceManagement && s.AudienceManagement.isReady();
    c += e + "/b/ss/" + s.account + "/" + (s.mobile ? "5." : "") + (d ? "10" : "1") + "/JS-" + s.version + (s.mb ? "T" : "") + (s.tagContainerMarker ? "-" + s.tagContainerMarker : "") + "/" + b + "?AQB=1&ndh=1&pf=1&" + (d ? "callback=s_c_il[" + s._in + "].AudienceManagement.passData&" : "") + a + "&AQE=1";
    s.Sa(c);
    s.Y();
  };

  s.Sa = function (b) {
    s.e || s.$a();
    s.e.push(b);
    s.aa = s.r();
    s.za();
  };

  s.$a = function () {
    s.e = s.cb();
    if (!s.e) s.e = [];
  };

  s.cb = function () {
    var b, a;

    if (s.fa()) {
      try {
        (a = w.localStorage.getItem(s.da())) && (b = w.JSON.parse(a));
      } catch (c) {}

      return b;
    }
  };

  s.fa = function () {
    var b = !0;
    if (!s.trackOffline || !s.offlineFilename || !w.localStorage || !w.JSON) b = !1;
    return b;
  };

  s.pa = function () {
    var b = 0;
    if (s.e) b = s.e.length;
    s.v && b++;
    return b;
  };

  s.Y = function () {
    if (!s.v) if (s.qa = k, s.ea) s.aa > s.G && s.xa(s.e), s.ha(500);else {
      var b = s.Ma();
      if (b > 0) s.ha(b);else if (b = s.na()) s.v = 1, s.fb(b), s.jb(b);
    }
  };

  s.ha = function (b) {
    if (!s.qa) b || (b = 0), s.qa = setTimeout(s.Y, b);
  };

  s.Ma = function () {
    var b;
    if (!s.trackOffline || s.offlineThrottleDelay <= 0) return 0;
    b = s.r() - s.wa;
    if (s.offlineThrottleDelay < b) return 0;
    return s.offlineThrottleDelay - b;
  };

  s.na = function () {
    if (s.e.length > 0) return s.e.shift();
  };

  s.fb = function (b) {
    if (s.debugTracking) {
      var a = "AppMeasurement Debug: " + b;
      b = b.split("&");
      var c;

      for (c = 0; c < b.length; c++) {
        a += "\n\t" + s.unescape(b[c]);
      }

      s.eb(a);
    }
  };

  s.Ha = function () {
    return s.marketingCloudVisitorID || s.analyticsVisitorID;
  };

  s.Q = !1;
  var n;

  try {
    n = JSON.parse('{"x":"y"}');
  } catch (r) {
    n = null;
  }

  n && n.x == "y" ? (s.Q = !0, s.P = function (s) {
    return JSON.parse(s);
  }) : w.$ && w.$.parseJSON ? (s.P = function (s) {
    return w.$.parseJSON(s);
  }, s.Q = !0) : s.P = function () {
    return null;
  };

  s.jb = function (b) {
    var a, c, e;
    if (s.Ha() && b.length > 2047 && (typeof XMLHttpRequest != "undefined" && (a = new XMLHttpRequest(), "withCredentials" in a ? c = 1 : a = 0), !a && typeof XDomainRequest != "undefined" && (a = new XDomainRequest(), c = 2), a && s.AudienceManagement && s.AudienceManagement.isReady())) s.Q ? a.ja = !0 : a = 0;
    !a && s.ab && (b = b.substring(0, 2047));
    if (!a && s.d.createElement && s.AudienceManagement && s.AudienceManagement.isReady() && (a = s.d.createElement("SCRIPT")) && "async" in a) (e = (e = s.d.getElementsByTagName("HEAD")) && e[0] ? e[0] : s.d.body) ? (a.type = "text/javascript", a.setAttribute("async", "async"), c = 3) : a = 0;
    if (!a) a = new Image(), a.alt = "";

    a.la = function () {
      try {
        if (s.ga) clearTimeout(s.ga), s.ga = 0;
        if (a.timeout) clearTimeout(a.timeout), a.timeout = 0;
      } catch (b) {}
    };

    a.onload = a.lb = function () {
      a.la();
      s.Ra();
      s.V();
      s.v = 0;
      s.Y();

      if (a.ja) {
        a.ja = !1;

        try {
          var b = s.P(a.responseText);
          AudienceManagement.passData(b);
        } catch (c) {}
      }
    };

    a.onabort = a.onerror = a.Ta = function () {
      a.la();
      (s.trackOffline || s.ea) && s.v && s.e.unshift(s.Qa);
      s.v = 0;
      s.aa > s.G && s.xa(s.e);
      s.V();
      s.ha(500);
    };

    a.onreadystatechange = function () {
      a.readyState == 4 && (a.status == 200 ? a.lb() : a.Ta());
    };

    s.wa = s.r();

    if (c == 1 || c == 2) {
      var d = b.indexOf("?");
      e = b.substring(0, d);
      d = b.substring(d + 1);
      d = d.replace(/&callback=[a-zA-Z0-9_.\[\]]+/, "");
      c == 1 ? (a.open("POST", e, !0), a.send(d)) : c == 2 && (a.open("POST", e), a.send(d));
    } else if (a.src = b, c == 3) {
      if (s.ua) try {
        e.removeChild(s.ua);
      } catch (f) {}
      e.firstChild ? e.insertBefore(a, e.firstChild) : e.appendChild(a);
      s.ua = s.Pa;
    }

    if (a.abort) s.ga = setTimeout(a.abort, 5E3);
    s.Qa = b;
    s.Pa = w["s_i_" + s.replace(s.account, ",", "_")] = a;

    if (s.useForcedLinkTracking && s.A || s.p) {
      if (!s.forcedLinkTrackingTimeout) s.forcedLinkTrackingTimeout = 250;
      s.W = setTimeout(s.V, s.forcedLinkTrackingTimeout);
    }
  };

  s.Ra = function () {
    if (s.fa() && !(s.va > s.G)) try {
      w.localStorage.removeItem(s.da()), s.va = s.r();
    } catch (b) {}
  };

  s.xa = function (b) {
    if (s.fa()) {
      s.za();

      try {
        w.localStorage.setItem(s.da(), w.JSON.stringify(b)), s.G = s.r();
      } catch (a) {}
    }
  };

  s.za = function () {
    if (s.trackOffline) {
      if (!s.offlineLimit || s.offlineLimit <= 0) s.offlineLimit = 10;

      for (; s.e.length > s.offlineLimit;) {
        s.na();
      }
    }
  };

  s.forceOffline = function () {
    s.ea = !0;
  };

  s.forceOnline = function () {
    s.ea = !1;
  };

  s.da = function () {
    return s.offlineFilename + "-" + s.visitorNamespace + s.account;
  };

  s.r = function () {
    return new Date().getTime();
  };

  s.ra = function (s) {
    s = s.toLowerCase();
    if (s.indexOf("#") != 0 && s.indexOf("about:") != 0 && s.indexOf("opera:") != 0 && s.indexOf("javascript:") != 0) return !0;
    return !1;
  };

  s.setTagContainer = function (b) {
    var a, c, e;
    s.mb = b;

    for (a = 0; a < s._il.length; a++) {
      if ((c = s._il[a]) && c._c == "s_l" && c.tagContainerName == b) {
        s.K(c);
        if (c.lmq) for (a = 0; a < c.lmq.length; a++) {
          e = c.lmq[a], s.loadModule(e.n);
        }
        if (c.ml) for (e in c.ml) {
          if (s[e]) for (a in (b = s[e], e = c.ml[e], e)) {
            if (!Object.prototype[a] && (typeof e[a] != "function" || ("" + e[a]).indexOf("s_c_il") < 0)) b[a] = e[a];
          }
        }
        if (c.mmq) for (a = 0; a < c.mmq.length; a++) {
          e = c.mmq[a], s[e.m] && (b = s[e.m], b[e.f] && typeof b[e.f] == "function" && (e.a ? b[e.f].apply(b, e.a) : b[e.f].apply(b)));
        }
        if (c.tq) for (a = 0; a < c.tq.length; a++) {
          s.track(c.tq[a]);
        }
        c.s = s;
        break;
      }
    }
  };

  s.Util = {
    urlEncode: s.escape,
    urlDecode: s.unescape,
    cookieRead: s.cookieRead,
    cookieWrite: s.cookieWrite,
    getQueryParam: function getQueryParam(b, a, c) {
      var e;
      a || (a = s.pageURL ? s.pageURL : w.location);
      c || (c = "&");
      if (b && a && (a = "" + a, e = a.indexOf("?"), e >= 0 && (a = c + a.substring(e + 1) + c, e = a.indexOf(c + b + "="), e >= 0 && (a = a.substring(e + c.length + b.length + 1), e = a.indexOf(c), e >= 0 && (a = a.substring(0, e)), a.length > 0)))) return s.unescape(a);
      return "";
    }
  };
  s.z = ["supplementalDataID", "timestamp", "dynamicVariablePrefix", "visitorID", "marketingCloudVisitorID", "analyticsVisitorID", "audienceManagerLocationHint", "authState", "fid", "vmk", "visitorMigrationKey", "visitorMigrationServer", "visitorMigrationServerSecure", "charSet", "visitorNamespace", "cookieDomainPeriods", "fpCookieDomainPeriods", "cookieLifetime", "pageName", "pageURL", "referrer", "contextData", "currencyCode", "lightProfileID", "lightStoreForSeconds", "lightIncrementBy", "retrieveLightProfiles", "deleteLightProfiles", "retrieveLightData", "pe", "pev1", "pev2", "pev3", "pageURLRest"];
  s.c = s.z.concat(["purchaseID", "variableProvider", "channel", "server", "pageType", "transactionID", "campaign", "state", "zip", "events", "events2", "products", "audienceManagerBlob", "tnt"]);
  s.ba = ["timestamp", "charSet", "visitorNamespace", "cookieDomainPeriods", "cookieLifetime", "contextData", "lightProfileID", "lightStoreForSeconds", "lightIncrementBy"];
  s.H = s.ba.slice(0);
  s.ia = ["account", "allAccounts", "debugTracking", "visitor", "trackOffline", "offlineLimit", "offlineThrottleDelay", "offlineFilename", "usePlugins", "doPlugins", "configURL", "visitorSampling", "visitorSamplingGroup", "linkObject", "clickObject", "linkURL", "linkName", "linkType", "trackDownloadLinks", "trackExternalLinks", "trackClickMap", "trackInlineStats", "linkLeaveQueryString", "linkTrackVars", "linkTrackEvents", "linkDownloadFileTypes", "linkExternalFilters", "linkInternalFilters", "useForcedLinkTracking", "forcedLinkTrackingTimeout", "trackingServer", "trackingServerSecure", "ssl", "abort", "mobile", "dc", "lightTrackVars", "maxDelay", "expectSupplementalData", "AudienceManagement"];

  for (i = 0; i <= 250; i++) {
    i < 76 && (s.c.push("prop" + i), s.H.push("prop" + i)), s.c.push("eVar" + i), s.H.push("eVar" + i), i < 6 && s.c.push("hier" + i), i < 4 && s.c.push("list" + i);
  }

  i = ["latitude", "longitude", "resolution", "colorDepth", "javascriptVersion", "javaEnabled", "cookiesEnabled", "browserWidth", "browserHeight", "connectionType", "homepage"];
  s.c = s.c.concat(i);
  s.z = s.z.concat(i);
  s.ssl = w.location.protocol.toLowerCase().indexOf("https") >= 0;
  s.charSet = "UTF-8";
  s.contextData = {};
  s.offlineThrottleDelay = 0;
  s.offlineFilename = "AppMeasurement.offline";
  s.wa = 0;
  s.aa = 0;
  s.G = 0;
  s.va = 0;
  s.linkDownloadFileTypes = "exe,zip,wav,mp3,mov,mpg,avi,wmv,pdf,doc,docx,xls,xlsx,ppt,pptx";
  s.w = w;
  s.d = w.document;

  try {
    s.ab = navigator.appName == "Microsoft Internet Explorer";
  } catch (t) {}

  s.V = function () {
    if (s.W) w.clearTimeout(s.W), s.W = k;
    s.i && s.A && s.i.dispatchEvent(s.A);
    if (s.p) if (typeof s.p == "function") s.p();else if (s.i && s.i.href) s.d.location = s.i.href;
    s.i = s.A = s.p = 0;
  };

  s.ya = function () {
    s.b = s.d.body;
    if (s.b) {
      if (s.o = function (b) {
        var a, c, e, d, f;

        if (!(s.d && s.d.getElementById("cppXYctnr") || b && b["s_fe_" + s._in])) {
          if (s.ka) {
            if (s.useForcedLinkTracking) s.b.removeEventListener("click", s.o, !1);else {
              s.b.removeEventListener("click", s.o, !0);
              s.ka = s.useForcedLinkTracking = 0;
              return;
            }
          } else s.useForcedLinkTracking = 0;
          s.clickObject = b.srcElement ? b.srcElement : b.target;

          try {
            if (s.clickObject && (!s.F || s.F != s.clickObject) && (s.clickObject.tagName || s.clickObject.parentElement || s.clickObject.parentNode)) {
              var g = s.F = s.clickObject;
              if (s.Z) clearTimeout(s.Z), s.Z = 0;
              s.Z = setTimeout(function () {
                if (s.F == g) s.F = 0;
              }, 1E4);
              e = s.pa();
              s.track();

              if (e < s.pa() && s.useForcedLinkTracking && b.target) {
                for (d = b.target; d && d != s.b && d.tagName.toUpperCase() != "A" && d.tagName.toUpperCase() != "AREA";) {
                  d = d.parentNode;
                }

                if (d && (f = d.href, s.ra(f) || (f = 0), c = d.target, b.target.dispatchEvent && f && (!c || c == "_self" || c == "_top" || c == "_parent" || w.name && c == w.name))) {
                  try {
                    a = s.d.createEvent("MouseEvents");
                  } catch (i) {
                    a = new w.MouseEvent();
                  }

                  if (a) {
                    try {
                      a.initMouseEvent("click", b.bubbles, b.cancelable, b.view, b.detail, b.screenX, b.screenY, b.clientX, b.clientY, b.ctrlKey, b.altKey, b.shiftKey, b.metaKey, b.button, b.relatedTarget);
                    } catch (k) {
                      a = 0;
                    }

                    if (a) a["s_fe_" + s._in] = a.s_fe = 1, b.stopPropagation(), b.kb && b.kb(), b.preventDefault(), s.i = b.target, s.A = a;
                  }
                }
              }
            } else s.clickObject = 0;
          } catch (m) {
            s.clickObject = 0;
          }
        }
      }, s.b && s.b.attachEvent) s.b.attachEvent("onclick", s.o);else {
        if (s.b && s.b.addEventListener) {
          if (navigator && (navigator.userAgent.indexOf("WebKit") >= 0 && s.d.createEvent || navigator.userAgent.indexOf("Firefox/2") >= 0 && w.MouseEvent)) s.ka = 1, s.useForcedLinkTracking = 1, s.b.addEventListener("click", s.o, !0);
          s.b.addEventListener("click", s.o, !1);
        }
      }
    } else setTimeout(s.ya, 30);
  };

  s.ya();
}

function s_gi(s) {
  var w,
      k = window.s_c_il,
      m,
      i,
      o = s.split(","),
      p,
      n,
      r = 0;
  if (k) for (m = 0; !r && m < k.length;) {
    w = k[m];
    if (w._c == "s_c" && (w.account || w.oun)) if (w.account && w.account == s) r = 1;else {
      i = w.account ? w.account : w.oun;
      i = w.allAccounts ? w.allAccounts : i.split(",");

      for (p = 0; p < o.length; p++) {
        for (n = 0; n < i.length; n++) {
          o[p] == i[n] && (r = 1);
        }
      }
    }
    m++;
  }
  r || (w = new AppMeasurement());
  w.setAccount ? w.setAccount(s) : w.sa && w.sa(s);
  return w;
}

AppMeasurement.getInstance = s_gi;
window.s_objectID || (window.s_objectID = 0);

function s_pgicq() {
  var s = window,
      w = s.s_giq,
      k,
      m,
      i;
  if (w) for (k = 0; k < w.length; k++) {
    m = w[k], i = s_gi(m.oun), i.setAccount(m.un), i.setTagContainer(m.tagContainerName);
  }
  s.s_giq = 0;
}

s_pgicq();
/* eslint-enable */
// some things need to be global

window.Visitor = Visitor;
window.AppMeasurement = AppMeasurement;
/**
 * function that runs before client.js, does preliminary stuff and creates a new AppMeasurement
 * @returns {object} s
 */

function pre() {
  // Global Config.
  var currentHost = window.location.hostname.split('.').slice(-2).join('.'),
      visitor = new Visitor('newyorkmagazine'),
      // same as s.visitorNamespace
  s = new AppMeasurement(),
      domain = window.location.hostname.toLowerCase(); // set visitor stuff

  visitor.trackingServer = 'stats.' + currentHost; // same as s.trackingServer

  visitor.trackingServerSecure = 'sstats.' + currentHost; // same as s.trackingServerSecure
  // set app measurement stuff

  s.visitorNamespace = 'newyorkmagazine';
  s.visitor = Visitor.getInstance('newyorkmagazine');
  s.trackingServer = 'stats.' + currentHost;
  s.trackingServerSecure = 'sstats.' + currentHost;
  s.trackDownloadLinks = true;
  s.trackInlineStats = true;
  s.linkDownloadFileTypes = 'exe,zip,wav,mp3,mov,mpg,avi,wmv,pdf,doc,docx,xls,xlsx,ppt,pptx';
  s.linkLeaveQueryString = false;
  s.currencyCode = 'USD';
  s.charSet = 'UTF-8';
  s.linkTrackVars = 'prop34,prop39,eVar1,eVar8,eVar12';
  s.linkTrackEvents = 'event20';
  s.events = 'event1'; // Set Internal links (Global among all properties).

  s.linkInternalFilters = 'localhost,nymag.com,nymetro.com,vulture.com,grubstreet.com,bedfordandbowery.com,thecut.com';
  s.linkInternalFilters += ',' + domain; // Login status.

  s.prop52 = 'Anonymous'; // track external links

  s.trackExternalLinks = false;
  return s;
}
/**
 * function that runs AFTER client.js and does more stuff based on the data
 * @param  {object} s an AppMeasurement
 * @returns {object} s FINAL FORM!!!
 */


function post(s) {
  var href = window.location.href; // Props from client-side js:
  // Hierarchy. Based on some legacy.

  s.hier1 = s.channel && s.channel.split(':').join(',');
  s.a1 = s.hier1 && s.hier1.split(','); // set eVars from props

  s.eVar19 = s.prop2;
  s.eVar3 = s.prop6;
  s.eVar29 = s.prop12;
  s.eVar2 = s.pageName;
  s.eVar17 = s.prop40; // set stuff from current location

  s.prop26 = href;
  s.eVar20 = href; // this is where omniture parses the prop6/hierarchy and splits them into separate props
  // note: do not set these props directly (in client.js)

  if (s.a1 && s.a1[0]) {
    s.eVar14 = s.a1[0];
    s.prop31 = s.a1[0];
  }

  if (s.a1 && s.a1[1]) {
    s.eVar15 = s.a1[1];
    s.prop32 = s.a1[1];
  }

  if (s.a1 && s.a1[2]) {
    s.eVar16 = s.a1[2];
    s.prop33 = s.a1[2];
  } // Previous page (for clicks).


  s.prop34 = href;
  s.eVar8 = s.prop34; // Request URL for current page.

  s.eVar20 = s.prop34; // AdBlock checking: 1 = noblock, 9 = ABP block (advertising.js method)
  // The number 9 is being used to jive with legacy adblock detect data/reports

  s.prop54 = 1;

  if (!window.ad_block_disabled) {
    s.prop54 = 9;
  } // Props from plugins.


  s.usePlugins = true;

  function s_doPlugins(s) {
    // Time of visit.
    s.currentYear = new Date().getYear() + 1900;
    s.prop7 = s.getTimeParting('d', '-5');
    s.prop8 = s.getTimeParting('h', '-5'); // Days since last visit. Might have problem with domain

    s.prop21 = s.getDaysSinceLastVisit('o_dslv');
    s.prop21 = s.getAndPersistValue(s.prop21, 'o_dslv', 0);
    s.eVar6 = s.prop21; // Search term.

    s.prop30 = s.getQueryValue('textquery'); // Message ID. Captured as a prop and evar. May be able to remove in the future.

    s.prop36 = s.getQueryValue('mid') || s.getQueryValue('email');
    s.eVar12 = s.prop36;
    s.eVar28 = s.getQueryValue('mid'); // Recipient ID.

    s.prop37 = s.getQueryValue('rid');
    s.eVar27 = s.prop37; // for UTM parameters

    s.campaign = s.campaign;
    s.eVar1 = s.campaign; // New vs Repeat.

    s.prop49 = s.getNewRepeat(365, 's_getNewRepeat');
    s.eVar26 = s.prop49; // Loyalty logic.

    s.prop47 = s.getVisitNum(30) >= 4 ? 'Loyal' : 'non loyal';
  }

  s.doPlugins = s_doPlugins;
  /* eslint-disable */
  // Plugins. Mostly cut-and-paste from omniture.
  // Documentation: http://microsite.omniture.com/t2/help/en_US/sc/implement/#Implementation_Plugins

  /*
   * Custom Plugin Replacement for getQueryParam 2.3:
   *  s.getQueryParam no longer works.
   *  s.getQueryValue takes a string and returns the query value from the URL.
   *  If the param is not in the url, then it returns "".
   */

  s.getQueryValue = function (a) {
    var b = {};

    for (var i = 0; i < a.length; ++i) {
      var p = a[i].split('=');
      if (p.length != 2) continue;
      b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, ' '));
    }

    return function (c) {
      return b.hasOwnProperty(c) ? b[c] : '';
    };
  }(window.location.search.substr(1).split('&'));
  /*
   * Plugin: getTimeParting 2.0 - Set timeparting values based on time zone
   */


  s.getTimeParting = new Function("t", "z", "" + "var s=this,cy;dc=new Date('1/1/2000');" + "if(dc.getDay()!=6||dc.getMonth()!=0){return'Data Not Available'}" + "else{;z=parseFloat(z);var dsts=new Date(s.dstStart);" + "var dste=new Date(s.dstEnd);fl=dste;cd=new Date();if(cd>dsts&&cd<fl)" + "{z=z+1}else{z=z};utc=cd.getTime()+(cd.getTimezoneOffset()*60000);" + "tz=new Date(utc + (3600000*z));thisy=tz.getFullYear();" + "var days=['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday'," + "'Saturday'];if(thisy!=s.currentYear){return'Data Not Available'}else{;" + "thish=tz.getHours();thismin=tz.getMinutes();thisd=tz.getDay();" + "var dow=days[thisd];var ap='AM';var dt='Weekday';var mint='00';" + "if(thismin>30){mint='30'}if(thish>=12){ap='PM';thish=thish-12};" + "if (thish==0){thish=12};if(thisd==6||thisd==0){dt='Weekend'};" + "var timestring=thish+':'+mint+ap;if(t=='h'){return timestring}" + "if(t=='d'){return dow};if(t=='w'){return dt}}};");
  /*
   * Plugin: getAndPersistValue 0.3 - get a value on every page
   */

  s.getAndPersistValue = new Function("v", "c", "e", "" + "var s=this,a=new Date;e=e?e:0;a.setTime(a.getTime()+e*86400000);if(" + "v)s.c_w(c,v,e?a:0);return s.c_r(c);");
  /*
   * Plugin: Days since last Visit 1.1 - capture time from last visit
   */

  s.getDaysSinceLastVisit = new Function("c", "" + "var s=this,e=new Date(),es=new Date(),cval,cval_s,cval_ss,ct=e.getT" + "ime(),day=24*60*60*1000,f1,f2,f3,f4,f5;e.setTime(ct+3*365*day);es.s" + "etTime(ct+30*60*1000);f0='Cookies Not Supported';f1='First Visit';f" + "2='More than 30 days';f3='More than 7 days';f4='Less than 7 days';f" + "5='Less than 1 day';cval=s.c_r(c);if(cval.length==0){s.c_w(c,ct,e);" + "s.c_w(c+'_s',f1,es);}else{var d=ct-cval;if(d>30*60*1000){if(d>30*da" + "y){s.c_w(c,ct,e);s.c_w(c+'_s',f2,es);}else if(d<30*day+1 && d>7*day" + "){s.c_w(c,ct,e);s.c_w(c+'_s',f3,es);}else if(d<7*day+1 && d>day){s." + "c_w(c,ct,e);s.c_w(c+'_s',f4,es);}else if(d<day+1){s.c_w(c,ct,e);s.c" + "_w(c+'_s',f5,es);}}else{s.c_w(c,ct,e);cval_ss=s.c_r(c+'_s');s.c_w(c" + "+'_s',cval_ss,es);}}cval_s=s.c_r(c+'_s');if(cval_s.length==0) retur" + "n f0;else if(cval_s!=f1&&cval_s!=f2&&cval_s!=f3&&cval_s!=f4&&cval_s" + "!=f5) return '';else return cval_s;");
  /*
   * Plugin: getNewRepeat 1.2 - Returns whether user is new or repeat
   */

  s.getNewRepeat = new Function("d", "cn", "" + "var s=this,e=new Date(),cval,sval,ct=e.getTime();d=d?d:30;cn=cn?cn:" + "'s_nr';e.setTime(ct+d*24*60*60*1000);cval=s.c_r(cn);if(cval.length=" + "=0){s.c_w(cn,ct+'-New',e);return'New';}sval=s.split(cval,'-');if(ct" + "-sval[0]<30*60*1000&&sval[1]=='New'){s.c_w(cn,ct+'-New',e);return'N" + "ew';}else{s.c_w(cn,ct+'-Repeat',e);return'Repeat';}");
  /*
   * Utility Function: split v1.5 (JS 1.0 compatible)
   */

  s.split = new Function("l", "d", "" + "var i,x=0,a=new Array;while(l){i=l.indexOf(d);i=i>-1?i:l.length;a[x" + "++]=l.substring(0,i);l=l.substring(i+d.length);}return a");
  /*
   * Plugin: Visit Number By Month 2.0 - Return the user visit number
   */

  s.getVisitNum = new Function("" + "var s=this,e=new Date(),cval,cvisit,ct=e.getTime(),c='s_vnum',c2='s" + "_invisit';e.setTime(ct+30*24*60*60*1000);cval=s.c_r(c);if(cval){var" + " i=cval.indexOf('&vn='),str=cval.substring(i+4,cval.length),k;}cvis" + "it=s.c_r(c2);if(cvisit){if(str){e.setTime(ct+30*60*1000);s.c_w(c2,'" + "true',e);return str;}else return 'unknown visit number';}else{if(st" + "r){str++;k=cval.substring(0,i);e.setTime(k);s.c_w(c,k+'&vn='+str,e)" + ";e.setTime(ct+30*60*1000);s.c_w(c2,'true',e);return str;}else{s.c_w" + "(c,ct+30*24*60*60*1000+'&vn=1',e);e.setTime(ct+30*60*1000);s.c_w(c2" + ",'true',e);return 1;}}");
  /*
   * Plugin: getValOnce_v1.1
   */

  s.getValOnce = new Function("v", "c", "e", "t", "" + "var s=this,a=new Date,v=v?v:'',c=c?c:'s_gvo',e=e?e:0,i=t=='m'?6000" + "0:86400000;k=s.c_r(c);if(v){a.setTime(a.getTime()+e*i);s.c_w(c,v,e" + "==0?0:a);}return v==k?'':v");
  /* eslint-enable */

  return s;
}

module.exports.pre = pre;
module.exports.post = post;
}, {}];
window.modules["202"] = [function(require,module,exports){;(function(){
"use strict";

var store = require(197);

module.exports = {
  data: function data() {
    return {
      paymentType: 'Credit Card'
    };
  },
  computed: {
    selectedPlan: function selectedPlan() {
      return store.state.selectedPlan;
    },
    pcdAccountNumber: function pcdAccountNumber() {
      return store.state.pcdAccountNumber;
    },
    firstChargeAmount: function firstChargeAmount() {
      var selectedTier = store.getters.selectedTier();
      return selectedTier ? selectedTier.firstChargeAmount : '';
    },
    recurringChargeAmount: function recurringChargeAmount() {
      var selectedTier = store.getters.selectedTier();
      return selectedTier ? selectedTier.recurringChargeAmount : '';
    },
    recurringChargePeriod: function recurringChargePeriod() {
      var selectedTier = store.getters.selectedTier();
      return selectedTier ? selectedTier.recurringChargePeriod : '';
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"subscription-order-summary"},[_c('header',{staticClass:"title"},[_vm._v("Order Summary")]),_vm._v(" "),_c('div',{staticClass:"subs-order-summary"},[_c('p',{staticClass:"subs-first-charge"},[_vm._v("Your total today was $"+_vm._s(_vm.firstChargeAmount))]),_vm._v(" "),_c('div',{staticClass:"subs-order-details"},[_c('div',{staticClass:"detail"},[_c('div',{staticClass:"detail-label"},[_vm._v("Account #")]),_vm._v(" "),_c('div',{staticClass:"detail-content"},[_vm._v(_vm._s(_vm.pcdAccountNumber))])]),_vm._v(" "),_c('div',{staticClass:"detail"},[_c('div',{staticClass:"detail-label"},[_vm._v("Subscription Plan")]),_vm._v(" "),_c('div',{staticClass:"detail-content"},[_vm._v(_vm._s(_vm.selectedPlan))])]),_vm._v(" "),_c('div',{staticClass:"detail"},[_c('div',{staticClass:"detail-label"},[_vm._v("Plan Cost")]),_vm._v(" "),_c('div',{staticClass:"detail-content"},[_vm._v("$"+_vm._s(_vm.recurringChargeAmount)+"/"+_vm._s(_vm.recurringChargePeriod))])]),_vm._v(" "),_c('div',{staticClass:"detail"},[_c('div',{staticClass:"detail-label"},[_vm._v("Payment Type")]),_vm._v(" "),_c('div',{staticClass:"detail-content"},[_vm._v(_vm._s(_vm.paymentType))])])]),_vm._v(" "),_c('p',{staticClass:"subs-email"},[_vm._v("We've also sent an email with your order confirmation and complete details.")])])])}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require(10)
  hotAPI.install(require(8), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-220f5980", __vue__options__)
  } else {
    hotAPI.reload("data-v-220f5980", __vue__options__)
  }
})()}}, {"8":8,"10":10,"197":197}];
window.modules["199"] = [function(require,module,exports){;(function(){
"use strict";

var store = require(197);

module.exports = {
  props: ['planType', 'planName', 'unselectedButtonText', 'defaultSelection'],
  computed: {
    isSelected: function isSelected() {
      return this.planType === store.state.selectedPlan;
    }
  },
  methods: {
    selectPlanType: function selectPlanType() {
      var elementToAdd = this.$el.closest(".subscription-plan"),
          elementToRemove = this.$el.closest(".subscription-plans");
      store.actions.selectPlanType(this.planType);

      if (elementToRemove.querySelector('.selected')) {
        elementToRemove.querySelector('.selected').classList.remove('selected');
      }

      elementToAdd.classList.add('selected');
    }
  },
  mounted: function mounted() {
    var _this = this;

    var propNames = Object.keys(this._props),
        data = propNames.reduce(function (acc, propName) {
      acc[propName] = _this[propName];
      return acc;
    }, {}),
        nearestPlan = this.$el.closest(".subscription-plan");
    nearestPlan.addEventListener('click', function () {
      _this.selectPlanType();
    });

    if (!!this.defaultSelection) {
      store.actions.setDefaultPlan(this.planName);
      this.selectPlanType();
    }

    store.actions.registerPlan(data);
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('button',{staticClass:"plan-button",class:{ selected: _vm.isSelected }},[_c('span',{staticClass:"unselected-button"},[_vm._v(_vm._s(_vm.unselectedButtonText))]),_vm._v(" "),_c('span',{staticClass:"selected-button"})])}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require(10)
  hotAPI.install(require(8), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7cf4bba2", __vue__options__)
  } else {
    hotAPI.reload("data-v-7cf4bba2", __vue__options__)
  }
})()}}, {"8":8,"10":10,"197":197}];
window.modules["209"] = [function(require,module,exports){'use strict'; // this is a big regex that matches everything embedly knows about that ISN'T a video provider
// generated from http://embed.ly/tools/generator
// note: embedly doesn't know about twitter, so we added it manually

module.exports.match = function (url) {
  return url.match(/((http:\/\/(www\.flickr\.com\/photos\/.*|flic\.kr\/.*|polaroidswing\.com\/p\/.*|momento360\.com\/e\/u\/.*|https\?:\/\/kuula\.co\/post\/.*|.*imgur\.com\/.*|i.*\.photobucket\.com\/albums\/.*|s.*\.photobucket\.com\/albums\/.*|media\.photobucket\.com\/image\/.*|www\.mobypicture\.com\/user\/.*\/view\/.*|moby\.to\/.*|xkcd\.com\/.*|www\.xkcd\.com\/.*|imgs\.xkcd\.com\/.*|www\.asofterworld\.com\/index\.php\?id=.*|www\.asofterworld\.com\/.*\.jpg|asofterworld\.com\/.*\.jpg|www\.qwantz\.com\/index\.php\?comic=.*|23hq\.com\/.*\/photo\/.*|www\.23hq\.com\/.*\/photo\/.*|.*dribbble\.com\/shots\/.*|drbl\.in\/.*|.*\.smugmug\.com\/.*|.*\.smugmug\.com\/.*#.*|img\.ly\/.*|www\.tinypic\.com\/view\.php.*|tinypic\.com\/view\.php.*|www\.tinypic\.com\/player\.php.*|tinypic\.com\/player\.php.*|www\.tinypic\.com\/r\/.*\/.*|tinypic\.com\/r\/.*\/.*|.*\.tinypic\.com\/.*\.jpg|.*\.tinypic\.com\/.*\.png|meadd\.com\/.*\/.*|meadd\.com\/.*|.*\.deviantart\.com\/art\/.*|.*\.deviantart\.com\/gallery\/.*|.*\.deviantart\.com\/#\/.*|fav\.me\/.*|.*\.deviantart\.com|.*\.deviantart\.com\/gallery|.*\.deviantart\.com\/.*\/.*\.jpg|.*\.deviantart\.com\/.*\/.*\.gif|.*\.deviantart\.net\/.*\/.*\.jpg|.*\.deviantart\.net\/.*\/.*\.gif|www\.fotopedia\.com\/.*\/.*|fotopedia\.com\/.*\/.*|photozou\.jp\/photo\/show\/.*\/.*|photozou\.jp\/photo\/photo_only\/.*\/.*|instagr\.am\/p\/.*|instagram\.com\/p\/.*|www\.instagram\.com\/p\/.*|skitch\.com\/.*\/.*\/.*|img\.skitch\.com\/.*|www\.questionablecontent\.net\/|questionablecontent\.net\/|www\.questionablecontent\.net\/view\.php.*|questionablecontent\.net\/view\.php.*|questionablecontent\.net\/comics\/.*\.png|www\.questionablecontent\.net\/comics\/.*\.png|twitrpix\.com\/.*|.*\.twitrpix\.com\/.*|www\.someecards\.com\/.*\/.*|someecards\.com\/.*\/.*|some\.ly\/.*|www\.some\.ly\/.*|pikchur\.com\/.*|achewood\.com\/.*|www\.achewood\.com\/.*|achewood\.com\/index\.php.*|www\.achewood\.com\/index\.php.*|www\.whosay\.com\/.*\/content\/.*|www\.whosay\.com\/.*\/photos\/.*|www\.whosay\.com\/.*\/videos\/.*|say\.ly\/.*|ow\.ly\/i\/.*|mlkshk\.com\/p\/.*|d\.pr\/i\/.*|www\.eyeem\.com\/p\/.*|www\.eyeem\.com\/a\/.*|www\.eyeem\.com\/u\/.*|giphy\.com\/gifs\/.*|gph\.is\/.*|frontback\.me\/p\/.*|www\.frontback\.me\/p\/.*|www\.fotokritik\.com\/.*\/.*|fotokritik\.com\/.*\/.*|vid\.me\/.*|galeri\.uludagsozluk\.com\/.*|gfycat\.com\/.*|tochka\.net\/.*|.*\.tochka\.net\/.*|4cook\.net\/recipe\/.*|www\.alphahat\.com\/view\/.*|alphahat\.com\/view\/.*|futurism\.com\/images\/.*|superstack\.io\/v\/.*|gist\.github\.com\/.*|producthunt\.com\/.*|www\.slideshare\.net\/.*\/.*|www\.slideshare\.net\/mobile\/.*\/.*|.*\.slideshare\.net\/.*\/.*|slidesha\.re\/.*|scribd\.com\/doc\/.*|www\.scribd\.com\/doc\/.*|scribd\.com\/mobile\/documents\/.*|www\.scribd\.com\/mobile\/documents\/.*|upscri\.be\/.*|contentupgrade\.me\/.*|screenr\.com\/.*|pollshare\.com\/poll\/.*|polldaddy\.com\/community\/poll\/.*|polldaddy\.com\/poll\/.*|answers\.polldaddy\.com\/poll\/.*|www\.howcast\.com\/videos\/.*|www\.screencast\.com\/.*\/media\/.*|screencast\.com\/.*\/media\/.*|www\.screencast\.com\/t\/.*|screencast\.com\/t\/.*|issuu\.com\/.*\/docs\/.*|www\.kickstarter\.com\/projects\/.*\/.*|www\.scrapblog\.com\/viewer\/viewer\.aspx.*|foursquare\.com\/.*|www\.foursquare\.com\/.*|4sq\.com\/.*|linkedin\.com\/in\/.*|linkedin\.com\/pub\/.*|.*\.linkedin\.com\/in\/.*|.*\.linkedin\.com\/pub\/.*|linkedin\.com\/in\/.*|linkedin\.com\/company\/.*|.*\.linkedin\.com\/company\/.*|www\.sliderocket\.com\/.*|sliderocket\.com\/.*|app\.sliderocket\.com\/.*|portal\.sliderocket\.com\/.*|beta-sliderocket\.com\/.*|www\.yelp\.com\/.*&hrid=\.+|www\.sociale\.co\/question\/.*|www\.genial\.ly\/.*|maps\.google\.com\/maps\?.*|maps\.google\.com\/\?.*|maps\.google\.com\/maps\/ms\?.*|www\.google\..*\/maps\/.*|google\..*\/maps\/.*|.*\.alpacamaps\.com\/.*|graphcommons\.com\/graphs\/.*|graphcommons\.com\/nodes\/.*|https\?:\/\/infogr\.am\/.*|datawrapper\.dwcdn\.net\/.*|embed\.kumu\.io|embed\.kumu\.io|my\.opera\.com\/.*\/albums\/show\.dml\?id=.*|my\.opera\.com\/.*\/albums\/showpic\.dml\?album=.*&picture=.*|tumblr\.com\/.*|.*\.tumblr\.com\/post\/.*|www\.polleverywhere\.com\/polls\/.*|www\.polleverywhere\.com\/multiple_choice_polls\/.*|www\.polleverywhere\.com\/free_text_polls\/.*|www\.quantcast\.com\/wd:.*|www\.quantcast\.com\/.*|siteanalytics\.compete\.com\/.*|.*\.status\.net\/notice\/.*|identi\.ca\/notice\/.*|myloc\.me\/.*|pastebin\.com\/.*|pastie\.org\/.*|www\.pastie\.org\/.*|redux\.com\/stream\/item\/.*\/.*|redux\.com\/f\/.*\/.*|www\.redux\.com\/stream\/item\/.*\/.*|www\.redux\.com\/f\/.*\/.*|cl\.ly\/.*|cl\.ly\/.*\/content|speakerdeck\.com\/.*\/.*|www\.kiva\.org\/lend\/.*|www\.timetoast\.com\/timelines\/.*|storify\.com\/.*\/.*|.*meetup\.com\/.*|meetu\.ps\/.*|www\.dailymile\.com\/people\/.*\/entries\/.*|.*\.kinomap\.com\/.*|www\.metacdn\.com\/r\/c\/.*\/.*|www\.metacdn\.com\/r\/m\/.*\/.*|prezi\.com\/.*\/.*|.*\.uservoice\.com\/.*\/suggestions\/.*|www\.wikipedia\.org\/wiki\/.*|.*\.wikipedia\.org\/wiki\/.*|www\.wikimedia\.org\/wiki\/File.*|360\.io\/.*|www\.behance\.net\/gallery\/.*|behance\.net\/gallery\/.*|www\.jdsupra\.com\/legalnews\/.*|jdsupra\.com\/legalnews\/.*|minilogs\.com\/.*|www\.minilogs\.com\/.*|jsfiddle\.net\/.*|ponga\.com\/.*|list\.ly\/list\/.*|crowdmap\.com\/post\/.*|.*\.crowdmap\.com\/post\/.*|crowdmap\.com\/map\/.*|.*\.crowdmap\.com\/map\/.*|ifttt\.com\/recipes\/.*|weavly\.com\/watch\/.*|www\.weavly\.com\/watch\/.*|tagmotion\.com\/tree\/.*|www\.tagmotion\.com\/tree\/.*|public\.talely\.com\/.*\/.*|polarb\.com\/.*|.*\.polarb\.com\/.*|on\.bubb\.li\/.*|bubb\.li\/.*|.*\.bubb\.li\/.*|embed\.imajize\.com\/.*|giflike\.com\/a\/.*|www\.giflike\.com\/a\/.*|i\.giflike\.com\/.*|rapidengage\.com\/s\/.*|infomous\.com\/node\/.*|stepic\.org\/.*|chirb\.it\/.*|beta\.polstir\.com\/.*\/.*|polstir\.com\/.*\/.*|www\.gettyimages\.com\/detail\/photo\/.*|gty\.im\/.*|www\.gettyimages\.com\/license\/.*|isnare\.com\/.*|www\.isnare\.com\/.*|www\.branchtrack\.com\/projects\/.*|jsbin\.com\/.*\/.*|jsbin\.com\/.*|wedgi\.es\/.*|public\.chartblocks\.com\/c\/.*|radd\.it\/r\/.*|radd\.it\/comments\/.*|radd\.it\/user\/.*|radd\.it\/playlists\/.*|radd\.it\/magic\/.*|vibi\.com\/videocard\/.*|kastio\.com\/webcasts\/.*|.*\.kastio\.com\/webcasts\/.*|megavisor\.com\/view\/.*|megavisor\.com\/en\/view\/.*|bunkrapp\.com\/.*\/.*|.*\.cartodb\.com\/.*\/.*|flowvella\.com\/s\/.*|fr\.peoplbrain\.com\/tutoriaux\/.*|codepicnic\.com\/bites\/.*|codepicnic\.com\/consoles\/.*|tr\.instela\.com\/.*|codepen\.io\/.*\/pen\/.*|codepen\.io\/.*\/pen\/.*|runelm\.io\/.*\/.*|www\.vtility\.net\/virtualtour\/.*|quora\.com\/.*\/answer\/.*|www\.quora\.com\/.*\/answer\/.*|tunein\.com\/.*|tun\.in\/.*|scribblemaps\.com\/maps\/view\/.*\/.*|www\.scribblemaps\.com\/maps\/view\/.*\/.*|www\.codeply\.com\/view\/.*|codeply\.com\/view\/.*|www\.candybank\.com\/.*|flat\.io\/score\/.*|www\.qzzr\.com\/quiz\/.*|shorti\.com\/.*|www\.shorti\.com\/.*|blab\.im\/.*|pollplug\.com\/poll\/.*|alpha\.vrchive\.com\/.*|vrchive\.com\/.*|www\.globalgiving\.org\/projects\/.*|www\.globalgiving\.org\/funds\/.*|www\.globalgiving\.org\/microprojects\/.*|www\.newhive\.com\/.*\/.*|slidr\.io\/.*\/.*|publons\.com\/author\/.*|www\.publons\.com\/author\/.*|calameo\.com\/.*|www\.calameo\.com\/.*|relayto\.com\/.*|www\.relayto\.com\/.*|www\.graphiq\.com\/w\/.*|graphiq\.com\/w\/.*|w\.graphiq\.com\/w\/.*|view\.stacker\.cc\/.*|content\.newsbound\.com\/.*\/.*|.*\.silk\.co\/explore\/.*|docs\.com\/.*|rocketium\.com\/.*|cdn\.knightlab\.com\/libs\/timeline3\/.*|cdn\.knightlab\.com\/libs\/juxtapose\/.*|uploads\.knightlab\.com\/storymapjs\/.*\/index\.html|www\.thelastgraph\.com\/lg\.php\?a=.*|thelastgraph\.com\/lg\.php\?a=.*|rogertalk\.com\/.*|www\.rogertalk\.com\/.*|stackshare\.io\/.*|www\.stackshare\.io\/.*|maphubs\.com\/user\/.*\/map\/.*|www\.maphubs\.com\/user\/.*\/map\/.*|braid\.io\/embed-tile\/.*|www\.braid\.io\/embed-tile\/.*|talkshow\.im\/show\/.*|www\.talkshow\.im\/show\/.*|medibang\.com\/sv\/.*|www\.medibang\.com\/sv\/.*|redivis\.com\/r\/.*|www\.redivis\.com\/r\/.*|my\.webboards\.fr\/.*|cooler\.tv\/.*|mathembed\.com\/latex.*|minko\.io\/s\/|campaign\.theheartstringsproject\.com\/.*|www\.altizure\.com\/project\/.*|exploratory\.io\/viz\/.*|esplor\.io\/.*|www\.pastery\.net\/.*|hardbound\.co\/.*\/.*\/.*|mybeweeg\.com\/w\/.*|storribook\.com\/articles\/view\/.*\/.*|sidewire\.com\/.*\/.*\/.*|codiva\.io\/p\/.*|www\.codiva\.io\/p\/.*|www\.fwdeveryone\.com\/t\/.*|fwdeveryone\.com\/t\/.*|app\.wizer\.me\/learn\/.*|app\.wizer\.me\/preview\/.*|kidoju\.com\/.*|.*\.razoo\.com\/.*|eyrie\.io\/.*|verse\.com\/stories\/.*|www\.moviemogul\.io\/.*|walkinto\.in\/.*\/.*|.*\.walkinto\.in\/.*\/.*|spaces\.archilogic\.com\/model\/.*|spaces\.archilogic\.com\/3d\/.*|ellie-app\.com\/.*\/.*|www\.maprosoft\.com\/app\/map.*|www\.gradba\.se\/v\/.*|cincopa\.com\/~.*|.*\.cincopa\.com\/watch\/.*|vr3d\.vn\/.*|lcontacts\.herokuapp\.com\/embed\/button\/.*|vrbfoto\.com\/f\/.*|orbitvu\.com\/001\/.*|www\.amazon\.com\/gp\/product\/.*|www\.amazon\.com\/.*\/dp\/.*|www\.amazon\.com\/o\/ASIN\/.*|www\.amazon\.com\/gp\/offer-listing\/.*|www\.amazon\.com\/.*\/ASIN\/.*|www\.amazon\.com\/gp\/aw\/d\/.*|amazon\.com\/gp\/product\/.*|amazon\.com\/.*\/dp\/.*|amazon\.com\/o\/ASIN\/.*|amazon\.com\/gp\/offer-listing\/.*|amazon\.com\/.*\/ASIN\/.*|amazon\.com\/gp\/aw\/d\/.*|www\.amazon\.cn\/gp\/product\/.*|www\.amazon\.cn\/.*\/dp\/.*|www\.amazon\.cn\/o\/ASIN\/.*|www\.amazon\.cn\/gp\/offer-listing\/.*|www\.amazon\.cn\/.*\/ASIN\/.*|www\.amazon\.cn\/gp\/aw\/d\/.*|amazon\.cn\/gp\/product\/.*|amazon\.cn\/.*\/dp\/.*|amazon\.cn\/o\/ASIN\/.*|amazon\.cn\/gp\/offer-listing\/.*|amazon\.cn\/.*\/ASIN\/.*|amazon\.cn\/gp\/aw\/d\/.*|www\.amazon\.in\/gp\/product\/.*|www\.amazon\.in\/.*\/dp\/.*|www\.amazon\.in\/o\/ASIN\/.*|www\.amazon\.in\/gp\/offer-listing\/.*|www\.amazon\.in\/.*\/ASIN\/.*|www\.amazon\.in\/gp\/aw\/d\/.*|amazon\.in\/gp\/product\/.*|amazon\.in\/.*\/dp\/.*|amazon\.in\/o\/ASIN\/.*|amazon\.in\/gp\/offer-listing\/.*|amazon\.in\/.*\/ASIN\/.*|amazon\.in\/gp\/aw\/d\/.*|www\.amazon\.co\.jp\/gp\/product\/.*|www\.amazon\.co\.jp\/.*\/dp\/.*|www\.amazon\.co\.jp\/o\/ASIN\/.*|www\.amazon\.co\.jp\/gp\/offer-listing\/.*|www\.amazon\.co\.jp\/.*\/ASIN\/.*|www\.amazon\.co\.jp\/gp\/aw\/d\/.*|amazon\.co\.jp\/gp\/product\/.*|amazon\.co\.jp\/.*\/dp\/.*|amazon\.co\.jp\/o\/ASIN\/.*|amazon\.co\.jp\/gp\/offer-listing\/.*|amazon\.co\.jp\/.*\/ASIN\/.*|amazon\.co\.jp\/gp\/aw\/d\/.*|www\.amazon\.fr\/gp\/product\/.*|www\.amazon\.fr\/.*\/dp\/.*|www\.amazon\.fr\/o\/ASIN\/.*|www\.amazon\.fr\/gp\/offer-listing\/.*|www\.amazon\.fr\/.*\/ASIN\/.*|www\.amazon\.fr\/gp\/aw\/d\/.*|amazon\.fr\/gp\/product\/.*|amazon\.fr\/.*\/dp\/.*|amazon\.fr\/o\/ASIN\/.*|amazon\.fr\/gp\/offer-listing\/.*|amazon\.fr\/.*\/ASIN\/.*|amazon\.fr\/gp\/aw\/d\/.*|www\.amazon\.de\/gp\/product\/.*|www\.amazon\.de\/.*\/dp\/.*|www\.amazon\.de\/o\/ASIN\/.*|www\.amazon\.de\/gp\/offer-listing\/.*|www\.amazon\.de\/.*\/ASIN\/.*|www\.amazon\.de\/gp\/aw\/d\/.*|amazon\.de\/gp\/product\/.*|amazon\.de\/.*\/dp\/.*|amazon\.de\/o\/ASIN\/.*|amazon\.de\/gp\/offer-listing\/.*|amazon\.de\/.*\/ASIN\/.*|amazon\.de\/gp\/aw\/d\/.*|www\.amazon\.es\/gp\/product\/.*|www\.amazon\.es\/.*\/dp\/.*|www\.amazon\.es\/o\/ASIN\/.*|www\.amazon\.es\/gp\/offer-listing\/.*|www\.amazon\.es\/.*\/ASIN\/.*|www\.amazon\.es\/gp\/aw\/d\/.*|amazon\.es\/gp\/product\/.*|amazon\.es\/.*\/dp\/.*|amazon\.es\/o\/ASIN\/.*|amazon\.es\/gp\/offer-listing\/.*|amazon\.es\/.*\/ASIN\/.*|amazon\.es\/gp\/aw\/d\/.*|www\.amazon\.it\/gp\/product\/.*|www\.amazon\.it\/.*\/dp\/.*|www\.amazon\.it\/o\/ASIN\/.*|www\.amazon\.it\/gp\/offer-listing\/.*|www\.amazon\.it\/.*\/ASIN\/.*|www\.amazon\.it\/gp\/aw\/d\/.*|amazon\.it\/gp\/product\/.*|amazon\.it\/.*\/dp\/.*|amazon\.it\/o\/ASIN\/.*|amazon\.it\/gp\/offer-listing\/.*|amazon\.it\/.*\/ASIN\/.*|amazon\.it\/gp\/aw\/d\/.*|www\.amazon\.co\.uk\/gp\/product\/.*|www\.amazon\.co\.uk\/.*\/dp\/.*|www\.amazon\.co\.uk\/o\/ASIN\/.*|www\.amazon\.co\.uk\/gp\/offer-listing\/.*|www\.amazon\.co\.uk\/.*\/ASIN\/.*|www\.amazon\.co\.uk\/gp\/aw\/d\/.*|amazon\.co\.uk\/gp\/product\/.*|amazon\.co\.uk\/.*\/dp\/.*|amazon\.co\.uk\/o\/ASIN\/.*|amazon\.co\.uk\/gp\/offer-listing\/.*|amazon\.co\.uk\/.*\/ASIN\/.*|amazon\.co\.uk\/gp\/aw\/d\/.*|www\.amazon\.ca\/gp\/product\/.*|www\.amazon\.ca\/.*\/dp\/.*|www\.amazon\.ca\/o\/ASIN\/.*|www\.amazon\.ca\/gp\/offer-listing\/.*|www\.amazon\.ca\/.*\/ASIN\/.*|www\.amazon\.ca\/gp\/aw\/d\/.*|amazon\.ca\/gp\/product\/.*|amazon\.ca\/.*\/dp\/.*|amazon\.ca\/o\/ASIN\/.*|amazon\.ca\/gp\/offer-listing\/.*|amazon\.ca\/.*\/ASIN\/.*|amazon\.ca\/gp\/aw\/d\/.*|www\.amazon\.com\.mx\/gp\/product\/.*|www\.amazon\.com\.mx\/.*\/dp\/.*|www\.amazon\.com\.mx\/o\/ASIN\/.*|www\.amazon\.com\.mx\/gp\/offer-listing\/.*|www\.amazon\.com\.mx\/.*\/ASIN\/.*|www\.amazon\.com\.mx\/gp\/aw\/d\/.*|amazon\.com\.mx\/gp\/product\/.*|amazon\.com\.mx\/.*\/dp\/.*|amazon\.com\.mx\/o\/ASIN\/.*|amazon\.com\.mx\/gp\/offer-listing\/.*|amazon\.com\.mx\/.*\/ASIN\/.*|amazon\.com\.mx\/gp\/aw\/d\/.*|www\.amazon\.com\.au\/gp\/product\/.*|www\.amazon\.com\.au\/.*\/dp\/.*|www\.amazon\.com\.au\/o\/ASIN\/.*|www\.amazon\.com\.au\/gp\/offer-listing\/.*|www\.amazon\.com\.au\/.*\/ASIN\/.*|www\.amazon\.com\.au\/gp\/aw\/d\/.*|amazon\.com\.au\/gp\/product\/.*|amazon\.com\.au\/.*\/dp\/.*|amazon\.com\.au\/o\/ASIN\/.*|amazon\.com\.au\/gp\/offer-listing\/.*|amazon\.com\.au\/.*\/ASIN\/.*|amazon\.com\.au\/gp\/aw\/d\/.*|www\.amazon\.com\.br\/gp\/product\/.*|www\.amazon\.com\.br\/.*\/dp\/.*|www\.amazon\.com\.br\/o\/ASIN\/.*|www\.amazon\.com\.br\/gp\/offer-listing\/.*|www\.amazon\.com\.br\/.*\/ASIN\/.*|www\.amazon\.com\.br\/gp\/aw\/d\/.*|amazon\.com\.br\/gp\/product\/.*|amazon\.com\.br\/.*\/dp\/.*|amazon\.com\.br\/o\/ASIN\/.*|amazon\.com\.br\/gp\/offer-listing\/.*|amazon\.com\.br\/.*\/ASIN\/.*|amazon\.com\.br\/gp\/aw\/d\/.*|www\.amzn\.com\/.*|amzn\.com\/.*|shoplocket\.com\/products\/.*|etsy\.com\/.*|www\.etsy\.com\/.*|fiverr\.com\/.*\/.*|www\.fiverr\.com\/.*\/.*|kit\.com\/.*|soundcloud\.com\/.*|soundcloud\.com\/.*\/.*|soundcloud\.com\/.*\/sets\/.*|soundcloud\.com\/groups\/.*|snd\.sc\/.*|open\.spotify\.com\/.*|spoti\.fi\/.*|play\.spotify\.com\/.*|www\.last\.fm\/music\/.*|www\.last\.fm\/music\/+videos\/.*|www\.last\.fm\/music\/+images\/.*|www\.last\.fm\/music\/.*\/_\/.*|www\.last\.fm\/music\/.*\/.*|www\.simplecast\.com\/s\/.*|www\.changelog\.com\/.*|www\.megafono\.io\/.*|www\.mixcloud\.com\/.*\/.*\/|play\.radiopublic\.com\/.*|www\.hark\.com\/clips\/.*|www\.rdio\.com\/#\/artist\/.*\/album\/.*|www\.rdio\.com\/artist\/.*\/album\/.*|www\.zero-inch\.com\/.*|.*\.bandcamp\.com\/|.*\.bandcamp\.com\/track\/.*|.*\.bandcamp\.com\/album\/.*|freemusicarchive\.org\/music\/.*|www\.freemusicarchive\.org\/music\/.*|freemusicarchive\.org\/curator\/.*|www\.freemusicarchive\.org\/curator\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/templates\/story\/story\.php.*|huffduffer\.com\/.*\/.*|audioboom\.com\/posts\/.*|www\.audioboom\.com\/boos\/.*|audioboom\.com\/boos\/.*|boo\.fm\/b.*|www\.xiami\.com\/song\/.*|xiami\.com\/song\/.*|www\.saynow\.com\/playMsg\.html.*|www\.saynow\.com\/playMsg\.html.*|grooveshark\.com\/.*|radioreddit\.com\/songs.*|www\.radioreddit\.com\/songs.*|radioreddit\.com\/\?q=songs.*|www\.radioreddit\.com\/\?q=songs.*|www\.gogoyoko\.com\/song\/.*|hypem\.com\/premiere\/.*|bop\.fm\/s\/.*\/.*|clyp\.it\/.*|www\.dnbradio\.com\/.*|dnbradio\.com\/.*|anchor\.fm\/.*|bumpers\.fm\/e\/.*|buzzsprout\.com\/.*|.*\.buzzsprout\.com\/.*|60db\.co\/story\/.*|allihoopa\.com\/s\/.*|vizamp\.com\/player\/.*|www\.vizamp\.com\/player\/.*|tapewrite\.com\/.*|player\.megaphone\.fm\/.*|cms\.megaphone\.fm\/.*|play\.soundsgood\.co\/.*|.*\.sparemin\.com\/myrecording|.*\.sparemin\.com\/recording-.*))|(https:\/\/(www\.flickr\.com\/photos\/.*|flic\.kr\/.*|polaroidswing\.com\/p\/.*|momento360\.com\/e\/u\/.*|.*imgur\.com\/.*|www\.instagram\.com\/p\/.*|skitch\.com\/.*\/.*\/.*|img\.skitch\.com\/.*|frontback\.me\/p\/.*|www\.frontback\.me\/p\/.*|vidd\.me\/.*|vid\.me\/.*|gfycat\.com\/.*|.*\.accredible\.com\/.*|accredible\.com\/.*|futurism\.com\/images\/.*|superstack\.io\/v\/.*|www\.pexels\.com\/photo\/.*|gist\.github\.com\/.*|producthunt\.com\/.*|www\.slideshare\.net\/.*\/.*|www\.slideshare\.net\/mobile\/.*\/.*|.*\.slideshare\.net\/.*\/.*|slidesha\.re\/.*|scribd\.com\/doc\/.*|www\.scribd\.com\/doc\/.*|scribd\.com\/mobile\/documents\/.*|www\.scribd\.com\/mobile\/documents\/.*|scribd\.com\/documents\/.*|www\.scribd\.com\/documents\/.*|upscri\.be\/.*|contentupgrade\.me\/.*|pollshare\.com\/poll\/.*|www\.getwhichit\.com\/page\/.*|issuu\.com\/.*\/docs\/.*|www\.kickstarter\.com\/projects\/.*\/.*|foursquare\.com\/.*|www\.foursquare\.com\/.*|linkedin\.com\/in\/.*|linkedin\.com\/pub\/.*|.*\.linkedin\.com\/in\/.*|.*\.linkedin\.com\/pub\/.*|linkedin\.com\/in\/.*|linkedin\.com\/company\/.*|.*\.linkedin\.com\/company\/.*|www\.yelp\.com\/.*&hrid=\.+|www\.sociale\.co\/question\/.*|www\.genial\.ly\/.*|maps\.google\.com\/maps\?.*|maps\.google\.com\/\?.*|maps\.google\.com\/maps\/ms\?.*|www\.google\..*\/maps\/.*|google\..*\/maps\/.*|.*\.alpacamaps\.com\/.*|graphcommons\.com\/graphs\/.*|graphcommons\.com\/nodes\/.*|datawrapper\.dwcdn\.net\/.*|tumblr\.com\/.*|.*\.tumblr\.com\/post\/.*|pastebin\.com\/.*|speakerdeck\.com\/.*\/.*|storify\.com\/.*\/.*|.*meetup\.com\/.*|meetu\.ps\/.*|www\.wikipedia\.org\/wiki\/.*|.*\.wikipedia\.org\/wiki\/.*|www\.wikimedia\.org\/wiki\/File.*|urtak\.com\/u\/.*|urtak\.com\/clr\/.*|ganxy\.com\/.*|www\.ganxy\.com\/.*|sketchfab\.com\/models\/.*|sketchfab\.com\/show\/.*|ifttt\.com\/recipes\/.*|cloudup\.com\/.*|rapidengage\.com\/s\/.*|stepic\.org\/.*|readtapestry\.com\/s\/.*\/|chirb\.it\/.*|www\.gettyimages\.com\/detail\/photo\/.*|gty\.im\/.*|www\.gettyimages\.com\/license\/.*|www\.branchtrack\.com\/projects\/.*|www\.wedgies\.com\/question\/.*|public\.chartblocks\.com\/c\/.*|megavisor\.com\/view\/.*|megavisor\.com\/en\/view\/.*|bunkrapp\.com\/.*\/.*|.*\.cartodb\.com\/.*\/.*|flowvella\.com\/s\/.*|fr\.peoplbrain\.com\/tutoriaux\/.*|codepicnic\.com\/bites\/.*|codepicnic\.com\/consoles\/.*|tr\.instela\.com\/.*|runelm\.io\/.*\/.*|quora\.com\/.*\/answer\/.*|www\.quora\.com\/.*\/answer\/.*|tunein\.com\/.*|tun\.in\/.*|scribblemaps\.com\/maps\/view\/.*\/.*|www\.scribblemaps\.com\/maps\/view\/.*\/.*|marvelapp\.com\/.*|www\.flat\.io\/score\/.*|www\.qzzr\.com\/quiz\/.*|blab\.im\/.*|glitter\.club\/.*|pollplug\.com\/poll\/.*|alpha\.vrchive\.com\/.*|vrchive\.com\/.*|www\.globalgiving\.org\/projects\/.*|www\.globalgiving\.org\/funds\/.*|www\.globalgiving\.org\/microprojects\/.*|www\.newhive\.com\/.*\/.*|newhive\.com\/.*\/.*|newhive\.com\/.*\/.*|slidr\.io\/.*\/.*|publons\.com\/author\/.*|www\.publons\.com\/author\/.*|calameo\.com\/.*|www\.calameo\.com\/.*|relayto\.com\/.*|www\.relayto\.com\/.*|www\.graphiq\.com\/w\/.*|graphiq\.com\/w\/.*|w\.graphiq\.com\/w\/.*|view\.stacker\.cc\/.*|content\.newsbound\.com\/.*\/.*|projects\.invisionapp\.com\/share\/.*|invis\.io\/.*|.*\.silk\.co\/explore\/.*|docs\.com\/.*|sway\.com\/.*|publicgood\.com\/campaign\/.*|publicgood\.com\/org\/.*|publicgood\.com\/org\/.*\/campaign\/.*|airtable\.com\/shr.*|rocketium\.com\/.*|cdn\.knightlab\.com\/libs\/timeline3\/.*|cdn\.knightlab\.com\/libs\/juxtapose\/.*|rogertalk\.com\/.*|www\.rogertalk\.com\/.*|maphubs\.com\/user\/.*\/map\/.*|www\.maphubs\.com\/user\/.*\/map\/.*|braid\.io\/embed-tile\/.*|www\.braid\.io\/embed-tile\/.*|talkshow\.im\/show\/.*|www\.talkshow\.im\/show\/.*|medibang\.com\/sv\/.*|www\.medibang\.com\/sv\/.*|redivis\.com\/r\/.*|www\.redivis\.com\/r\/.*|my\.webboards\.fr\/.*|my\.matterport\.com\/show\/.*|cooler\.tv\/.*|mathembed\.com\/latex.*|minko\.io\/s\/|campaign\.theheartstringsproject\.com\/.*|www\.altizure\.com\/project\/.*|exploratory\.io\/viz\/.*|maps\.mysidewalk\.com\/.*|esplor\.io\/.*|www\.pastery\.net\/.*|hardbound\.co\/.*\/.*\/.*|mybeweeg\.com\/w\/.*|storribook\.com\/articles\/view\/.*\/.*|sidewire\.com\/.*\/.*\/.*|codiva\.io\/p\/.*|www\.codiva\.io\/p\/.*|www\.fwdeveryone\.com\/t\/.*|fwdeveryone\.com\/t\/.*|app\.wizer\.me\/learn\/.*|app\.wizer\.me\/preview\/.*|kidoju\.com\/.*|.*\.razoo\.com\/.*|eyrie\.io\/.*|verse\.com\/stories\/.*|www\.canva\.com\/design\/.*|www\.moviemogul\.io\/.*|powered\.by\.rabbut\.com\/p\/.*|walkinto\.in\/.*\/.*|.*\.walkinto\.in\/.*\/.*|spaces\.archilogic\.com\/model\/.*|spaces\.archilogic\.com\/3d\/.*|api\.peptone\.io\/v1\/visualize\/.*|www\.highly\.co\/hl\/.*|.*\.uplabs\.com\/posts\/.*|ellie-app\.com\/.*\/.*|www\.maprosoft\.com\/app\/map.*|www\.gradba\.se\/v\/.*|cincopa\.com\/~.*|.*\.cincopa\.com\/watch\/.*|lcontacts\.herokuapp\.com\/embed\/button\/.*|vrbfoto\.com\/f\/.*|orbitvu\.com\/001\/.*|www\.ipushpull\.com\/pages\/domains\/.*\/pages\/.*|ipushpull\.com\/pages\/domains\/.*\/pages\/.*|app\.very\.gd\/p\/.*|www\.icloud\.com\/keynote\/.*|icloud\.com\/keynote\/.*|www\.iorad\.com\/player\/.*|iorad\.com\/player\/.*|etsy\.com\/.*|www\.etsy\.com\/.*|kit\.com|soundcloud\.com\/.*|soundcloud\.com\/.*\/.*|soundcloud\.com\/.*\/sets\/.*|soundcloud\.com\/groups\/.*|open\.spotify\.com\/.*|play\.spotify\.com\/.*|www\.last\.fm\/music\/.*|www\.last\.fm\/music\/+videos\/.*|www\.last\.fm\/music\/+images\/.*|www\.last\.fm\/music\/.*\/_\/.*|www\.last\.fm\/music\/.*\/.*|www\.simplecast\.com\/s\/.*|www\.changelog\.com\/.*|www\.megafono\.io\/.*|play\.radiopublic\.com\/.*|www\.rdio\.com\/#\/artist\/.*\/album\/.*|www\.rdio\.com\/artist\/.*\/album\/.*|.*\.bandcamp\.com\/|.*\.bandcamp\.com\/track\/.*|.*\.bandcamp\.com\/album\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/.*\/.*\/.*\/.*\/.*\/.*\/.*|www\.npr\.org\/templates\/story\/story\.php.*|audioboom\.com\/posts\/.*|bop\.fm\/s\/.*\/.*|bop\.fm\/p\/.*|bop\.fm\/a\/.*|clyp\.it\/.*|sfx\.io\/.*|anchor\.fm\/.*|bumpers\.fm\/e\/.*|buzzsprout\.com\/.*|.*\.buzzsprout\.com\/.*|60db\.co\/story\/.*|allihoopa\.com\/s\/.*|vizamp\.com\/player\/.*|www\.vizamp\.com\/player\/.*|art19\.com\/shows\/.*\/episodes\/.*|tapewrite\.com\/.*|player\.megaphone\.fm\/.*|cms\.megaphone\.fm\/.*|play\.soundsgood\.co\/.*|.*\.sparemin\.com\/myrecording|.*\.sparemin\.com\/recording-.*)))/i) || url.match(/twitter\.com/i);
};
}, {}];
window.modules["217"] = [function(require,module,exports){'use strict'; // module.exports.render = (uri, data, locals) => {
//     console.log(`womp`, uri, data, locals);
//     return data;
// }
// module.exports.save = (uri, data, locals) => {
//   console.log(`uri`, uri, data);
//   return data;
// }
// module.exports.save = (uri, data, locals) => {
//   console.log(`uri`, uri, data);
//   return data;
// }
}, {}];
window.modules["225"] = [function(require,module,exports){/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */;

var utils = require(220);
var v = require(219);

/**
 * A Find Place request takes a text input, and returns a place.
 * The text input can be any kind of Places data, for example,
 * a name, address, or phone number.
 *
 * @memberof! GoogleMapsClient
 * @name GoogleMapsClient.findPlace
 * @function
 * @param {Object} query
 * @param {string} query.input
 * @param {string} query.inputtype
 * @param {string} [query.language]
 * @param {Array<string>} [query.fields]
 * @param {ResponseCallback} callback Callback function for handling the result
 * @return {RequestHandle}
 */
exports.findPlace = {
  url: 'https://maps.googleapis.com/maps/api/place/findplacefromtext/json',
  validator: v.compose([
    v.object({
      input: v.string,
      inputtype: v.oneOf(['textquery', 'phonenumber']),
      language: v.optional(v.string),
      fields: v.optional(utils.arrayOf(v.oneOf([
        'formatted_address', 'geometry', 'icon', 'id', 'name',
        'permanently_closed', 'photos', 'place_id', 'scope', 'types',
        'vicinity', 'opening_hours', 'price_level', 'rating'
      ]), ',')),
      locationbias: v.optional(v.string),
      retryOptions: v.optional(utils.retryOptions),
      timeout: v.optional(v.number)
    }),
    function(query) {
      if (!query.locationbias || query.locationbias == 'ipbias') {
        return query;
      }
      var isLatLng = function(latLng) {
        latLng = latLng.split(',');
        return latLng.length == 2 && !isNaN(latLng[0]) && !isNaN(latLng[1]);
      };
      var parts = query.locationbias.split(':');
      switch (parts[0]) {
        case 'point':
          if (isLatLng(parts[parts.length - 1])) {
            return query;
          }
          break;
        case 'circle':
          parts = parts[parts.length - 1].split('@');
          if (!isNaN(parts[0]) && isLatLng(parts[parts.length - 1])) {
            return query;
          }
          break;
        case 'rectangle':
          parts = parts[parts.length - 1].split('|');
          if (parts.length == 2 && isLatLng(parts[0]) && isLatLng(parts[1])) {
            return query;
          }
          break;
      }
      throw new v.InvalidValueError('invalid locationbias');
    }
  ])
};

/**
 * Makes a places request.
 *
 * @memberof! GoogleMapsClient
 * @name GoogleMapsClient.places
 * @function
 * @param {Object} query
 * @param {string} query.query
 * @param {string} [query.language]
 * @param {LatLng} [query.location]
 * @param {number} [query.radius]
 * @param {number} [query.minprice]
 * @param {number} [query.maxprice]
 * @param {boolean} [query.opennow]
 * @param {string} [query.type]
 * @param {string} [query.pagetoken]
 * @param {string} [query.region]
 * @param {ResponseCallback} callback Callback function for handling the result
 * @return {RequestHandle}
 */
exports.places = {
  url: 'https://maps.googleapis.com/maps/api/place/textsearch/json',
  validator: v.object({
    query: v.optional(v.string),
    language: v.optional(v.string),
    location: v.optional(utils.latLng),
    radius: v.optional(v.number),
    minprice: v.optional(v.number),
    maxprice: v.optional(v.number),
    opennow: v.optional(v.boolean),
    type: v.optional(v.string),
    pagetoken: v.optional(v.string),
    retryOptions: v.optional(utils.retryOptions),
    timeout: v.optional(v.number),
    region: v.optional(v.string)
  })
};

/**
 * Makes a nearby places request.
 *
 * @memberof! GoogleMapsClient
 * @name GoogleMapsClient.placesNearby
 * @function
 * @param {Object} query
 * @param {LatLng} query.location
 * @param {string} [query.language]
 * @param {number} [query.radius]
 * @param {string} [query.keyword]
 * @param {number} [query.minprice]
 * @param {number} [query.maxprice]
 * @param {string} [query.name]
 * @param {boolean} [query.opennow]
 * @param {string} [query.rankby] Either 'prominence' or 'distance'
 * @param {string} [query.type]
 * @param {string} [query.pagetoken]
 * @param {ResponseCallback} callback Callback function for handling the result
 * @return {RequestHandle}
 */
exports.placesNearby = {
  url: 'https://maps.googleapis.com/maps/api/place/nearbysearch/json',
  validator: v.compose([
    v.mutuallyExclusivePropertiesRequired(['location', 'pagetoken']),
    v.object({
      location: v.optional(utils.latLng),
      language: v.optional(v.string),
      radius: v.optional(v.number),
      keyword: v.optional(v.string),
      minprice: v.optional(v.number),
      maxprice: v.optional(v.number),
      name: v.optional(v.string),
      opennow: v.optional(v.boolean),
      rankby: v.optional(v.oneOf(['prominence', 'distance'])),
      type: v.optional(v.string),
      pagetoken: v.optional(v.string),
      retryOptions: v.optional(utils.retryOptions),
      timeout: v.optional(v.number)
    })
  ])
};

/**
 * Makes a places radar search request.
 *
 * @memberof! GoogleMapsClient
 * @name GoogleMapsClient.placesRadar
 * @function
 * @param {Object} query
 * @param {LatLng} query.location
 * @param {number} query.radius
 * @param {string} [query.language]
 * @param {string} [query.keyword]
 * @param {number} [query.minprice]
 * @param {number} [query.maxprice]
 * @param {string} [query.name]
 * @param {boolean} [query.opennow]
 * @param {string} [query.type]
 * @param {ResponseCallback} callback Callback function for handling the result
 * @return {RequestHandle}
 */
exports.placesRadar = {
  url: 'https://maps.googleapis.com/maps/api/place/radarsearch/json',
  validator: v.object({
    location: utils.latLng,
    radius: v.number,
    language: v.optional(v.string),
    keyword: v.optional(v.string),
    minprice: v.optional(v.number),
    maxprice: v.optional(v.number),
    name: v.optional(v.string),
    opennow: v.optional(v.boolean),
    type: v.optional(v.string),
    retryOptions: v.optional(utils.retryOptions),
    timeout: v.optional(v.number)
  })
};

/**
 * Makes a place detail request.
 *
 * @memberof! GoogleMapsClient
 * @name GoogleMapsClient.place
 * @function
 * @param {Object} query
 * @param {string} query.placeid
 * @param {string} [query.sessiontoken]
 * @param {string} [query.language]
 * @param {Array<string>} [query.fields]
 * @param {ResponseCallback} callback Callback function for handling the result
 * @return {RequestHandle}
 */
exports.place = {
  url: 'https://maps.googleapis.com/maps/api/place/details/json',
  validator: v.object({
    placeid: v.string,
    sessiontoken: v.optional(v.string),
    language: v.optional(v.string),
    fields: v.optional(utils.arrayOf(v.oneOf([
      'address_component', 'adr_address', 'alt_id', 'formatted_address',
      'geometry', 'icon', 'id', 'name', 'permanently_closed', 'photo',
      'place_id', 'scope', 'type', 'url', 'utc_offset', 'vicinity',
      'formatted_phone_number', 'international_phone_number', 'opening_hours',
      'website', 'price_level', 'rating', 'review',
    ]), ',')),
    retryOptions: v.optional(utils.retryOptions),
    timeout: v.optional(v.number)
  })
};

/**
 * Makes a place photos request.
 *
 * @memberof! GoogleMapsClient
 * @name GoogleMapsClient.placesPhoto
 * @function
 * @param {Object} query
 * @param {string} query.photoreference
 * @param {number} [query.maxwidth]
 * @param {number} [query.maxheight]
 * @param {ResponseCallback} callback Callback function for handling the result
 * @return {RequestHandle}
 */
exports.placesPhoto = {
  url: 'https://maps.googleapis.com/maps/api/place/photo',
  validator: v.object({
    photoreference: v.string,
    maxwidth: v.optional(v.number),
    maxheight: v.optional(v.number),
    retryOptions: v.optional(utils.retryOptions),
    timeout: v.optional(v.number)
  })
};

/**
 * Makes a places autocomplete request.
 *
 * @memberof! GoogleMapsClient
 * @name GoogleMapsClient.placesAutoComplete
 * @function
 * @param {Object} query
 * @param {string} query.input
 * @param {string} query.sessiontoken
 * @param {number} [query.offset]
 * @param {LatLng} [query.location]
 * @param {string} [query.language]
 * @param {number} [query.radius]
 * @param {string} [query.types]
 * @param {Array<string>} [query.components]
 * @param {boolean} [query.strictbounds]
 * @param {ResponseCallback} callback Callback function for handling the result
 * @return {RequestHandle}
 */
exports.placesAutoComplete = {
  url: 'https://maps.googleapis.com/maps/api/place/autocomplete/json',
  validator: v.object({
    input: v.string,
    sessiontoken: v.string,
    offset: v.optional(v.number),
    location: v.optional(utils.latLng),
    language: v.optional(v.string),
    radius: v.optional(v.number),
    types: v.optional(v.oneOf(['geocode', 'address', 'establishment', '(regions)', '(cities)'])),
    components: v.optional(utils.pipedKeyValues),
    strictbounds: v.optional(v.boolean),
    retryOptions: v.optional(utils.retryOptions),
    timeout: v.optional(v.number)
  })
};


/**
 * Makes a places query autocomplete request.
 *
 * @memberof! GoogleMapsClient
 * @name GoogleMapsClient.placesQueryAutoComplete
 * @function
 * @param {Object} query
 * @param {string} query.input
 * @param {number} [query.offset]
 * @param {LatLng} [query.location]
 * @param {string} [query.language]
 * @param {number} [query.radius]
 * @param {ResponseCallback} callback Callback function for handling the result
 * @return {RequestHandle}
 */
exports.placesQueryAutoComplete = {
  url: 'https://maps.googleapis.com/maps/api/place/queryautocomplete/json',
  validator: v.object({
    input: v.string,
    offset: v.optional(v.number),
    location: v.optional(utils.latLng),
    language: v.optional(v.string),
    radius: v.optional(v.number),
    retryOptions: v.optional(utils.retryOptions),
    timeout: v.optional(v.number)
  })
};
}, {"219":219,"220":220}];
window.modules["231"] = [function(require,module,exports){(function (process,Buffer){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var url = require(235);
var Task = require(233);

exports.inject = function(options) {

  var key = options.key || window.process.env.GOOGLE_MAPS_API_KEY;
  var channel = options.channel;
  var clientId = options.clientId || window.process.env.GOOGLE_MAPS_API_CLIENT_ID;
  var clientSecret = options.clientSecret || window.process.env.GOOGLE_MAPS_API_CLIENT_SECRET;

  var rate = options.rate || {};
  var rateLimit = rate.limit || 50;  // 50 requests per ratePeriod.
  var ratePeriod = rate.period || 1000;  // 1 second.

  var makeUrlRequest = options.makeUrlRequest || require(239);
  var mySetTimeout = options.setTimeout || setTimeout;
  var myClearTimeout = options.clearTimeout || clearTimeout;
  var getTime = options.getTime || function() {return new Date().getTime();};
  var wait = require(236).inject(mySetTimeout, myClearTimeout);
  var attempt = require(232).inject(wait).attempt;
  var ThrottledQueue = require(237).inject(wait, getTime);
  var requestQueue = ThrottledQueue.create(rateLimit, ratePeriod);

  /**
   * Makes an API request using the injected makeUrlRequest.
   *
   * Inserts the API key (or client ID and signature) into the query
   * parameters. Retries requests when the status code requires it.
   * Parses the response body as JSON.
   *
   * The callback is given either an error or a response. The response
   * is an object with the following entries:
   * {
   *   status: number,
   *   body: string,
   *   json: Object
   * }
   *
   * @param {string} path
   * @param {Object} query This function mutates the query object.
   * @param {Function} callback
   * @return {{
   *   cancel: function(),
   *   finally: function(function()),
   *   asPromise: function(): Promise
   * }}
   */
  return function(path, query, callback) {

    callback = callback || function() {};

    var retryOptions = query.retryOptions || options.retryOptions || {};
    delete query.retryOptions;

    var timeout = query.timeout || options.timeout || 60 * 1000;
    delete query.timeout;

    var useClientId = query.supportsClientId && clientId && clientSecret;
    delete query.supportsClientId;

    var queryOptions = query.options || {};
    delete query.options;

    var isPost = queryOptions.method === 'POST'
    var requestUrl = formatRequestUrl(path, isPost ? {} : query, useClientId);

    if (isPost) {
      queryOptions.body = query;
    }

    // Determines whether a response indicates a retriable error.
    var canRetry = queryOptions.canRetry || function(response) {
      return (
        response == null
        || response.status === 500
        || response.status === 503
        || response.status === 504
        || (response.json && (
            response.json.status === 'OVER_QUERY_LIMIT' ||
            response.json.status === 'RESOURCE_EXHAUSTED')));
    };
    delete queryOptions.canRetry;

    // Determines whether a response indicates success.
    var isSuccessful = queryOptions.isSuccessful || function(response) {
      return response.status === 200 && (
                response.json == undefined ||
                response.json.status === undefined ||
                response.json.status === 'OK' ||
                response.json.status === 'ZERO_RESULTS');
    };
    delete queryOptions.isSuccessful;

    function rateLimitedGet() {
      return requestQueue.add(function() {
        return Task.start(function(resolve, reject) {
          return makeUrlRequest(requestUrl, resolve, reject, queryOptions);
        });
      });
    }

    var timeoutTask = wait(timeout).thenDo(function() {
      throw 'timeout';
    });
    var requestTask = attempt({
      'do': rateLimitedGet,
      until: function(response) { return !canRetry(response); },
      interval: retryOptions.interval,
      increment: retryOptions.increment,
      jitter: retryOptions.jitter
    });

    var task =
        Task.race([timeoutTask, requestTask])
        .thenDo(function(response) {
          // We add the request url and the original query to the response
          // to be able to use them when debugging errors.
          response.requestUrl = requestUrl;
          response.query = query;

          if (isSuccessful(response)) {
            return Task.withValue(response);
          } else {
            return Task.withError(response);
          }
        })
        .thenDo(
            function(response) { callback(null, response); },
            function(err) { callback(err); });

    if (options.Promise) {
      var originalCallback = callback;
      var promise = new options.Promise(function(resolve, reject) {
        callback = function(err, result) {
          if (err != null) {
            reject(err);
          } else {
            resolve(result);
          }
          originalCallback(err, result);
        };
      });
      task.asPromise = function() { return promise; };
    }

    delete task.thenDo;
    return task;
  };

  /**
   * Adds auth information to the query, and formats it into a URL.
   * @param {string} path
   * @param {Object} query
   * @param {boolean} useClientId
   * @return {string} The formatted URL.
   */
  function formatRequestUrl(path, query, useClientId) {
    if (channel) {
      query.channel = channel;
    }
    if (useClientId) {
      query.client = clientId;
    } else if (key && key.indexOf('AIza') == 0) {
      query.key = key;
    } else {
      throw 'Missing either a valid API key, or a client ID and secret';
    }

    var requestUrl = url.format({pathname: path, query: query});

    // When using client ID, generate and append the signature param.
    if (useClientId) {
      var secret = new Buffer(clientSecret, 'base64');
      var payload = url.parse(requestUrl).path;
      var signature = computeSignature(secret, payload);
      requestUrl += '&signature=' + encodeURIComponent(signature);
    }

    return requestUrl;
  }

  /**
   * @param {string} secret
   * @param {string} payload
   * @return {string}
   */
  function computeSignature(secret, payload) {
    var signature =
        new Buffer(
            require(240)
            .createHmac('sha1', secret)
            .update(payload)
            .digest('base64'))
        .toString()
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    while (signature.length % 4) {
      signature += '=';
    }
    return signature;
  }

};

}).call(this,require(22),require(238).Buffer)}, {"22":22,"232":232,"233":233,"235":235,"236":236,"237":237,"238":238,"239":239,"240":240}];
window.modules["239"] = [function(require,module,exports){(function (Buffer){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var https = require(242);
var parse = require(235).parse;
var version = require(241);


// add keep-alive header to speed up request
var agent = new https.Agent({ keepAlive: true });


/**
 * Makes a secure HTTP GET request for the given URL.
 *
 * Calls the callback with two parameters (err, response). If there was an
 * error, response should be null. If there was no error, err should be null,
 * and response should be an object with these properties
 * {
 *   status: number,
 *   headers: Object,
 *   json: Object
 * }
 *
 * Returns a function that cancels the request.
 *
 * @param {string} url
 * @param {function(ClientResponse)} onSuccess
 * @param {function(?)} onError
 * @param {Object} options
 * @return {function()}
 */
module.exports = function makeUrlRequest(url, onSuccess, onError, options) {

  var requestOptions = parse(url);
  var body;

  // Allow each API to provide some of the request options such as the
  // HTTP method, headers, etc.
  if (options) {
    for (var k in options) {
      if (k === 'body') {
        body = options[k];
      } else {
        requestOptions[k] = options[k];
      }
    }
  }

  requestOptions.headers = requestOptions.headers || {};
  requestOptions.headers['User-Agent'] = 'GoogleGeoApiClientJS/' + version;

  var request = https.request(requestOptions, function(response) {

    response.on('error', function(error) {
      onError(error);
    });

    if (response.statusCode === 302) {
      // Handle redirect.
      var url = response.headers['location'];
      makeUrlRequest(url, onSuccess, onError, options);
    } else if (response.headers['content-type'] == 'application/json; charset=UTF-8') {
      // Handle JSON.
      var data = [];
      response.on('data', function(chunk) {
        data.push(chunk);
      });
      response.on('end', function() {
        var json;
        try {
          json = JSON.parse(Buffer.concat(data).toString());
        } catch (error) {
          onError(error);
          return;
        }
        onSuccess({
          status: response.statusCode,
          headers: response.headers,
          json: json
        })
      });
    } else {
      // Fallback is for binary data, namely places photo download,
      // so just provide the response stream. Also provide the same
      // consistent name for status checking as per JSON responses.
      response.status = response.statusCode;
      onSuccess(response);
    }

  }).on('error', function(error) {
    onError(error);
  });

  if (body) {
    request.write(JSON.stringify(body));
  }

  request.end();

  return function cancel() { request.abort(); };
};

}).call(this,require(238).Buffer)}, {"235":235,"238":238,"241":241,"242":242}];
window.modules["262"] = [function(require,module,exports){var Reporter = require(257).Reporter;
var EncoderBuffer = require(257).EncoderBuffer;
var DecoderBuffer = require(257).DecoderBuffer;
var assert = require(263);

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};
}, {"257":257,"263":263}];
window.modules["266"] = [function(require,module,exports){var inherits = require(259);
var Buffer = require(238).Buffer;

var DERDecoder = require(265);

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};
}, {"238":238,"259":259,"265":265}];
window.modules["268"] = [function(require,module,exports){var inherits = require(259);

var DEREncoder = require(267);

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};
}, {"259":259,"267":267}];
window.modules["294"] = [function(require,module,exports){(function (Buffer){
var xor = require(280)

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require(238).Buffer)}, {"238":238,"280":280}];
window.modules["296"] = [function(require,module,exports){exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}
}, {}];
window.modules["313"] = [function(require,module,exports){(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})}, {}];
window.modules["325"] = [function(require,module,exports){'use strict';

var expirationYear = require(318);
var isArray = require(326);

function parseDate(value) {
  var month, len, year, yearValid;

  if (/\//.test(value)) {
    value = value.split(/\s*\/\s*/g);
  } else if (/\s/.test(value)) {
    value = value.split(/ +/g);
  }

  if (isArray(value)) {
    return {
      month: value[0],
      year: value.slice(1).join()
    };
  }

  len = value[0] === '0' || value.length > 5 ? 2 : 1;

  if (value[0] === '1') {
    year = value.substr(1);
    yearValid = expirationYear(year);
    if (!yearValid.isPotentiallyValid) {
      len = 2;
    }
  }

  month = value.substr(0, len);

  return {
    month: month,
    year: value.substr(month.length)
  };
}

module.exports = parseDate;
}, {"318":318,"326":326}];
window.modules["320"] = [function(require,module,exports){'use strict';

var DEFAULT_MIN_POSTAL_CODE_LENGTH = 3;

function verification(isValid, isPotentiallyValid) {
  return {isValid: isValid, isPotentiallyValid: isPotentiallyValid};
}

function postalCode(value, options) {
  var minLength;

  options = options || {};

  minLength = options.minLength || DEFAULT_MIN_POSTAL_CODE_LENGTH;

  if (typeof value !== 'string') {
    return verification(false, false);
  } else if (value.length < minLength) {
    return verification(false, true);
  }

  return verification(true, true);
}

module.exports = postalCode;
}, {}];
window.modules["368"] = [function(require,module,exports){var MD5 = require(366)

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}
}, {"366":366}];
window.modules["387"] = [function(require,module,exports){'use strict';

var SyntaxParseError = require(388).SyntaxParseError;

var TAB = 9;
var N = 10;
var F = 12;
var R = 13;
var SPACE = 32;
var EXCLAMATIONMARK = 33;    // !
var NUMBERSIGN = 35;         // #
var PERCENTSIGN = 37;        // %
var AMPERSAND = 38;          // &
var APOSTROPHE = 39;         // '
var LEFTPARENTHESIS = 40;    // (
var RIGHTPARENTHESIS = 41;   // )
var ASTERISK = 42;           // *
var PLUSSIGN = 43;           // +
var COMMA = 44;              // ,
var SOLIDUS = 47;            // /
var LESSTHANSIGN = 60;       // <
var GREATERTHANSIGN = 62;    // >
var QUESTIONMARK = 63;       // ?
var LEFTSQUAREBRACKET = 91;  // [
var RIGHTSQUAREBRACKET = 93; // ]
var LEFTCURLYBRACKET = 123;  // {
var VERTICALLINE = 124;      // |
var RIGHTCURLYBRACKET = 125; // }
var COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
};
var MULTIPLIER_DEFAULT = {
    comma: false,
    min: 1,
    max: 1
};
var MULTIPLIER_ZERO_OR_MORE = {
    comma: false,
    min: 0,
    max: 0
};
var MULTIPLIER_ONE_OR_MORE = {
    comma: false,
    min: 1,
    max: 0
};
var MULTIPLIER_ONE_OR_MORE_COMMA_SEPARATED = {
    comma: true,
    min: 1,
    max: 0
};
var MULTIPLIER_ZERO_OR_ONE = {
    comma: false,
    min: 0,
    max: 1
};
var NAME_CHAR = (function() {
    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
    for (var i = 0; i < 128; i++) {
        array[i] = /[a-zA-Z0-9\-]/.test(String.fromCharCode(i)) ? 1 : 0;
    }
    return array;
})();

var Tokenizer = function(str) {
    this.str = str;
    this.pos = 0;
};
Tokenizer.prototype = {
    charCode: function() {
        return this.pos < this.str.length ? this.str.charCodeAt(this.pos) : 0;
    },
    nextCharCode: function() {
        return this.pos + 1 < this.str.length ? this.str.charCodeAt(this.pos + 1) : 0;
    },

    substringToPos: function(end) {
        return this.str.substring(this.pos, this.pos = end);
    },
    eat: function(code) {
        if (this.charCode() !== code) {
            error(this, this.pos, 'Expect `' + String.fromCharCode(code) + '`');
        }

        this.pos++;
    }
};

function scanSpaces(tokenizer) {
    var end = tokenizer.pos + 1;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
            break;
        }
    }

    return tokenizer.substringToPos(end);
}

function scanWord(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        error(tokenizer, tokenizer.pos, 'Expect a keyword');
    }

    return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
    var end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        error(tokenizer, tokenizer.pos, 'Expect a number');
    }

    return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
        error(tokenizer, tokenizer.str.length, 'Expect a quote');
    }

    return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer, comma) {
    var min = null;
    var max = null;

    tokenizer.eat(LEFTCURLYBRACKET);

    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
        }
    } else {
        max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET);

    return {
        comma: comma,
        min: Number(min),
        max: max ? Number(max) : 0
    };
}

function readMultiplier(tokenizer) {
    switch (tokenizer.charCode()) {
        case ASTERISK:
            tokenizer.pos++;
            return MULTIPLIER_ZERO_OR_MORE;

        case PLUSSIGN:
            tokenizer.pos++;
            return MULTIPLIER_ONE_OR_MORE;

        case QUESTIONMARK:
            tokenizer.pos++;
            return MULTIPLIER_ZERO_OR_ONE;

        case NUMBERSIGN:
            tokenizer.pos++;

            if (tokenizer.charCode() !== LEFTCURLYBRACKET) {
                return MULTIPLIER_ONE_OR_MORE_COMMA_SEPARATED;
            }

            return readMultiplierRange(tokenizer, true);

        case LEFTCURLYBRACKET:
            return readMultiplierRange(tokenizer, false);
    }

    return MULTIPLIER_DEFAULT;
}

function readProperty(tokenizer) {
    var name;

    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE);

    name = scanWord(tokenizer);

    tokenizer.eat(APOSTROPHE);
    tokenizer.eat(GREATERTHANSIGN);

    return {
        type: 'Property',
        name: name,
        multiplier: readMultiplier(tokenizer)
    };
}

function readType(tokenizer) {
    var name;

    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS &&
        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
        tokenizer.pos += 2;
        name += '()';
    }

    tokenizer.eat(GREATERTHANSIGN);

    return {
        type: 'Type',
        name: name,
        multiplier: readMultiplier(tokenizer)
    };
}

function readKeywordOrFunction(tokenizer) {
    var sequence = null;
    var name;

    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS) {
        tokenizer.pos++;
        sequence = readSequence(tokenizer);
        tokenizer.eat(RIGHTPARENTHESIS);

        return {
            type: 'Function',
            name: name,
            sequence: sequence,
            multiplier: readMultiplier(tokenizer)
        };
    }

    return {
        type: 'Keyword',
        name: name,
        multiplier: readMultiplier(tokenizer)
    };
}

function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
        return {
            type: 'Sequence',
            terms: terms,
            combinator: combinator
        };
    }

    combinators = Object.keys(combinators).sort(function(a, b) {
        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
    });

    while (combinators.length > 0) {
        var combinator = combinators.shift();
        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
            var term = terms[i];
            if (term.type === 'Combinator') {
                if (term.value === combinator) {
                    if (subgroupStart === -1) {
                        subgroupStart = i - 1;
                    }
                    terms.splice(i, 1);
                    i--;
                } else {
                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
                        terms.splice(
                            subgroupStart,
                            i - subgroupStart,
                            createGroup(terms.slice(subgroupStart, i), combinator)
                        );
                        i = subgroupStart + 1;
                    }
                    subgroupStart = -1;
                }
            }
        }

        if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
                subgroupStart,
                i - subgroupStart,
                createGroup(terms.slice(subgroupStart, i), combinator)
            );
        }
    }

    return combinator;
}

function readSequence(tokenizer) {
    var terms = [];
    var combinators = {};
    var token;
    var prevToken = null;
    var prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
        if (token.type !== 'Spaces') {
            if (token.type === 'Combinator') {
                // check for combinator in group beginning and double combinator sequence
                if (prevToken === null || prevToken.type === 'Combinator') {
                    error(tokenizer, prevTokenPos, 'Unexpected combinator');
                }

                combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
                combinators[' '] = true;  // a b
                terms.push({
                    type: 'Combinator',
                    value: ' '
                });
            }

            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
        }
    }

    // check for combinator in group ending
    if (prevToken !== null && prevToken.type === 'Combinator') {
        error(tokenizer, tokenizer.pos - prevTokenPos, 'Unexpected combinator');
    }

    return {
        type: 'Sequence',
        terms: terms,
        combinator: regroupTerms(terms, combinators) || ' '
    };
}

function readGroup(tokenizer) {
    var sequence;
    var nonEmpty = false;
    var multiplier;

    tokenizer.eat(LEFTSQUAREBRACKET);
    sequence = readSequence(tokenizer);

    tokenizer.eat(RIGHTSQUAREBRACKET);
    multiplier = readMultiplier(tokenizer);

    if (tokenizer.charCode() === EXCLAMATIONMARK) {
        tokenizer.pos++;
        nonEmpty = true;
    }

    return {
        type: 'Group',
        terms: sequence.terms,
        combinator: sequence.combinator,
        nonEmpty: nonEmpty,
        multiplier: multiplier
    };
}

function peek(tokenizer) {
    var code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
        case LEFTSQUAREBRACKET:
            return readGroup(tokenizer);

        case LESSTHANSIGN:
            if (tokenizer.nextCharCode() === APOSTROPHE) {
                return readProperty(tokenizer);
            } else {
                return readType(tokenizer);
            }

        case VERTICALLINE:
            return {
                type: 'Combinator',
                value: tokenizer.substringToPos(tokenizer.nextCharCode() === VERTICALLINE ? tokenizer.pos + 2 : tokenizer.pos + 1)
            };

        case AMPERSAND:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND);
            return {
                type: 'Combinator',
                value: '&&'
            };

        case COMMA:
            tokenizer.pos++;
            return {
                type: 'Comma',
                value: ','
            };

        case SOLIDUS:
            tokenizer.pos++;
            return {
                type: 'Slash',
                value: '/'
            };

        case PERCENTSIGN:  // looks like exception, needs for attr()'s <type-or-unit>
            tokenizer.pos++;
            return {
                type: 'Percent',
                value: '%'
            };

        case LEFTPARENTHESIS:
            tokenizer.pos++;
            var sequence = readSequence(tokenizer);
            tokenizer.eat(RIGHTPARENTHESIS);

            return {
                type: 'Parentheses',
                sequence: sequence
            };

        case APOSTROPHE:
            return {
                type: 'String',
                value: scanString(tokenizer)
            };

        case SPACE:
        case TAB:
        case N:
        case R:
        case F:
            return {
                type: 'Spaces',
                value: scanSpaces(tokenizer)
            };
    }
}

function error(tokenizer, pos, msg) {
    throw new SyntaxParseError(msg || 'Unexpected input', tokenizer.str, pos);
}

function parse(str) {
    var tokenizer = new Tokenizer(str);
    var result = readSequence(tokenizer);

    if (tokenizer.pos !== str.length) {
        error(tokenizer, tokenizer.pos);
    }

    // reduce redundant sequences with single term
    // if (result.terms.length === 1) {
    //     result = result.terms[0];
    // }

    return result;
}

// warm up parse to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
parse('[a&&<b>#|<\'c\'>*||e(){2,} f{2} /,(% g#{1,2})]!');

module.exports = parse;
}, {"388":388}];
window.modules["383"] = [function(require,module,exports){'use strict';

var names = require(381);
var MULTIPLIER_DEFAULT = {
    comma: false,
    min: 1,
    max: 1,
    value: ''
};

function skipSpaces(node) {
    while (node !== null && (node.data.type === 'WhiteSpace' || node.data.type === 'Comment')) {
        node = node.next;
    }

    return node;
}

module.exports = function match(syntax, syntaxNode, node) {
    var result = [];
    var multiplier = syntaxNode.multiplier || MULTIPLIER_DEFAULT;
    var min = multiplier.min;
    var max = multiplier.max === 0 ? Infinity : multiplier.max;
    var lastCommaTermCount;
    var lastComma;
    var matchCount = 0;
    var lastNode = null;
    var badNode = null;

    mismatch:
    while (matchCount < max) {
        node = skipSpaces(node);
        switch (syntaxNode.type) {
            case 'Sequence':
            case 'Group':
                next:
                switch (syntaxNode.combinator) {
                    case '|':
                        for (var i = 0; i < syntaxNode.terms.length; i++) {
                            var term = syntaxNode.terms[i];
                            var res = match(syntax, term, node);

                            if (res.match) {
                                result.push(res.match);
                                node = res.next;
                                break next;  // continue matching
                            } else if (res.badNode) {
                                badNode = res.badNode;
                                break mismatch;
                            }
                        }
                        break mismatch; // nothing found -> stop matching

                    case ' ':
                        var beforeMatchNode = node;
                        var lastMatchedTerm = null;
                        var hasTailMatch = false;
                        var commaMissed = false;

                        for (var i = 0; i < syntaxNode.terms.length; i++) {
                            var term = syntaxNode.terms[i];
                            var res = match(syntax, term, node);

                            if (res.match) {
                                if (term.type === 'Comma' && i !== 0 && !hasTailMatch) {
                                    // recover cursor to state before last match and stop matching
                                    lastNode = node && node.data;
                                    node = beforeMatchNode;
                                    break mismatch;
                                }

                                // non-empty match
                                if (res.match.match.length) {
                                    // match should be preceded by a comma
                                    if (commaMissed) {
                                        lastNode = node && node.data;
                                        node = beforeMatchNode;
                                        break mismatch;
                                    }

                                    hasTailMatch = term.type !== 'Comma';
                                    lastMatchedTerm = term;
                                }

                                result.push(res.match);
                                node = skipSpaces(res.next);
                            } else if (res.badNode) {
                                badNode = res.badNode;
                                break mismatch;
                            } else {
                                // it's ok when comma doesn't match when no matches yet
                                // but only if comma is not first or last term
                                if (term.type === 'Comma' && i !== 0 && i !== syntaxNode.terms.length - 1) {
                                    if (hasTailMatch) {
                                        commaMissed = true;
                                    }
                                    continue;
                                }

                                // recover cursor to state before last match and stop matching
                                lastNode = res.lastNode || (node && node.data);
                                node = beforeMatchNode;
                                break mismatch;
                            }
                        }

                        // don't allow empty match when [ ]!
                        if (!lastMatchedTerm && syntaxNode.nonEmpty) {
                            // empty match but shouldn't
                            // recover cursor to state before last match and stop matching
                            lastNode = node && node.data;
                            node = beforeMatchNode;
                            break mismatch;
                        }

                        // don't allow comma at the end but only if last term isn't a comma
                        if (lastMatchedTerm && lastMatchedTerm.type === 'Comma' && term.type !== 'Comma') {
                            lastNode = node && node.data;
                            node = beforeMatchNode;
                            break mismatch;
                        }

                        break;

                    case '&&':
                        var beforeMatchNode = node;
                        var lastMatchedTerm = null;
                        var terms = syntaxNode.terms.slice();

                        while (terms.length) {
                            var wasMatch = false;
                            var emptyMatched = 0;

                            for (var i = 0; i < terms.length; i++) {
                                var term = terms[i];
                                var res = match(syntax, term, node);

                                if (res.match) {
                                    // non-empty match
                                    if (res.match.match.length) {
                                        lastMatchedTerm = term;
                                    } else {
                                        emptyMatched++;
                                        continue;
                                    }

                                    wasMatch = true;
                                    terms.splice(i--, 1);
                                    result.push(res.match);
                                    node = skipSpaces(res.next);
                                    break;
                                } else if (res.badNode) {
                                    badNode = res.badNode;
                                    break mismatch;
                                }
                            }

                            if (!wasMatch) {
                                // terms left, but they all are optional
                                if (emptyMatched === terms.length) {
                                    break;
                                }

                                // not ok
                                lastNode = node && node.data;
                                node = beforeMatchNode;
                                break mismatch;
                            }
                        }

                        if (!lastMatchedTerm && syntaxNode.nonEmpty) { // don't allow empty match when [ ]!
                            // empty match but shouldn't
                            // recover cursor to state before last match and stop matching
                            lastNode = node && node.data;
                            node = beforeMatchNode;
                            break mismatch;
                        }

                        break;

                    case '||':
                        var beforeMatchNode = node;
                        var lastMatchedTerm = null;
                        var terms = syntaxNode.terms.slice();

                        while (terms.length) {
                            var wasMatch = false;
                            var emptyMatched = 0;

                            for (var i = 0; i < terms.length; i++) {
                                var term = terms[i];
                                var res = match(syntax, term, node);
                                if (res.match) {
                                    // non-empty match
                                    if (res.match.match.length) {
                                        lastMatchedTerm = term;
                                    } else {
                                        emptyMatched++;
                                        continue;
                                    }

                                    wasMatch = true;
                                    terms.splice(i--, 1);
                                    result.push(res.match);
                                    node = skipSpaces(res.next);
                                    break;
                                } else if (res.badNode) {
                                    badNode = res.badNode;
                                    break mismatch;
                                }
                            }

                            if (!wasMatch) {
                                break;
                            }
                        }

                        // don't allow empty match
                        if (!lastMatchedTerm && (emptyMatched !== terms.length || syntaxNode.nonEmpty)) {
                            // empty match but shouldn't
                            // recover cursor to state before last match and stop matching
                            lastNode = node && node.data;
                            node = beforeMatchNode;
                            break mismatch;
                        }

                        break;
                }

                break;

            case 'Function':
                // expect a function node
                if (!node || node.data.type !== 'Function') {
                    break mismatch;
                }

                var keyword = names.keyword(node.data.name);
                var name = syntaxNode.name.toLowerCase();

                // check function name with vendor consideration
                if (name !== keyword.vendor + keyword.name) {
                    break mismatch;
                }

                var res = match(syntax, syntaxNode.sequence, node.data.children.head);
                if (!res.match || res.next) {
                    badNode = res.badNode || res.lastNode || (res.next ? res.next.data : null) || node.data;
                    break mismatch;
                }

                result.push(res.match);
                // Use node.next instead of res.next here since syntax is matching
                // for internal list and it's should be completelly matched (res.next is null at this point).
                // Therefore function is matched and we going to next node
                node = node.next;
                break;

            case 'Parentheses':
                if (!node || node.data.type !== 'Parentheses') {
                    break mismatch;
                }

                var res = match(syntax, syntaxNode.sequence, node.data.children.head);
                if (!res.match || res.next) {
                    badNode = res.badNode || res.lastNode || (res.next ? res.next.data : null) || node.data;  // TODO: case when res.next === null
                    break mismatch;
                }

                result.push(res.match);
                node = res.next;
                break;

            case 'Type':
                var typeSyntax = syntax.getType(syntaxNode.name);
                if (!typeSyntax) {
                    throw new Error('Unknown syntax type `' + syntaxNode.name + '`');
                }

                var res = typeSyntax.match(node);
                if (!res || !res.match) {
                    badNode = res && res.badNode; // TODO: case when res.next === null
                    lastNode = (res && res.lastNode) || (node && node.data);
                    break mismatch;
                }

                result.push(res.match);
                node = res.next;
                break;

            case 'Property':
                var propertySyntax = syntax.getProperty(syntaxNode.name);
                if (!propertySyntax) {
                    throw new Error('Unknown property `' + syntaxNode.name + '`');
                }

                var res = propertySyntax.match(node);
                if (!res || !res.match) {
                    badNode = res && res.badNode; // TODO: case when res.next === null
                    lastNode = (res && res.lastNode) || (node && node.data);
                    break mismatch;
                }

                result.push(res.match);
                node = res.next;
                break;

            case 'Keyword':
                if (!node) {
                    break mismatch;
                }

                if (node.data.type === 'Identifier') {
                    var keyword = names.keyword(node.data.name);
                    var keywordName = keyword.name;
                    var name = syntaxNode.name.toLowerCase();

                    // drop \0 and \9 hack from keyword name
                    if (keywordName.indexOf('\\') !== -1) {
                        keywordName = keywordName.replace(/\\[09].*$/, '');
                    }

                    if (name !== keyword.vendor + keywordName) {
                        break mismatch;
                    }
                } else {
                    // keyword may to be a number (a.e. font-weight: 400 )
                    if (node.data.type !== 'Number' || node.data.value !== syntaxNode.name) {
                        break mismatch;
                    }
                }

                result.push(node.data);
                node = node.next;
                break;

            case 'Slash':
            case 'Comma':
                if (!node || node.data.type !== 'Operator' || node.data.value !== syntaxNode.value) {
                    break mismatch;
                }

                result.push(node.data);
                node = node.next;
                break;

            case 'String':
                if (!node || node.data.type !== 'String') {
                    break mismatch;
                }

                result.push(node.data);
                node = node.next;
                break;

            default:
                throw new Error('Not implemented yet node type: ' + syntaxNode.type);
        }

        matchCount++;
        if (!node) {
            break;
        }

        if (multiplier.comma) {
            if (lastComma && lastCommaTermCount === result.length) {
                // nothing match after comma
                break mismatch;
            }

            node = skipSpaces(node);
            if (node && node.data.type === 'Operator' && node.data.value === ',') {
                lastCommaTermCount = result.length;
                lastComma = node;
                node = node.next;
            } else {
                lastNode = node && node.data;
                break mismatch;
            }
        }
    }

    // console.log(syntaxNode.type, badNode, lastNode);

    if (lastComma && lastCommaTermCount === result.length) {
        // nothing match after comma
        node = lastComma;
    }

    if (badNode) {
        return {
            badNode: badNode,
            lastNode: null,
            next: null,
            match: null
        };
    }

    return {
        badNode: null,
        lastNode: lastNode,
        next: node,
        match: matchCount < min ? null : {
            type: syntaxNode.type,
            name: syntaxNode.name,
            match: result
        }
    };
};
}, {"381":381}];
window.modules["397"] = [function(require,module,exports){module.exports = {
    parse: {
        expression: function() {
            return this.MediaQueryList();
        },
        block: function() {
            return this.Block(this.Rule);
        }
    }
};
}, {}];
window.modules["398"] = [function(require,module,exports){var TYPE = require(392).TYPE;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

module.exports = {
    parse: {
        expression: function() {
            if (this.scanner.lookupNonWSType(0) === LEFTCURLYBRACKET) {
                return null;
            }

            return this.SelectorList();
        },
        block: function() {
            return this.Block(this.Declaration);
        }
    }
};
}, {"392":392}];
window.modules["457"] = [function(require,module,exports){var shape = {
    generic: true,
    types: {},
    properties: {},
    parseContext: {},
    scope: {},
    atrule: ['parse'],
    pseudo: ['parse'],
    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
};

function mix(dest, src, shape) {
    for (var key in shape) {
        if (shape[key] === true) {
            if (key in src) {
                dest[key] = src[key];
            }
        } else if (shape[key]) {
            if (shape[key].constructor === Object) {
                var res = {};
                for (var name in dest[key]) {
                    res[name] = dest[key][name];
                }
                for (var name in src[key]) {
                    res[name] = src[key][name];
                }
                dest[key] = res;
            } else if (Array.isArray(shape[key])) {
                var res = {};
                var innerShape = shape[key].reduce(function(s, k) {
                    s[k] = true;
                    return s;
                }, {});
                for (var name in dest[key]) {
                    res[name] = {};
                    if (dest[key] && dest[key][name]) {
                        mix(res[name], dest[key][name], innerShape);
                    }
                }
                for (var name in src[key]) {
                    if (!res[name]) {
                        res[name] = {};
                    }
                    if (src[key] && src[key][name]) {
                        mix(res[name], src[key][name], innerShape);
                    }
                }
                dest[key] = res;
            }
        }
    }
    return dest;
}

module.exports = function(dest, src) {
    return mix(dest, src, shape);
};
}, {}];
window.modules["403"] = [function(require,module,exports){var TYPE = require(392).TYPE;

var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
var COLON = TYPE.Colon;
var SOLIDUS = TYPE.Solidus;

module.exports = {
    name: 'MediaFeature',
    structure: {
        name: String,
        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var value = null;

        this.scanner.eat(LEFTPARENTHESIS);
        this.scanner.skipSC();

        name = this.scanner.consume(IDENTIFIER);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
            this.scanner.eat(COLON);
            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case NUMBER:
                    if (this.scanner.lookupType(1) === IDENTIFIER) {
                        value = this.Dimension();
                    } else if (this.scanner.lookupNonWSType(1) === SOLIDUS) {
                        value = this.Ratio();
                    } else {
                        value = this.Number();
                    }

                    break;

                case IDENTIFIER:
                    value = this.Identifier();

                    break;

                default:
                    this.scanner.error('Number, dimension, ratio or identifier is expected');
            }

            this.scanner.skipSC();
        }

        this.scanner.eat(RIGHTPARENTHESIS);

        return {
            type: 'MediaFeature',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            value: value
        };
    },
    generate: function(node) {
        return node.value !== null
            ? ['(' + node.name + ':', this.generate(node.value), ')']
            : '(' + node.name + ')';
    }
};
}, {"392":392}];
window.modules["434"] = [function(require,module,exports){var List = require(394);
var TYPE = require(392).TYPE;

var WHITESPACE = TYPE.Whitespace;
var COMMENT = TYPE.Comment;
var IDENTIFIER = TYPE.Identifier;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;

module.exports = {
    name: 'MediaQuery',
    structure: {
        children: [['Identifier', 'MediaFeature', 'WhiteSpace']]
    },
    parse: function() {
        this.scanner.skipSC();

        var children = new List();
        var child = null;
        var space = null;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case COMMENT:
                    this.scanner.next();
                    continue;

                case WHITESPACE:
                    space = this.WhiteSpace();
                    continue;

                case IDENTIFIER:
                    child = this.Identifier();
                    break;

                case LEFTPARENTHESIS:
                    child = this.MediaFeature();
                    break;

                default:
                    break scan;
            }

            if (space !== null) {
                children.appendData(space);
                space = null;
            }

            children.appendData(child);
        }

        if (child === null) {
            this.scanner.error('Identifier or parenthesis is expected');
        }

        return {
            type: 'MediaQuery',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        return this.each(node.children);
    }
};
}, {"392":392,"394":394}];
window.modules["435"] = [function(require,module,exports){var List = require(394);
var COMMA = require(392).TYPE.Comma;

module.exports = {
    name: 'MediaQueryList',
    structure: {
        children: [['MediaQuery']]
    },
    parse: function(relative) {
        var children = new List();

        this.scanner.skipSC();

        while (!this.scanner.eof) {
            children.appendData(this.MediaQuery(relative));

            if (this.scanner.tokenType !== COMMA) {
                break;
            }

            this.scanner.next();
        }

        return {
            type: 'MediaQueryList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(node) {
        return this.eachComma(node.children);
    }
};
}, {"392":392,"394":394}];
window.modules["401"] = [function(require,module,exports){// https://drafts.csswg.org/css-syntax-3/#the-anb-type
module.exports = {
    name: 'Nth',
    structure: {
        nth: ['AnPlusB', 'Identifier'],
        selector: ['SelectorList', null]
    },
    parse: function(allowOfClause) {
        this.scanner.skipSC();

        var start = this.scanner.tokenStart;
        var end = start;
        var selector = null;
        var query;

        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
            query = this.Identifier();
        } else {
            query = this.AnPlusB();
        }

        this.scanner.skipSC();

        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
            this.scanner.next();

            selector = this.SelectorList();

            if (this.needPositions) {
                end = selector.children.last().loc.end.offset;
            }
        } else {
            if (this.needPositions) {
                end = query.loc.end.offset;
            }
        }

        return {
            type: 'Nth',
            loc: this.getLocation(start, end),
            nth: query,
            selector: selector
        };
    },
    generate: function(node) {
        return node.selector !== null
            ? [this.generate(node.nth), ' of ', this.generate(node.selector)]
            : [this.generate(node.nth)];
    }
};
}, {}];
window.modules["404"] = [function(require,module,exports){var NUMBER = require(392).TYPE.Number;

module.exports = {
    name: 'Number',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'Number',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.scanner.consume(NUMBER)
        };
    },
    generate: function(node) {
        return node.value;
    }
};
}, {"392":392}];
window.modules["402"] = [function(require,module,exports){// '/' | '*' | ',' | ':' | '+' | '-'
module.exports = {
    name: 'Operator',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.next();

        return {
            type: 'Operator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(node) {
        return node.value;
    }
};
}, {}];
window.modules["405"] = [function(require,module,exports){var TYPE = require(392).TYPE;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;

module.exports = {
    name: 'Parentheses',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.scanner.eat(LEFTPARENTHESIS);
        children = readSequence.call(this, recognizer);
        this.scanner.eat(RIGHTPARENTHESIS);

        return {
            type: 'Parentheses',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(node) {
        return [].concat('(', this.each(node.children), ')');
    }
};
}, {"392":392}];
window.modules["406"] = [function(require,module,exports){var TYPE = require(392).TYPE;

var NUMBER = TYPE.Number;
var PERCENTSIGN = TYPE.PercentSign;

module.exports = {
    name: 'Percentage',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var number = this.scanner.consume(NUMBER);

        this.scanner.eat(PERCENTSIGN);

        return {
            type: 'Percentage',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: number
        };
    },
    generate: function(node) {
        return node.value + '%';
    }
};
}, {"392":392}];
window.modules["436"] = [function(require,module,exports){var List = require(394);
var TYPE = require(392).TYPE;

var IDENTIFIER = TYPE.Identifier;
var COLON = TYPE.Colon;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
var BALANCED = true;

// : ident [ '(' .. ')' ]?
module.exports = {
    name: 'PseudoClassSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var children = null;

        this.scanner.eat(COLON);

        name = this.scanner.consume(IDENTIFIER);

        if (this.scanner.tokenType === LEFTPARENTHESIS) {
            var nameLowerCase = name.toLowerCase();

            this.scanner.next();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = new List().appendData(this.Raw(BALANCED, 0, 0));
            }

            this.scanner.eat(RIGHTPARENTHESIS);
        }

        return {
            type: 'PseudoClassSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        return node.children !== null
            ? [].concat(':' + node.name + '(', this.each(node.children), ')')
            : ':' + node.name;
    },
    walkContext: 'function'
};
}, {"392":392,"394":394}];
window.modules["437"] = [function(require,module,exports){var List = require(394);
var TYPE = require(392).TYPE;

var IDENTIFIER = TYPE.Identifier;
var COLON = TYPE.Colon;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
var BALANCED = true;

// :: ident [ '(' .. ')' ]?
module.exports = {
    name: 'PseudoElementSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var children = null;

        this.scanner.eat(COLON);
        this.scanner.eat(COLON);

        name = this.scanner.consume(IDENTIFIER);

        if (this.scanner.tokenType === LEFTPARENTHESIS) {
            var nameLowerCase = name.toLowerCase();

            this.scanner.next();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = new List().appendData(this.Raw(BALANCED, 0, 0));
            }

            this.scanner.eat(RIGHTPARENTHESIS);
        }

        return {
            type: 'PseudoElementSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(node) {
        return node.children !== null
            ? [].concat('::' + node.name + '(', this.each(node.children), ')')
            : '::' + node.name;
    },
    walkContext: 'function'
};
}, {"392":392,"394":394}];
window.modules["461"] = [function(require,module,exports){var List = require(394);
var DISALLOW_OF_CLAUSE = false;

module.exports = {
    parse: function nth() {
        return new List().appendData(
            this.Nth(DISALLOW_OF_CLAUSE)
        );
    }
};
}, {"394":394}];
window.modules["462"] = [function(require,module,exports){var List = require(394);
var ALLOW_OF_CLAUSE = true;

module.exports = {
    parse: function() {
        return new List().appendData(
            this.Nth(ALLOW_OF_CLAUSE)
        );
    }
};
}, {"394":394}];
window.modules["449"] = [function(require,module,exports){module.exports = require(463);
}, {"463":463}];
window.modules["452"] = [function(require,module,exports){module.exports = require(463);
}, {"463":463}];
window.modules["448"] = [function(require,module,exports){module.exports = require(462);
}, {"462":462}];
window.modules["451"] = [function(require,module,exports){module.exports = require(462);
}, {"462":462}];
window.modules["450"] = [function(require,module,exports){module.exports = require(461);
}, {"461":461}];
window.modules["447"] = [function(require,module,exports){module.exports = require(461);
}, {"461":461}];
window.modules["381"] = [function(require,module,exports){'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;
var keywords = Object.create(null);
var properties = Object.create(null);
var HYPHENMINUS = 45; // '-'.charCodeAt()

function isVariable(str, offset) {
    return str.charCodeAt(offset) === HYPHENMINUS &&
           str.charCodeAt(offset + 1) === HYPHENMINUS;
}

function getVendorPrefix(str, offset) {
    if (str.charCodeAt(offset) === HYPHENMINUS) {
        // vendor should contain at least one letter
        var secondDashIndex = str.indexOf('-', offset + 2);

        if (secondDashIndex !== -1) {
            return str.substring(offset, secondDashIndex + 1);
        }
    }

    return '';
}

function getKeywordInfo(keyword) {
    if (hasOwnProperty.call(keywords, keyword)) {
        return keywords[keyword];
    }

    var name = keyword.toLowerCase();

    if (hasOwnProperty.call(keywords, name)) {
        return keywords[keyword] = keywords[name];
    }

    var vendor = !isVariable(name, 0) ? getVendorPrefix(name, 0) : '';

    return keywords[keyword] = Object.freeze({
        vendor: vendor,
        prefix: vendor,
        name: name.substr(vendor.length)
    });
}

function getPropertyInfo(property) {
    if (hasOwnProperty.call(properties, property)) {
        return properties[property];
    }

    var name = property;
    var hack = property[0];

    if (hack === '/' && property[1] === '/') {
        hack = '//';
    } else if (hack !== '_' &&
               hack !== '*' &&
               hack !== '$' &&
               hack !== '#' &&
               hack !== '+') {
        hack = '';
    }

    var variable = isVariable(name, hack.length);

    if (!variable) {
        name = name.toLowerCase();
        if (hasOwnProperty.call(properties, name)) {
            return properties[property] = properties[name];
        }
    }

    var vendor = !variable ? getVendorPrefix(name, hack.length) : '';

    return properties[property] = Object.freeze({
        hack: hack,
        vendor: vendor,
        prefix: hack + vendor,
        name: name.substr(hack.length + vendor.length),
        variable: variable
    });
}

module.exports = {
    keyword: getKeywordInfo,
    property: getPropertyInfo
};
}, {}];
window.modules["474"] = [function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require(470);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;
}, {"470":470}];
window.modules["511"] = [function(require,module,exports){module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}}, {}];
window.modules["517"] = [function(require,module,exports){//https://developer.mozilla.org/en-US/docs/Web/API/Element


function Node(cfg) {

  this.namespace     = cfg.namespace || null;
  this.text          = cfg.text;
  this._selfCloseTag = cfg.selfCloseTag;


  Object.defineProperties(this, {
    nodeType: {
      value: cfg.nodeType
    },
    nodeName: {
      value: cfg.nodeType == 1 ? cfg.nodeName : '#text'
    },
    childNodes: {
      value: cfg.childNodes
    },
    firstChild: {
      get: function(){
        return this.childNodes[0] || null;
      }
    },
    lastChild: {
      get: function(){
        return this.childNodes[this.childNodes.length-1] || null;
      }
    },
    parentNode: {
      value: cfg.parentNode || null
    },
    attributes: {
      value: cfg.attributes || []
    },
    innerHTML: {
      get: function(){
        var
          result = '',
          cNode;
        for (var i = 0, l = this.childNodes.length; i < l; i++) {
          cNode = this.childNodes[i];
          result += cNode.nodeType === 3 ? cNode.text : cNode.outerHTML;
        }
        return result;
      }
    },
    outerHTML: {
      get: function(){
        if (this.nodeType != 3){
          var
            str,
            attrs = (this.attributes.map(function(elem){
              return elem.name + (elem.value ? '=' + '"'+ elem.value +'"' : '');
            }) || []).join(' '),
            childs = '';

          str = '<' + this.nodeName + (attrs ? ' ' + attrs : '') + (this._selfCloseTag ? '/' : '') + '>';

          if (!this._selfCloseTag){
            childs = (this._selfCloseTag ? '' : this.childNodes.map(function(child){
              return child.outerHTML;
            }) || []).join('');

            str += childs;
            str += '</' + this.nodeName + '>';
          }
        }
        else{
          str = this.textContent;
        }
        return str;
      }
    },
    textContent: {
      get: function(){
        if (this.nodeType == Node.TEXT_NODE){
          return this.text;
        }
        else{
          return this.childNodes.map(function(node){
            return node.textContent;
          }).join('').replace(/\x20+/g, ' ');
        }
      }
    }
  });
}

Node.prototype.getAttribute = function (attributeName) {
  for (var i = 0, l = this.attributes.length; i < l; i++) {
    if (this.attributes[i].name == attributeName) {
      return this.attributes[i].value;
    }
  }
  return null;
};

function searchElements(root, conditionFn, onlyFirst){
  var result = [];
  onlyFirst = !!onlyFirst;
  if (root.nodeType !== 3) {
    for (var i = 0, l = root.childNodes.length; i < l; i++) {
      if (root.childNodes[i].nodeType !== 3 && conditionFn(root.childNodes[i])) {
        result.push(root.childNodes[i]);
        if (onlyFirst){
          break;
        }
      }
      result = result.concat(searchElements(root.childNodes[i], conditionFn));
    }
  }
  return onlyFirst ? result[0] : result;
}

Node.prototype.getElementsByTagName = function (tagName) {
  return searchElements(this, function(elem){
    return elem.nodeName == tagName;
  })
};

Node.prototype.getElementsByClassName = function (className) {
  var expr = new RegExp('^(.*?\\s)?' + className + '(\\s.*?)?$');
  return searchElements(this, function(elem){
    return elem.attributes.length && expr.test(elem.getAttribute('class'));
  })
};

Node.prototype.getElementById = function (id) {
  return searchElements(this, function(elem){
    return elem.attributes.length && elem.getAttribute('id') == id;
  }, true)
};

Node.prototype.getElementsByName = function (name) {
  return searchElements(this, function(elem){
    return elem.attributes.length && elem.getAttribute('name') == name;
  })
};


Node.ELEMENT_NODE = 1;
Node.TEXT_NODE    = 3;

module.exports = Node;}, {}];
window.modules["523"] = [function(require,module,exports){// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var NodePrototype = module.exports = {
	get firstChild() {
		var children = this.children;
		return children && children[0] || null;
	},
	get lastChild() {
		var children = this.children;
		return children && children[children.length - 1] || null;
	},
	get nodeType() {
		return nodeTypes[this.type] || nodeTypes.element;
	}
};

var domLvl1 = {
	tagName: "name",
	childNodes: "children",
	parentNode: "parent",
	previousSibling: "prev",
	nextSibling: "next",
	nodeValue: "data"
};

var nodeTypes = {
	element: 1,
	text: 3,
	cdata: 4,
	comment: 8
};

Object.keys(domLvl1).forEach(function(key) {
	var shorthand = domLvl1[key];
	Object.defineProperty(NodePrototype, key, {
		get: function() {
			return this[shorthand] || null;
		},
		set: function(val) {
			this[shorthand] = val;
			return val;
		}
	});
});
}, {}];
window.modules["525"] = [function(require,module,exports){;(function(factory) {
    'use strict';
    /* global window: false, define: false, module: false */
    var root = typeof window === 'undefined' ? null : window;

    if (typeof define === 'function' && define.amd) {
        define(function(){ return factory(root); });
    } else if (typeof module !== 'undefined') {
        module.exports = factory(root);
    } else {
        root.DOMPurify = factory(root);
    }
}(function factory(window) {
    'use strict';

    var DOMPurify = function(window) {
        return factory(window);
    };

    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */
    DOMPurify.version = '0.8.9';

    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */
    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
        // not running in a browser, provide a factory function
        // so that you can pass your own Window
        DOMPurify.isSupported = false;
        return DOMPurify;
    }

    var document = window.document;
    var originalDocument = document;
    var DocumentFragment = window.DocumentFragment;
    var HTMLTemplateElement = window.HTMLTemplateElement;
    var Node = window.Node;
    var NodeFilter = window.NodeFilter;
    var NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap;
    var Text = window.Text;
    var Comment = window.Comment;
    var DOMParser = window.DOMParser;
    var useDOMParser = false; // See comment below

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') {
        var template = document.createElement('template');
        if (template.content && template.content.ownerDocument) {
            document = template.content.ownerDocument;
        }
    }
    var implementation = document.implementation;
    var createNodeIterator = document.createNodeIterator;
    var getElementsByTagName = document.getElementsByTagName;
    var createDocumentFragment = document.createDocumentFragment;
    var importNode = originalDocument.importNode;

    var hooks = {};

    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported =
        typeof implementation.createHTMLDocument !== 'undefined' &&
        document.documentMode !== 9;

    /* Add properties to a lookup table */
    var _addToSet = function(set, array) {
        var l = array.length;
        while (l--) {
            if (typeof array[l] === 'string') {
                array[l] = array[l].toLowerCase();
            }
            set[array[l]] = true;
        }
        return set;
    };

    /* Shallow clone an object */
    var _cloneObj = function(object) {
        var newObject = {};
        var property;
        for (property in object) {
            if (object.hasOwnProperty(property)) {
                newObject[property] = object[property];
            }
        }
        return newObject;
    };

    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */
    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = _addToSet({}, [

        // HTML
        'a','abbr','acronym','address','area','article','aside','audio','b',
        'bdi','bdo','big','blink','blockquote','body','br','button','canvas',
        'caption','center','cite','code','col','colgroup','content','data',
        'datalist','dd','decorator','del','details','dfn','dir','div','dl','dt',
        'element','em','fieldset','figcaption','figure','font','footer','form',
        'h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','i',
        'img','input','ins','kbd','label','legend','li','main','map','mark',
        'marquee','menu','menuitem','meter','nav','nobr','ol','optgroup',
        'option','output','p','pre','progress','q','rp','rt','ruby','s','samp',
        'section','select','shadow','small','source','spacer','span','strike',
        'strong','style','sub','summary','sup','table','tbody','td','template',
        'textarea','tfoot','th','thead','time','tr','track','tt','u','ul','var',
        'video','wbr',

        // SVG
        'svg','altglyph','altglyphdef','altglyphitem','animatecolor',
        'animatemotion','animatetransform','circle','clippath','defs','desc',
        'ellipse','filter','font','g','glyph','glyphref','hkern','image','line',
        'lineargradient','marker','mask','metadata','mpath','path','pattern',
        'polygon','polyline','radialgradient','rect','stop','switch','symbol',
        'text','textpath','title','tref','tspan','view','vkern',

        // SVG Filters
        'feBlend','feColorMatrix','feComponentTransfer','feComposite',
        'feConvolveMatrix','feDiffuseLighting','feDisplacementMap',
        'feFlood','feFuncA','feFuncB','feFuncG','feFuncR','feGaussianBlur',
        'feMerge','feMergeNode','feMorphology','feOffset',
        'feSpecularLighting','feTile','feTurbulence',

        //MathML
        'math','menclose','merror','mfenced','mfrac','mglyph','mi','mlabeledtr',
        'mmuliscripts','mn','mo','mover','mpadded','mphantom','mroot','mrow',
        'ms','mpspace','msqrt','mystyle','msub','msup','msubsup','mtable','mtd',
        'mtext','mtr','munder','munderover',

        //Text
        '#text'
    ]);

    /* Allowed attribute names */
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = _addToSet({}, [

        // HTML
        'accept','action','align','alt','autocomplete','background','bgcolor',
        'border','cellpadding','cellspacing','checked','cite','class','clear','color',
        'cols','colspan','coords','datetime','default','dir','disabled',
        'download','enctype','face','for','headers','height','hidden','high','href',
        'hreflang','id','ismap','label','lang','list','loop', 'low','max',
        'maxlength','media','method','min','multiple','name','noshade','novalidate',
        'nowrap','open','optimum','pattern','placeholder','poster','preload','pubdate',
        'radiogroup','readonly','rel','required','rev','reversed','role','rows',
        'rowspan','spellcheck','scope','selected','shape','size','span',
        'srclang','start','src','step','style','summary','tabindex','title',
        'type','usemap','valign','value','width','xmlns',

        // SVG
        'accent-height','accumulate','additivive','alignment-baseline',
        'ascent','attributename','attributetype','azimuth','basefrequency',
        'baseline-shift','begin','bias','by','clip','clip-path','clip-rule',
        'color','color-interpolation','color-interpolation-filters','color-profile',
        'color-rendering','cx','cy','d','dx','dy','diffuseconstant','direction',
        'display','divisor','dur','edgemode','elevation','end','fill','fill-opacity',
        'fill-rule','filter','flood-color','flood-opacity','font-family','font-size',
        'font-size-adjust','font-stretch','font-style','font-variant','font-weight',
        'fx', 'fy','g1','g2','glyph-name','glyphref','gradientunits','gradienttransform',
        'image-rendering','in','in2','k','k1','k2','k3','k4','kerning','keypoints',
        'keysplines','keytimes','lengthadjust','letter-spacing','kernelmatrix',
        'kernelunitlength','lighting-color','local','marker-end','marker-mid',
        'marker-start','markerheight','markerunits','markerwidth','maskcontentunits',
        'maskunits','max','mask','mode','min','numoctaves','offset','operator',
        'opacity','order','orient','orientation','origin','overflow','paint-order',
        'path','pathlength','patterncontentunits','patterntransform','patternunits',
        'points','preservealpha','r','rx','ry','radius','refx','refy','repeatcount',
        'repeatdur','restart','result','rotate','scale','seed','shape-rendering',
        'specularconstant','specularexponent','spreadmethod','stddeviation','stitchtiles',
        'stop-color','stop-opacity','stroke-dasharray','stroke-dashoffset','stroke-linecap',
        'stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke','stroke-width',
        'surfacescale','targetx','targety','transform','text-anchor','text-decoration',
        'text-rendering','textlength','u1','u2','unicode','values','viewbox',
        'visibility','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing',
        'wrap','writing-mode','xchannelselector','ychannelselector','x','x1','x2',
        'y','y1','y2','z','zoomandpan',

        // MathML
        'accent','accentunder','bevelled','close','columnsalign','columnlines',
        'columnspan','denomalign','depth','display','displaystyle','fence',
        'frame','largeop','length','linethickness','lspace','lquote',
        'mathbackground','mathcolor','mathsize','mathvariant','maxsize',
        'minsize','movablelimits','notation','numalign','open','rowalign',
        'rowlines','rowspacing','rowspan','rspace','rquote','scriptlevel',
        'scriptminsize','scriptsizemultiplier','selection','separator',
        'separators','stretchy','subscriptshift','supscriptshift','symmetric',
        'voffset',

        // XML
        'xlink:href','xml:id','xlink:title','xml:space','xmlns:xlink'
    ]);

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null;

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null;

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true;

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Output should be safe for jQuery's $() factory? */
    var SAFE_FOR_JQUERY = false;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    var SAFE_FOR_TEMPLATES = false;

    /* Specify template detection regex for SAFE_FOR_TEMPLATES mode */
    var MUSTACHE_EXPR = /\{\{[\s\S]*|[\s\S]*\}\}/gm;
    var ERB_EXPR = /<%[\s\S]*|[\s\S]*%>/gm;

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false;

    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    var FORCE_BODY = false;

    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html string.
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */
    var RETURN_DOM = false;

    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html string */
    var RETURN_DOM_FRAGMENT = false;

    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
     * `Node` is imported into the current `Document`. If this flag is not enabled the
     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
     * DOMPurify. */
    var RETURN_DOM_IMPORT = false;

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true;

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true;

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = _addToSet({}, [
        'audio', 'head', 'math', 'script', 'style', 'template', 'svg', 'video'
    ]);

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = _addToSet({}, [
        'audio', 'video', 'img', 'source', 'image'
    ]);

    /* Attributes safe for values like "javascript:" */
    var URI_SAFE_ATTRIBUTES = _addToSet({}, [
        'alt','class','for','id','label','name','pattern','placeholder',
        'summary','title','value','style','xmlns'
    ]);

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null;

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form');

    /**
     * _parseConfig
     *
     * @param  optional config literal
     */
    var _parseConfig = function(cfg) {
        /* Shield configuration object from tampering */
        if (typeof cfg !== 'object') {
            cfg = {};
        }

        /* Set configuration parameters */
        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ?
            _addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ?
            _addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
        FORBID_TAGS = 'FORBID_TAGS' in cfg ?
            _addToSet({}, cfg.FORBID_TAGS) : {};
        FORBID_ATTR = 'FORBID_ATTR' in cfg ?
            _addToSet({}, cfg.FORBID_ATTR) : {};
        ALLOW_ARIA_ATTR     = cfg.ALLOW_ARIA_ATTR     !== false; // Default true
        ALLOW_DATA_ATTR     = cfg.ALLOW_DATA_ATTR     !== false; // Default true
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
        SAFE_FOR_JQUERY     = cfg.SAFE_FOR_JQUERY     ||  false; // Default false
        SAFE_FOR_TEMPLATES  = cfg.SAFE_FOR_TEMPLATES  ||  false; // Default false
        WHOLE_DOCUMENT      = cfg.WHOLE_DOCUMENT      ||  false; // Default false
        RETURN_DOM          = cfg.RETURN_DOM          ||  false; // Default false
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT ||  false; // Default false
        RETURN_DOM_IMPORT   = cfg.RETURN_DOM_IMPORT   ||  false; // Default false
        FORCE_BODY          = cfg.FORCE_BODY          ||  false; // Default false
        SANITIZE_DOM        = cfg.SANITIZE_DOM        !== false; // Default true
        KEEP_CONTENT        = cfg.KEEP_CONTENT        !== false; // Default true

        if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
        }

        if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
        }

        /* Merge configuration parameters */
        if (cfg.ADD_TAGS) {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                ALLOWED_TAGS = _cloneObj(ALLOWED_TAGS);
            }
            _addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
        }
        if (cfg.ADD_ATTR) {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                ALLOWED_ATTR = _cloneObj(ALLOWED_ATTR);
            }
            _addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
            _addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
        }

        /* Add #text in case KEEP_CONTENT is set to true */
        if (KEEP_CONTENT) { ALLOWED_TAGS['#text'] = true; }

        // Prevent further manipulation of configuration.
        // Not available in IE8, Safari 5, etc.
        if (Object && 'freeze' in Object) { Object.freeze(cfg); }

        CONFIG = cfg;
    };

   /**
     * _forceRemove
     *
     * @param  a DOM node
     */
    var _forceRemove = function(node) {
        DOMPurify.removed.push({element: node});
        try {
            node.parentNode.removeChild(node);
        } catch (e) {
            node.outerHTML = '';
        }
    };

   /**
     * _removeAttribute
     *
     * @param  an Attribute name
     * @param  a DOM node
     */
    var _removeAttribute = function(name, node) {
        DOMPurify.removed.push({
            attribute: node.getAttributeNode(name),
            from: node
        });
        node.removeAttribute(name);
    };

   /**
     * _initDocument
     *
     * @param  a string of dirty markup
     * @return a DOM, filled with the dirty markup
     */
    var _initDocument = function(dirty) {
        /* Create a HTML document */
        var doc, body;

        /* Fill body with bogus element */
        if (FORCE_BODY) {
            dirty = '<remove></remove>' + dirty;
        }

        /* Use DOMParser to workaround Firefox bug (see comment below) */
        if (useDOMParser) {
            try {
                doc = new DOMParser().parseFromString(dirty, 'text/html');
            } catch (e) {}
        }

        /* Otherwise use createHTMLDocument, because DOMParser is unsafe in
           Safari (see comment below) */
        if (!doc || !doc.documentElement) {
            doc = implementation.createHTMLDocument('');
            body = doc.body;
            body.parentNode.removeChild(body.parentNode.firstElementChild);
            body.outerHTML = dirty;
        }

        /* Work on whole document or just its body */
        return getElementsByTagName.call(doc,
            WHOLE_DOCUMENT ? 'html' : 'body')[0];
    };

    // Safari 10.1+ (unfixed as of time of writing) has a catastrophic bug in
    // its implementation of DOMParser such that the following executes the
    // JavaScript:
    //
    // new DOMParser()
    //   .parseFromString('<svg onload=alert(document.domain)>', 'text/html');
    //
    // However, Firefox uses a different parser for innerHTML rather than
    // DOMParser (see https://bugzilla.mozilla.org/show_bug.cgi?id=1205631)
    // which means that you *must* use DOMParser, otherwise the output may
    // not be safe if used in a document.write context later.
    //
    // So we feature detect the Firefox bug and use the DOMParser if necessary.
    if (DOMPurify.isSupported) {
        (function () {
            var doc = _initDocument('<svg><p><style><img src="</style><img src=x onerror=alert(1)//">');
            if (doc.querySelector('svg img')) {
                useDOMParser = true;
            }
        }());
    }

    /**
     * _createIterator
     *
     * @param  document/fragment to create iterator for
     * @return iterator instance
     */
    var _createIterator = function(root) {
        return createNodeIterator.call(root.ownerDocument || root,
            root,
            NodeFilter.SHOW_ELEMENT
            | NodeFilter.SHOW_COMMENT
            | NodeFilter.SHOW_TEXT,
            function() { return NodeFilter.FILTER_ACCEPT; },
            false
        );
    };

    /**
     * _isClobbered
     *
     * @param  element to check for clobbering attacks
     * @return true if clobbered, false if safe
     */
    var _isClobbered = function(elm) {
        if (elm instanceof Text || elm instanceof Comment) {
            return false;
        }
        if (  typeof elm.nodeName !== 'string'
           || typeof elm.textContent !== 'string'
           || typeof elm.removeChild !== 'function'
           || !(elm.attributes instanceof NamedNodeMap)
           || typeof elm.removeAttribute !== 'function'
           || typeof elm.setAttribute !== 'function'
        ) {
            return true;
        }
        return false;
    };

    /**
     * _isNode
     *
     * @param object to check whether it's a DOM node
     * @return true is object is a DOM node
     */
    var _isNode = function(obj) {
        return (
            typeof Node === "object" ? obj instanceof Node : obj
                && typeof obj === "object" && typeof obj.nodeType === "number"
                && typeof obj.nodeName==="string"
        );
    };

    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   node to check for permission to exist
     * @return  true if node was killed, false if left alive
     */
    var _sanitizeElements = function(currentNode) {
        var tagName, content;

        /* Execute a hook if present */
        _executeHook('beforeSanitizeElements', currentNode, null);

        /* Check if element is clobbered or can clobber */
        if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
            return true;
        }

        /* Now let's check the element's type and name */
        tagName = currentNode.nodeName.toLowerCase();

        /* Execute a hook if present */
        _executeHook('uponSanitizeElement', currentNode, {
            tagName: tagName,
            allowedTags: ALLOWED_TAGS
        });

        /* Remove element if anything forbids its presence */
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            /* Keep content except for black-listed elements */
            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]
                    && typeof currentNode.insertAdjacentHTML === 'function') {
                try {
                    currentNode.insertAdjacentHTML('AfterEnd', currentNode.innerHTML);
                } catch (e) {}
            }
            _forceRemove(currentNode);
            return true;
        }

        /* Convert markup to cover jQuery behavior */
        if (SAFE_FOR_JQUERY && !currentNode.firstElementChild &&
                (!currentNode.content || !currentNode.content.firstElementChild) &&
                /</g.test(currentNode.textContent)) {
            DOMPurify.removed.push({element: currentNode.cloneNode()});
            currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;');
        }

        /* Sanitize element content to be template-safe */
        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
            /* Get the element's text content */
            content = currentNode.textContent;
            content = content.replace(MUSTACHE_EXPR, ' ');
            content = content.replace(ERB_EXPR, ' ');
            if (currentNode.textContent !== content) {
                DOMPurify.removed.push({element: currentNode.cloneNode()});
                currentNode.textContent = content;
            }
        }

        /* Execute a hook if present */
        _executeHook('afterSanitizeElements', currentNode, null);

        return false;
    };

    var DATA_ATTR = /^data-[\-\w.\u00B7-\uFFFF]/;
    var ARIA_ATTR = /^aria-[\-\w]+$/;
    var IS_ALLOWED_URI = /^(?:(?:(?:f|ht)tps?|mailto|tel):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
    var IS_SCRIPT_OR_DATA = /^(?:\w+script|data):/i;
    /* This needs to be extensive thanks to Webkit/Blink's behavior */
    var ATTR_WHITESPACE = /[\x00-\x20\xA0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;

    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param   node to sanitize
     * @return  void
     */
    var _sanitizeAttributes = function(currentNode) {
        var attr, name, value, lcName, idAttr, attributes, hookEvent, l;
        /* Execute a hook if present */
        _executeHook('beforeSanitizeAttributes', currentNode, null);

        attributes = currentNode.attributes;

        /* Check if we have attributes; if not we might have a text node */
        if (!attributes) { return; }

        hookEvent = {
            attrName: '',
            attrValue: '',
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR
        };
        l = attributes.length;

        /* Go backwards over all attributes; safely remove bad ones */
        while (l--) {
            attr = attributes[l];
            name = attr.name;
            value = attr.value.trim();
            lcName = name.toLowerCase();

            /* Execute a hook if present */
            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            _executeHook('uponSanitizeAttribute', currentNode, hookEvent );
            value = hookEvent.attrValue;

            /* Remove attribute */
            // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to
            // remove a "name" attribute from an <img> tag that has an "id"
            // attribute at the time.
            if (lcName === 'name'  &&
                    currentNode.nodeName === 'IMG' && attributes.id) {
                idAttr = attributes.id;
                attributes = Array.prototype.slice.apply(attributes);
                _removeAttribute('id', currentNode);
                _removeAttribute(name, currentNode);
                if (attributes.indexOf(idAttr) > l) {
                    currentNode.setAttribute('id', idAttr.value);
                }
            } else if (
                  // This works around a bug in Safari, where input[type=file]
                  // cannot be dynamically set after type has been removed
                  currentNode.nodeName === 'INPUT' && lcName === 'type' &&
                  value === 'file' && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {
                  continue;
            } else {
                // This avoids a crash in Safari v9.0 with double-ids.
                // The trick is to first set the id to be empty and then to
                // remove the attribute
                if (name === 'id') {
                    currentNode.setAttribute(name, '');
                }
                _removeAttribute(name, currentNode);
            }

            /* Did the hooks approve of the attribute? */
            if (!hookEvent.keepAttr) {
                continue;
            }

            /* Make sure attribute cannot clobber */
            if (SANITIZE_DOM &&
                    (lcName === 'id' || lcName === 'name') &&
                    (value in window || value in document || value in formElement)) {
                continue;
            }

            /* Sanitize attribute content to be template-safe */
            if (SAFE_FOR_TEMPLATES) {
                value = value.replace(MUSTACHE_EXPR, ' ');
                value = value.replace(ERB_EXPR, ' ');
            }

            /* Allow valid data-* attributes: At least one character after "-"
               (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
               XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
               We don't need to check the value; it's always URI safe. */
            if (ALLOW_DATA_ATTR && DATA_ATTR.test(lcName)) {
                // This attribute is safe
            }
            else if (ALLOW_ARIA_ATTR && ARIA_ATTR.test(lcName)) {
                // This attribute is safe
            }
            /* Otherwise, check the name is permitted */
            else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
                continue;
            }
            /* Check value is safe. First, is attr inert? If so, is safe */
            else if (URI_SAFE_ATTRIBUTES[lcName]) {
                // This attribute is safe
            }
            /* Check no script, data or unknown possibly unsafe URI
               unless we know URI values are safe for that attribute */
            else if (IS_ALLOWED_URI.test(value.replace(ATTR_WHITESPACE,''))) {
                // This attribute is safe
            }
            /* Keep image data URIs alive if src/xlink:href is allowed */
            else if (
                (lcName === 'src' || lcName === 'xlink:href') &&
                value.indexOf('data:') === 0 &&
                DATA_URI_TAGS[currentNode.nodeName.toLowerCase()]) {
                // This attribute is safe
            }
            /* Allow unknown protocols: This provides support for links that
               are handled by protocol handlers which may be unknown ahead of
               time, e.g. fb:, spotify: */
            else if (
                ALLOW_UNKNOWN_PROTOCOLS &&
                !IS_SCRIPT_OR_DATA.test(value.replace(ATTR_WHITESPACE,''))) {
                // This attribute is safe
            }
            /* Check for binary attributes */
            else if (!value) {
                // binary attributes are safe at this point
            }
            /* Anything else, presume unsafe, do not add it back */
            else {
                continue;
            }

            /* Handle invalid data-* attribute set by try-catching it */
            try {
                currentNode.setAttribute(name, value);
                DOMPurify.removed.pop();
            } catch (e) {}
        }

        /* Execute a hook if present */
        _executeHook('afterSanitizeAttributes', currentNode, null);
    };

    /**
     * _sanitizeShadowDOM
     *
     * @param  fragment to iterate over recursively
     * @return void
     */
    var _sanitizeShadowDOM = function(fragment) {
        var shadowNode;
        var shadowIterator = _createIterator(fragment);

        /* Execute a hook if present */
        _executeHook('beforeSanitizeShadowDOM', fragment, null);

        while ( (shadowNode = shadowIterator.nextNode()) ) {
            /* Execute a hook if present */
            _executeHook('uponSanitizeShadowNode', shadowNode, null);

            /* Sanitize tags and elements */
            if (_sanitizeElements(shadowNode)) {
                continue;
            }

            /* Deep shadow DOM detected */
            if (shadowNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(shadowNode.content);
            }

            /* Check attributes, sanitize if necessary */
            _sanitizeAttributes(shadowNode);
        }

        /* Execute a hook if present */
        _executeHook('afterSanitizeShadowDOM', fragment, null);
    };

    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode
     */
    var _executeHook = function(entryPoint, currentNode, data) {
        if (!hooks[entryPoint]) { return; }

        hooks[entryPoint].forEach(function(hook) {
            hook.call(DOMPurify, currentNode, data, CONFIG);
        });
    };

    /**
     * sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    DOMPurify.sanitize = function(dirty, cfg) {
        var body, importedNode, currentNode, oldNode, nodeIterator, returnNode;
        /* Make sure we have a string to sanitize.
           DO NOT return early, as this will return the wrong type if
           the user has requested a DOM object rather than a string */
        if (!dirty) {
            dirty = '<!-->';
        }

        /* Stringify, in case dirty is an object */
        if (typeof dirty !== 'string' && !_isNode(dirty)) {
            if (typeof dirty.toString !== 'function') {
                throw new TypeError('toString is not a function');
            } else {
                dirty = dirty.toString();
            }
        }

        /* Check we can run. Otherwise fall back or ignore */
        if (!DOMPurify.isSupported) {
            if (typeof window.toStaticHTML === 'object'
                || typeof window.toStaticHTML === 'function') {
                if (typeof dirty === 'string') {
                    return window.toStaticHTML(dirty);
                } else if (_isNode(dirty)) {
                    return window.toStaticHTML(dirty.outerHTML);
                }
            }
            return dirty;
        }

        /* Assign config vars */
        _parseConfig(cfg);

        /* Clean up removed elements */
        DOMPurify.removed = [];

        if (dirty instanceof Node) {
            /* If dirty is a DOM element, append to an empty document to avoid
               elements being stripped by the parser */
            body = _initDocument('<!-->');
            importedNode = body.ownerDocument.importNode(dirty, true);
            if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
                /* Node is already a body, use as is */
                body = importedNode;
            } else {
                body.appendChild(importedNode);
            }
        } else {
            /* Exit directly if we have nothing to do */
            if (!RETURN_DOM && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {
                return dirty;
            }

            /* Initialize the document to work on */
            body = _initDocument(dirty);

            /* Check we have a DOM node from the data */
            if (!body) {
                return RETURN_DOM ? null : '';
            }
        }

        /* Remove first element node (ours) if FORCE_BODY is set */
        if (FORCE_BODY) {
            _forceRemove(body.firstChild);
        }

        /* Get node iterator */
        nodeIterator = _createIterator(body);

        /* Now start iterating over the created document */
        while ( (currentNode = nodeIterator.nextNode()) ) {

            /* Fix IE's strange behavior with manipulated textNodes #89 */
            if (currentNode.nodeType === 3 && currentNode === oldNode) {
                continue;
            }

            /* Sanitize tags and elements */
            if (_sanitizeElements(currentNode)) {
                continue;
            }

            /* Shadow DOM detected, sanitize it */
            if (currentNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(currentNode.content);
            }

            /* Check attributes, sanitize if necessary */
            _sanitizeAttributes(currentNode);

            oldNode = currentNode;
        }

        /* Return sanitized string or DOM */
        if (RETURN_DOM) {

            if (RETURN_DOM_FRAGMENT) {
                returnNode = createDocumentFragment.call(body.ownerDocument);

                while (body.firstChild) {
                    returnNode.appendChild(body.firstChild);
                }
            } else {
                returnNode = body;
            }

            if (RETURN_DOM_IMPORT) {
                /* adoptNode() is not used because internal state is not reset
                   (e.g. the past names map of a HTMLFormElement), this is safe
                   in theory but we would rather not risk another attack vector.
                   The state that is cloned by importNode() is explicitly defined
                   by the specs. */
                returnNode = importNode.call(originalDocument, returnNode, true);
            }

            return returnNode;
        }

        return WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    };

    /**
     * addHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint
     * @param {Function} hookFunction
     */
    DOMPurify.addHook = function(entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') { return; }
        hooks[entryPoint] = hooks[entryPoint] || [];
        hooks[entryPoint].push(hookFunction);
    };

    /**
     * removeHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint
     * @return void
     */
    DOMPurify.removeHook = function(entryPoint) {
        if (hooks[entryPoint]) {
            hooks[entryPoint].pop();
        }
    };

    /**
     * removeHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint
     * @return void
     */
    DOMPurify.removeHooks = function(entryPoint) {
        if (hooks[entryPoint]) {
            hooks[entryPoint] = [];
        }
    };

    /**
     * removeAllHooks
     * Public method to remove all DOMPurify hooks
     *
     * @return void
     */
    DOMPurify.removeAllHooks = function() {
        hooks = {};
    };

    return DOMPurify;
}));
}, {}];
window.modules["528"] = [function(require,module,exports){exports.removeElement = function(elem){
	if(elem.prev) elem.prev.next = elem.next;
	if(elem.next) elem.next.prev = elem.prev;

	if(elem.parent){
		var childs = elem.parent.children;
		childs.splice(childs.lastIndexOf(elem), 1);
	}
};

exports.replaceElement = function(elem, replacement){
	var prev = replacement.prev = elem.prev;
	if(prev){
		prev.next = replacement;
	}

	var next = replacement.next = elem.next;
	if(next){
		next.prev = replacement;
	}

	var parent = replacement.parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs[childs.lastIndexOf(elem)] = replacement;
	}
};

exports.appendChild = function(elem, child){
	child.parent = elem;

	if(elem.children.push(child) !== 1){
		var sibling = elem.children[elem.children.length - 2];
		sibling.next = child;
		child.prev = sibling;
		child.next = null;
	}
};

exports.append = function(elem, next){
	var parent = elem.parent,
		currNext = elem.next;

	next.next = currNext;
	next.prev = elem;
	elem.next = next;
	next.parent = parent;

	if(currNext){
		currNext.prev = next;
		if(parent){
			var childs = parent.children;
			childs.splice(childs.lastIndexOf(currNext), 0, next);
		}
	} else if(parent){
		parent.children.push(next);
	}
};

exports.prepend = function(elem, prev){
	var parent = elem.parent;
	if(parent){
		var childs = parent.children;
		childs.splice(childs.lastIndexOf(elem), 0, prev);
	}

	if(elem.prev){
		elem.prev.next = prev;
	}
	
	prev.parent = parent;
	prev.prev = elem.prev;
	prev.next = elem;
	elem.prev = prev;
};


}, {}];
window.modules["541"] = [function(require,module,exports){'use strict';

var curve = require(534);
var BN = require(252);
var inherits = require(259);
var Base = curve.base;

var elliptic = require(309);
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};
}, {"252":252,"259":259,"309":309,"534":534}];
window.modules["533"] = [function(require,module,exports){module.exports={
  "_from": "elliptic@^6.0.0",
  "_id": "elliptic@6.4.1",
  "_inBundle": false,
  "_integrity": "sha512-BsXLz5sqX8OHcsh7CqBMztyXARmGQ3LWPtGjJi6DiJHq5C/qvi9P3OqgswKSDftbu8+IoI/QDTAm2fFnQ9SZSQ==",
  "_location": "/elliptic",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "elliptic@^6.0.0",
    "name": "elliptic",
    "escapedName": "elliptic",
    "rawSpec": "^6.0.0",
    "saveSpec": null,
    "fetchSpec": "^6.0.0"
  },
  "_requiredBy": [
    "/browserify-sign",
    "/create-ecdh"
  ],
  "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.4.1.tgz",
  "_shasum": "c2d0b7776911b86722c632c3c06c60f2f819939a",
  "_spec": "elliptic@^6.0.0",
  "_where": "/Users/snash/workspace/sites/node_modules/browserify-sign",
  "author": {
    "name": "Fedor Indutny",
    "email": "fedor@indutny.com"
  },
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "bn.js": "^4.4.0",
    "brorand": "^1.0.1",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.0",
    "inherits": "^2.0.1",
    "minimalistic-assert": "^1.0.0",
    "minimalistic-crypto-utils": "^1.0.0"
  },
  "deprecated": false,
  "description": "EC cryptography",
  "devDependencies": {
    "brfs": "^1.4.3",
    "coveralls": "^2.11.3",
    "grunt": "^0.4.5",
    "grunt-browserify": "^5.0.0",
    "grunt-cli": "^1.2.0",
    "grunt-contrib-connect": "^1.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^1.0.1",
    "grunt-mocha-istanbul": "^3.0.1",
    "grunt-saucelabs": "^8.6.2",
    "istanbul": "^0.4.2",
    "jscs": "^2.9.0",
    "jshint": "^2.6.0",
    "mocha": "^2.1.0"
  },
  "files": [
    "lib"
  ],
  "homepage": "https://github.com/indutny/elliptic",
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "license": "MIT",
  "main": "lib/elliptic.js",
  "name": "elliptic",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/indutny/elliptic.git"
  },
  "scripts": {
    "jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
    "jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
    "lint": "npm run jscs && npm run jshint",
    "test": "npm run lint && npm run unit",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "version": "grunt dist && git add dist/"
  },
  "version": "6.4.1"
}
}, {}];
window.modules["560"] = [function(require,module,exports){/*
 * Copyright (C) 2018 Alasdair Mercer, !ninja
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

'use strict';

/**
 * The available digits for hexadecimal values.
 *
 * @type {string[]}
 */
const hexDigits = '0123456789abcdef'.split('');

/**
 * Parses the specified Unicode character found within the input string and calculate the hexadecimal representation of
 * its Unicode code point.
 *
 * @param {string} ch - the character to be parsed to calculate the hexadecimal segment of the Unicode escape
 * @return {string} The calculated Unicode code point in its hexadecimal representation.
 */
function parse(ch) {
  const code = ch.codePointAt(0);

  return toHexDigit((code >> 12) & 15) +
    toHexDigit((code >> 8) & 15) +
    toHexDigit((code >> 4) & 15) +
    toHexDigit(code & 15);
}

/**
 * Converts the specified <code>nibble</code> into a hexadecimal digit.
 *
 * @param {number} nibble - the nibble to be converted
 * @return {string} The single-digit hexadecimal string.
 */
function toHexDigit(nibble) {
  return hexDigits[nibble & 15];
}

module.exports = parse;
}, {}];
window.modules["565"] = [function(require,module,exports){"use strict";

const util = require(564);

const convertToJson =function(node, options) {
    const jObj = {};

    if ((!node.child  ||  util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {
        return util.isExist(node.val) ? node.val : "";
    } else {
        if (util.isExist(node.val)) {
            if (!(typeof node.val === "string" && (node.val === "" || node.val === options.cdataPositionChar))) {
                jObj[options.textNodeName] = node.val;
            }
        }
    }

    util.merge(jObj, node.attrsMap);

    const keys = Object.keys(node.child);
    for (let index = 0; index < keys.length; index++) {
        var tagname = keys[index];
        if (node.child[tagname] && node.child[tagname].length > 1) {
            jObj[tagname] = [];
            for (var tag in node.child[tagname]) {
                jObj[tagname].push(convertToJson(node.child[tagname][tag], options));
            }
        } else {
            jObj[tagname] = convertToJson(node.child[tagname][0], options);
        }
    }
    
    //add value
    return jObj;
};

exports.convertToJson = convertToJson;}, {"564":564}];
window.modules["566"] = [function(require,module,exports){"use strict";

const util = require(564);
const buildOptions = require(564).buildOptions;
const x2j = require(567);

//TODO: do it later
const convertToJsonString = function(node, options) {
    options = buildOptions(options,x2j.defaultOptions,x2j.props);

    options.indentBy = options.indentBy || "";
    return _cToJsonStr(node, options,0);
}

const _cToJsonStr = function(node, options,level) {
    let jObj = "{";

    //traver through all the children
    const keys = Object.keys(node.child);
    
    for (let index = 0; index < keys.length; index++) {
        var tagname = keys[index];
        if (node.child[tagname] && node.child[tagname].length > 1) {
            jObj  += "\"" + tagname + "\" : [ ";
            for (var tag in node.child[tagname]) {
                jObj += _cToJsonStr(node.child[tagname][tag], options) + " , ";
            }
            jObj = jObj.substr(0,jObj.length-1) + " ] "; //remove extra comma in last
        } else {
            jObj += "\"" +tagname + "\" : " + _cToJsonStr(node.child[tagname][0], options) + " ,";
        }
    }
    util.merge(jObj, node.attrsMap);
    //add attrsMap as new children
    if (util.isEmptyObject(jObj)) {
        return util.isExist(node.val) ? node.val : "";
    } else {
        if (util.isExist(node.val)) {
            if (!(typeof node.val === "string" && (node.val === "" || node.val === options.cdataPositionChar))) {
                jObj += "\"" + options.textNodeName +"\" : " + stringval(node.val);
            }
        }
    }
    //add value
    if(jObj[jObj.length-1] === ","){
        jObj = jObj.substr(0,jObj.length-2);
    }
    return jObj + "}";
};

function stringval(v){
    if(v === true || v === false || !isNaN(v)){
        return v;
    }else{
        return "\"" + v + "\"";
    }
}

function indentate(options, level) {
    return options.indentBy.repeat(level);
}

exports.convertToJsonString = convertToJsonString;}, {"564":564,"567":567}];
window.modules["568"] = [function(require,module,exports){"use strict";
const char = function(a) {
    return String.fromCharCode(a);
};

const chars = {
    nilChar : char(176),
    missingChar : char(201),
    nilPremitive : char(175),
    missingPremitive : char(200),

    emptyChar : char(178),
    emptyValue:  char(177),//empty Premitive
    
    boundryChar : char(179),
    
    objStart: char(198),
    arrStart: char(204),
    arrayEnd: char(185),
};

const charsArr = [
    chars.nilChar,
    chars.nilPremitive,
    chars.missingChar,
    chars.missingPremitive,
    chars.boundryChar,
    chars.emptyChar,
    chars.emptyValue,
    chars.arrayEnd,
    chars.objStart,
    chars.arrStart
];

const _e = function(node, e_schema, options) {
    if (typeof e_schema === "string") {//premitive
        if (node && node[0] && node[0].val !== undefined) {
            return getValue(node[0].val, e_schema);
        } else {
            return getValue(node, e_schema);
        }
    } else {
        const hasValidData = hasData(node);
        if (hasValidData === true) {
            let str = "";
            if (Array.isArray(e_schema)) {
                //attributes can't be repeated. hence check in children tags only
                str += chars.arrStart;
                const itemSchema = e_schema[0];
                //var itemSchemaType = itemSchema;
                const arr_len = node.length;

                if (typeof itemSchema === "string") {
                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {
                        const r = getValue(node[arr_i].val, itemSchema);
                        str = processValue(str, r);
                    }
                } else {
                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {
                        const r = _e(node[arr_i], itemSchema, options);
                        str = processValue(str, r);
                    }
                }
                str += chars.arrayEnd;//indicates that next item is not array item
            } else {//object
                str += chars.objStart;
                const keys = Object.keys(e_schema);
                if (Array.isArray(node)) {
                    node = node[0];
                }
                for (let i in keys) {
                    const key = keys[i];
                    //a property defined in schema can be present either in attrsMap or children tags
                    //options.textNodeName will not present in both maps, take it's value from val
                    //options.attrNodeName will be present in attrsMap
                    let r;
                    if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {
                        r = _e(node.attrsMap[key], e_schema[key], options);
                    } else if (key === options.textNodeName) {
                        r = _e(node.val, e_schema[key], options);
                    } else {
                        r = _e(node.child[key], e_schema[key], options);
                    }
                    str = processValue(str, r);
                }
            }
            return str;
        } else {
            return hasValidData;
        }
    }
};

const getValue = function(a/*, type*/) {
    switch (a) {
        case undefined:
            return chars.missingPremitive;
        case null:
            return chars.nilPremitive;
        case "":
            return chars.emptyValue;
        default:
            return a;
    }
};

const processValue = function(str, r) {
    if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {
        str += chars.boundryChar;
    }
    return str + r;
};

const isAppChar = function(ch) {
    return charsArr.indexOf(ch) !== -1;
};

function hasData(jObj) {
    if (jObj === undefined) {
        return chars.missingChar;
    } else if (jObj === null) {
        return chars.nilChar;
    } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {
        return chars.emptyChar;
    } else {
        return true;
    }
}

const x2j = require(567);
const buildOptions = require(564).buildOptions;

const convert2nimn = function(node, e_schema, options) {
    options = buildOptions(options,x2j.defaultOptions,x2j.props);
    return _e(node, e_schema, options);
};

exports.convert2nimn = convert2nimn;
}, {"564":564,"567":567}];
window.modules["569"] = [function(require,module,exports){"use strict";

const nodeToJson = require(565);
const xmlToNodeobj = require(567);
const x2j = require(567);
const buildOptions = require(564).buildOptions;

exports.parse = function(xmlData, options) {
    options = buildOptions(options,x2j.defaultOptions,x2j.props);
    return nodeToJson.convertToJson(xmlToNodeobj.getTraversalObj(xmlData, options), options);
};
exports.convertTonimn = require(568).convert2nimn;
exports.getTraversalObj = xmlToNodeobj.getTraversalObj;
exports.convertToJson = nodeToJson.convertToJson;
exports.convertToJsonString = require(566).convertToJsonString;
exports.validate = require(570).validate;
exports.j2xParser = require(563);
exports.parseToNimn = function (xmlData,schema,options){
    return exports.convertTonimn(exports.getTraversalObj(xmlData,options), schema, options);
};
}, {"563":563,"564":564,"565":565,"566":566,"567":567,"568":568,"570":570}];
window.modules["597"] = [function(require,module,exports){var Tokenizer = require(598);

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var formTags = {
	input: true,
	option: true,
	optgroup: true,
	select: true,
	button: true,
	datalist: true,
	textarea: true
};

var openImpliesClose = {
	tr      : { tr:true, th:true, td:true },
	th      : { th:true },
	td      : { thead:true, th:true, td:true },
	body    : { head:true, link:true, script:true },
	li      : { li:true },
	p       : { p:true },
	h1      : { p:true },
	h2      : { p:true },
	h3      : { p:true },
	h4      : { p:true },
	h5      : { p:true },
	h6      : { p:true },
	select  : formTags,
	input   : formTags,
	output  : formTags,
	button  : formTags,
	datalist: formTags,
	textarea: formTags,
	option  : { option:true },
	optgroup: { optgroup:true }
};

var voidElements = {
	__proto__: null,
	area: true,
	base: true,
	basefont: true,
	br: true,
	col: true,
	command: true,
	embed: true,
	frame: true,
	hr: true,
	img: true,
	input: true,
	isindex: true,
	keygen: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,
};

var foreignContextElements = {
	__proto__: null,
	math: true,
	svg: true
}
var htmlIntegrationElements = {
	__proto__: null,
	mi: true,
	mo: true,
	mn: true,
	ms: true,
	mtext: true,
	"annotation-xml": true,
	foreignObject: true,
	desc: true,
	title: true
}

var re_nameEnd = /\s|\//;

function Parser(cbs, options){
	this._options = options || {};
	this._cbs = cbs || {};

	this._tagname = "";
	this._attribname = "";
	this._attribvalue = "";
	this._attribs = null;
	this._stack = [];
	this._foreignContext = [];

	this.startIndex = 0;
	this.endIndex = null;

	this._lowerCaseTagNames = "lowerCaseTags" in this._options ?
		!!this._options.lowerCaseTags :
		!this._options.xmlMode;
	this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ?
		!!this._options.lowerCaseAttributeNames :
		!this._options.xmlMode;

	if(this._options.Tokenizer) {
		Tokenizer = this._options.Tokenizer;
	}
	this._tokenizer = new Tokenizer(this._options, this);

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
}

require(259)(Parser, require(561).EventEmitter);

Parser.prototype._updatePosition = function(initialOffset){
	if(this.endIndex === null){
		if(this._tokenizer._sectionStart <= initialOffset){
			this.startIndex = 0;
		} else {
			this.startIndex = this._tokenizer._sectionStart - initialOffset;
		}
	}
	else this.startIndex = this.endIndex + 1;
	this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
Parser.prototype.ontext = function(data){
	this._updatePosition(1);
	this.endIndex--;

	if(this._cbs.ontext) this._cbs.ontext(data);
};

Parser.prototype.onopentagname = function(name){
	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	this._tagname = name;

	if(!this._options.xmlMode && name in openImpliesClose) {
		for(
			var el;
			(el = this._stack[this._stack.length - 1]) in openImpliesClose[name];
			this.onclosetag(el)
		);
	}

	if(this._options.xmlMode || !(name in voidElements)){
		this._stack.push(name);
		if(name in foreignContextElements) this._foreignContext.push(true);
		else if(name in htmlIntegrationElements) this._foreignContext.push(false);
	}

	if(this._cbs.onopentagname) this._cbs.onopentagname(name);
	if(this._cbs.onopentag) this._attribs = {};
};

Parser.prototype.onopentagend = function(){
	this._updatePosition(1);

	if(this._attribs){
		if(this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
		this._attribs = null;
	}

	if(!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements){
		this._cbs.onclosetag(this._tagname);
	}

	this._tagname = "";
};

Parser.prototype.onclosetag = function(name){
	this._updatePosition(1);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	if(this._stack.length && (!(name in voidElements) || this._options.xmlMode)){
		var pos = this._stack.lastIndexOf(name);
		if(pos !== -1){
			if(this._cbs.onclosetag){
				pos = this._stack.length - pos;
				while(pos--) this._cbs.onclosetag(this._stack.pop());
			}
			else this._stack.length = pos;
		} else if(name === "p" && !this._options.xmlMode){
			this.onopentagname(name);
			this._closeCurrentTag();
		}
	} else if(!this._options.xmlMode && (name === "br" || name === "p")){
		this.onopentagname(name);
		this._closeCurrentTag();
	}
};

Parser.prototype.onselfclosingtag = function(){
	if(this._options.xmlMode || this._options.recognizeSelfClosing
		|| this._foreignContext[this._foreignContext.length - 1]){
		this._closeCurrentTag();
	} else {
		this.onopentagend();
	}
};

Parser.prototype._closeCurrentTag = function(){
	var name = this._tagname;

	this.onopentagend();

	//self-closing tags will be on the top of the stack
	//(cheaper check than in onclosetag)
	if(this._stack[this._stack.length - 1] === name){
		if(this._cbs.onclosetag){
			this._cbs.onclosetag(name);
		}
		this._stack.pop();
		if((name in foreignContextElements) || (name in htmlIntegrationElements)){
			this._foreignContext.pop();
		}
	}
};

Parser.prototype.onattribname = function(name){
	if(this._lowerCaseAttributeNames){
		name = name.toLowerCase();
	}
	this._attribname = name;
};

Parser.prototype.onattribdata = function(value){
	this._attribvalue += value;
};

Parser.prototype.onattribend = function(){
	if(this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
	if(
		this._attribs &&
		!Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)
	){
		this._attribs[this._attribname] = this._attribvalue;
	}
	this._attribname = "";
	this._attribvalue = "";
};

Parser.prototype._getInstructionName = function(value){
	var idx = value.search(re_nameEnd),
	    name = idx < 0 ? value : value.substr(0, idx);

	if(this._lowerCaseTagNames){
		name = name.toLowerCase();
	}

	return name;
};

Parser.prototype.ondeclaration = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("!" + name, "!" + value);
	}
};

Parser.prototype.onprocessinginstruction = function(value){
	if(this._cbs.onprocessinginstruction){
		var name = this._getInstructionName(value);
		this._cbs.onprocessinginstruction("?" + name, "?" + value);
	}
};

Parser.prototype.oncomment = function(value){
	this._updatePosition(4);

	if(this._cbs.oncomment) this._cbs.oncomment(value);
	if(this._cbs.oncommentend) this._cbs.oncommentend();
};

Parser.prototype.oncdata = function(value){
	this._updatePosition(1);

	if(this._options.xmlMode || this._options.recognizeCDATA){
		if(this._cbs.oncdatastart) this._cbs.oncdatastart();
		if(this._cbs.ontext) this._cbs.ontext(value);
		if(this._cbs.oncdataend) this._cbs.oncdataend();
	} else {
		this.oncomment("[CDATA[" + value + "]]");
	}
};

Parser.prototype.onerror = function(err){
	if(this._cbs.onerror) this._cbs.onerror(err);
};

Parser.prototype.onend = function(){
	if(this._cbs.onclosetag){
		for(
			var i = this._stack.length;
			i > 0;
			this._cbs.onclosetag(this._stack[--i])
		);
	}
	if(this._cbs.onend) this._cbs.onend();
};


//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset = function(){
	if(this._cbs.onreset) this._cbs.onreset();
	this._tokenizer.reset();

	this._tagname = "";
	this._attribname = "";
	this._attribs = null;
	this._stack = [];

	if(this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete = function(data){
	this.reset();
	this.end(data);
};

Parser.prototype.write = function(chunk){
	this._tokenizer.write(chunk);
};

Parser.prototype.end = function(chunk){
	this._tokenizer.end(chunk);
};

Parser.prototype.pause = function(){
	this._tokenizer.pause();
};

Parser.prototype.resume = function(){
	this._tokenizer.resume();
};

//alias for backwards compat
Parser.prototype.parseChunk = Parser.prototype.write;
Parser.prototype.done = Parser.prototype.end;

module.exports = Parser;
}, {"259":259,"561":561,"598":598}];
window.modules["599"] = [function(require,module,exports){module.exports = ProxyHandler;

function ProxyHandler(cbs){
	this._cbs = cbs || {};
}

var EVENTS = require(594).EVENTS;
Object.keys(EVENTS).forEach(function(name){
	if(EVENTS[name] === 0){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(){
			if(this._cbs[name]) this._cbs[name]();
		};
	} else if(EVENTS[name] === 1){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a){
			if(this._cbs[name]) this._cbs[name](a);
		};
	} else if(EVENTS[name] === 2){
		name = "on" + name;
		ProxyHandler.prototype[name] = function(a, b){
			if(this._cbs[name]) this._cbs[name](a, b);
		};
	} else {
		throw Error("wrong number of arguments");
	}
});}, {"594":594}];
window.modules["623"] = [function(require,module,exports){'use strict';


var common = require(622);


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;
}, {"622":622}];
window.modules["635"] = [function(require,module,exports){'use strict';

var Type = require(613);

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});
}, {"613":613}];
window.modules["632"] = [function(require,module,exports){'use strict';

var Type = require(613);

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});
}, {"613":613}];
window.modules["637"] = [function(require,module,exports){'use strict';

var Type = require(613);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});
}, {"613":613}];
window.modules["628"] = [function(require,module,exports){'use strict';

var Type = require(613);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
}, {"613":613}];
window.modules["629"] = [function(require,module,exports){'use strict';

var Type = require(613);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
}, {"613":613}];
window.modules["37"] = [function(require,module,exports){var arrayMap = require(696),
    baseIteratee = require(780),
    baseMap = require(791),
    isArray = require(129);

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;
}, {"129":129,"696":696,"780":780,"791":791}];
window.modules["178"] = [function(require,module,exports){var baseAssignValue = require(707),
    baseForOwn = require(733),
    baseIteratee = require(780);

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;
}, {"707":707,"733":733,"780":780}];
window.modules["29"] = [function(require,module,exports){var baseExtremum = require(738),
    baseGt = require(755),
    identity = require(781);

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseGt)
    : undefined;
}

module.exports = max;
}, {"738":738,"755":755,"781":781}];
window.modules["61"] = [function(require,module,exports){var baseExtremum = require(738),
    baseGt = require(755),
    baseIteratee = require(780);

/**
 * This method is like `_.max` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.maxBy(objects, function(o) { return o.n; });
 * // => { 'n': 2 }
 *
 * // The `_.property` iteratee shorthand.
 * _.maxBy(objects, 'n');
 * // => { 'n': 2 }
 */
function maxBy(array, iteratee) {
  return (array && array.length)
    ? baseExtremum(array, baseIteratee(iteratee, 2), baseGt)
    : undefined;
}

module.exports = maxBy;
}, {"738":738,"755":755,"780":780}];
window.modules["35"] = [function(require,module,exports){var MapCache = require(663);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;
}, {"663":663}];
window.modules["904"] = [function(require,module,exports){var baseMerge = require(798),
    createAssigner = require(846);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;
}, {"798":798,"846":846}];
window.modules["905"] = [function(require,module,exports){var baseExtremum = require(738),
    baseLt = require(790),
    identity = require(781);

/**
 * Computes the minimum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * _.min([4, 2, 8, 6]);
 * // => 2
 *
 * _.min([]);
 * // => undefined
 */
function min(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseLt)
    : undefined;
}

module.exports = min;
}, {"738":738,"781":781,"790":790}];
window.modules["62"] = [function(require,module,exports){var baseExtremum = require(738),
    baseIteratee = require(780),
    baseLt = require(790);

/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * // The `_.property` iteratee shorthand.
 * _.minBy(objects, 'n');
 * // => { 'n': 1 }
 */
function minBy(array, iteratee) {
  return (array && array.length)
    ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)
    : undefined;
}

module.exports = minBy;
}, {"738":738,"780":780,"790":790}];
window.modules["906"] = [function(require,module,exports){/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that negates the result of the predicate `func`. The
 * `func` predicate is invoked with the `this` binding and arguments of the
 * created function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0;
 * }
 *
 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
 * // => [1, 3, 5]
 */
function negate(predicate) {
  if (typeof predicate != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0: return !predicate.call(this);
      case 1: return !predicate.call(this, args[0]);
      case 2: return !predicate.call(this, args[0], args[1]);
      case 3: return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}

module.exports = negate;
}, {}];
window.modules["864"] = [function(require,module,exports){/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;
}, {}];
window.modules["892"] = [function(require,module,exports){var root = require(644);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;
}, {"644":644}];
window.modules["121"] = [function(require,module,exports){var arrayMap = require(696),
    baseClone = require(716),
    baseUnset = require(814),
    castPath = require(749),
    copyObject = require(711),
    customOmitClone = require(865),
    flatRest = require(856),
    getAllKeysIn = require(718);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

module.exports = omit;
}, {"696":696,"711":711,"716":716,"718":718,"749":749,"814":814,"856":856,"865":865}];
window.modules["158"] = [function(require,module,exports){var baseIteratee = require(780),
    negate = require(906),
    pickBy = require(59);

/**
 * The opposite of `_.pickBy`; this method creates an object composed of
 * the own and inherited enumerable string keyed properties of `object` that
 * `predicate` doesn't return truthy for. The predicate is invoked with two
 * arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omitBy(object, _.isNumber);
 * // => { 'b': '2' }
 */
function omitBy(object, predicate) {
  return pickBy(object, negate(baseIteratee(predicate)));
}

module.exports = omitBy;
}, {"59":59,"780":780,"906":906}];
window.modules["161"] = [function(require,module,exports){var before = require(889);

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before(2, func);
}

module.exports = once;
}, {"889":889}];
window.modules["193"] = [function(require,module,exports){var createPadding = require(860),
    stringSize = require(861),
    toInteger = require(890),
    toString = require(833);

/**
 * Pads `string` on the right side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padEnd('abc', 6);
 * // => 'abc   '
 *
 * _.padEnd('abc', 6, '_-');
 * // => 'abc_-_'
 *
 * _.padEnd('abc', 3);
 * // => 'abc'
 */
function padEnd(string, length, chars) {
  string = toString(string);
  length = toInteger(length);

  var strLength = length ? stringSize(string) : 0;
  return (length && strLength < length)
    ? (string + createPadding(length - strLength, chars))
    : string;
}

module.exports = padEnd;
}, {"833":833,"860":860,"861":861,"890":890}];
window.modules["195"] = [function(require,module,exports){var createPadding = require(860),
    stringSize = require(861),
    toInteger = require(890),
    toString = require(833);

/**
 * Pads `string` on the left side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padStart('abc', 6);
 * // => '   abc'
 *
 * _.padStart('abc', 6, '_-');
 * // => '_-_abc'
 *
 * _.padStart('abc', 3);
 * // => 'abc'
 */
function padStart(string, length, chars) {
  string = toString(string);
  length = toInteger(length);

  var strLength = length ? stringSize(string) : 0;
  return (length && strLength < length)
    ? (createPadding(length - strLength, chars) + string)
    : string;
}

module.exports = padStart;
}, {"833":833,"860":860,"861":861,"890":890}];
window.modules["108"] = [function(require,module,exports){var root = require(644),
    toString = require(833);

/** Used to match leading and trailing whitespace. */
var reTrimStart = /^\s+/;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeParseInt = root.parseInt;

/**
 * Converts `string` to an integer of the specified radix. If `radix` is
 * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
 * hexadecimal, in which case a `radix` of `16` is used.
 *
 * **Note:** This method aligns with the
 * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category String
 * @param {string} string The string to convert.
 * @param {number} [radix=10] The radix to interpret `value` by.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.parseInt('08');
 * // => 8
 *
 * _.map(['6', '08', '10'], _.parseInt);
 * // => [6, 8, 10]
 */
function parseInt(string, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
}

module.exports = parseInt;
}, {"644":644,"833":833}];
window.modules["174"] = [function(require,module,exports){var basePick = require(808),
    flatRest = require(856);

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;
}, {"808":808,"856":856}];
window.modules["59"] = [function(require,module,exports){var arrayMap = require(696),
    baseIteratee = require(780),
    basePickBy = require(809),
    getAllKeysIn = require(718);

/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}

module.exports = pickBy;
}, {"696":696,"718":718,"780":780,"809":809}];
window.modules["782"] = [function(require,module,exports){var baseProperty = require(702),
    basePropertyDeep = require(811),
    isKey = require(795),
    toKey = require(750);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;
}, {"702":702,"750":750,"795":795,"811":811}];
window.modules["194"] = [function(require,module,exports){/*!
 * mezr v0.6.2
 * https://github.com/niklasramo/mezr
 * Copyright (c) 2016 Niklas Rm <inramo@gmail.com>
 * Released under the MIT license
 */

(function (global, factory) {

  if (typeof define === 'function' && define.amd) {
    define([], function () {
      return factory(global);
    });
  }
  else if (typeof module === 'object' && module.exports) {
    module.exports = factory(global);
  }
  else {
    global.mezr = factory(global);
  }

}(this, function (global, undefined) {

  'use strict';

  // Make sure we received a valid window object from the arguments.
  var win = global.document && global.self === global.document.defaultView ? global : window;

  // Cache document, root and body elements.
  var doc = win.document;
  var root = doc.documentElement;
  var body = doc.body;

  // Throw error if body is not available
  if (!body) {
    throw Error('Mezr needs access to body element.');
  }

  // Cache some often used native functions.
  var abs = Math.abs;
  var max = Math.max;
  var min = Math.min;

  // String to number mappings for element edges.
  var edges = {
    content: 1,
    padding: 2,
    scroll: 3,
    border: 4,
    margin: 5
  };

  // CSS display values which make it impossible for an element to have a
  // scrollbar.
  var unscrollableDisplayValues = ['inline', 'table-column', 'table-column-group'];

  // Temporary bounding client rect data.
  var tempBCR;

  // Mezr settings.
  var settings = {};

  // Default options for place method.
  settings.placeDefaultOptions = {
    element: null,
    target: null,
    position: 'left top left top',
    offsetX: 0,
    offsetY: 0,
    contain: null,
    adjust: null
  };

  // Get the primary supported transform property.
  settings.transform = getSupportedTransform();

  // Check if transformed elements leak fixed elements? According W3C
  // specification (about transform rendering) a transformed element should
  // contain fixed elements, but not every browser follows the spec. So we need
  // to test it.
  settings.transformLeaksFixed = doesTransformLeakFixed();

  /**
   * Public methods
   * **************
   */

  /**
   * Returns the width of an element in pixels. Accepts also the window object
   * (for getting the viewport width) and the document object (for getting the
   * document width) in place of element.
   *
   * @example
   * mezr.width(elemA, 'content');
   *
   * @public
   * @param {(Document|Element|Window)} el
   * @param {Edge} [edge='border']
   * @returns {Number}
   *   - The return value may be fractional when calculating the width of an
   *     element. For window and document objects the value is always an integer
   *     though.
   */
  function getWidth(el, edge) {

    edge = edge && edges[edge] || 4;

    return getDimension('width', el, edge > 1, edge > 2, edge > 3, edge > 4);

  }

  /**
   * Returns the height of an element in pixels. Accepts also the window object
   * (for getting the viewport height) and the document object (for getting the
   * document height) in place of element.
   *
   * @example
   * mezr.height(elemA, 'content');
   *
   * @public
   * @param {(Document|Element|Window)} el
   * @param {Edge} [edge='border']
   * @returns {Number}
   *   - The return value may be fractional when calculating the width of an
   *     element. For window and document objects the value is always an integer
   *     though.
   */
  function getHeight(el, edge) {

    edge = edge && edges[edge] || 4;

    return getDimension('height', el, edge > 1, edge > 2, edge > 3, edge > 4);

  }

  /**
   * Returns the element's offset from another element, window or document. In
   * practice the offset means the vertical and horizontal distance from the
   * comparison element's northwest corner to the target element's northwest
   * corner. By default the comparison element is considered to be the document.
   *
   * @example
   * // Returns offset from document's northwest corner to elemA's content
   * // layer's northwest corner.
   * mezr.offset(elemA, 'content');
   *
   * @example
   * // Returns offset from window's northwest corner to elemA's content layer's
   * // northwest corner.
   * mezr.offset([elemA, 'content'], window);
   *
   * @example
   * // Returns offset from elemB's margin layer's northwest corner to elemA's
   * // content layer's northwest corner.
   * mezr.offset([elemA, 'padding'], [elemB, 'margin']);
   *
   * @public
   * @param {(Array|Document|Element|Rectangle|Window)} el
   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']
   *   - If this argument is a string it is considered to be an edge layer
   *     definition for the first argument. Otherwise this is considered to be a
   *     defintion of an element, document or window.
   * @returns {Offset}
   */
  function getOffset(el, edge) {

    // Use default syntax if the element is not an array and the edge is
    // undefined or a string.
    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {
      return getOffsetFromDocument(el, edge);
    }

    // Otherwise assume that two element/document/window defintions were
    // provided and calculate the offset from the second to the first element.
    else {

      var elemA = [].concat(el);
      var elemB = [].concat(edge);
      var offsetA = isPlainObject(el) ? el : getOffsetFromDocument(elemA[0], elemA[1]);
      var offsetB = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);

      return {
        left: offsetA.left - offsetB.left,
        top: offsetA.top - offsetB.top
      };

    }

  }

  /**
   * Returns an object containing the provided element's dimensions and offsets.
   * This is basically a helper method for calculating an element's dimensions
   * and offsets simultaneously. Mimics the native getBoundingClientRect method
   * with the added bonus of allowing to provide the "edge" of the element.
   *
   * @example
   * // Returns rect data for elemA (using the element's "content" layer in the
   * // calculations) with the offset calculated from the document.
   * mezr.offset(elemA, 'content');
   *
   * @example
   * // Returns rect data for elemA (using the element's "content" layer in the
   * // calculations) with the offset calculated from the window.
   * mezr.rect([elemA, 'content'], window);
   *
   * @example
   * // Returns rect data for elemA (using the element's "padding" layer in the
   * // calculations) with the offset calculated from the elemB ("margin"
   * // layer).
   * mezr.rect([elemA, 'padding'], [elemB, 'margin']);
   *
   * @public
   * @param {(Array|Document|Element|Rectangle|Window)} el
   * @param {(Array|Document|Edge|Element|Rectangle|Window)} [edge='border']
   *   - If this argument is a string it is considered to be an edge layer
   *     definition for the first argument. Otherwise this is considered to be a
   *     defintion of an element, document or window.
   * @returns {Rectangle}
   */
  function getRect(el, edge) {

    // Use default syntax if the element is not an array and the edge is
    // undefined or a string.
    if (!Array.isArray(el) && (!edge || typeof edge === 'string')) {
      return getRectInternal(el, edge);
    }

    // Otherwise assume that two element/document/window defintions were
    // provided and calculate the offset from the second to the first element.
    else {

      var elemA = [].concat(el);
      var elemB = [].concat(edge);
      var rect = isPlainObject(el) ? el : getRectInternal(elemA[0], elemA[1]);
      var offsetFrom = isPlainObject(edge) ? edge : getOffsetFromDocument(elemB[0], elemB[1]);

      rect.left = rect.left - offsetFrom.left;
      rect.top = rect.top - offsetFrom.top;

      return rect;

    }

  }

  /**
   * Returns the element's containing block, which is considered to be the
   * closest ancestor element (or window, or document, or the target element
   * itself) that the target element's positioning is relative to. In other
   * words, containing block is the element the target element's CSS properties
   * "left", "right", "top" and "bottom" are relative to. You should not confuse
   * this with the native elem.offsetParent read-only property, which works in a
   * similar fashion (and even identically in certain situations), but is really
   * not the same thing (although the name might imply it).
   *
   * The logic:
   * - Document is considered to be the root containing block of all elements
   *   and the window. Getting the document's containing block will return null.
   * - Static element does not have a containing block since setting values to
   *   the "left", "right", "top" and "bottom" CSS properties does not have any
   *   effect on the element's position. Thus, getting the containing block of a
   *   static element will return null.
   * - Relative element's containing block is always the element itself.
   * - Fixed element's containing block is always the closest transformed
   *   ancestor or window if the element does not have any transformed
   *   ancestors. An exception is made for browsers which allow fixed elements
   *   to bypass the W3C specification of transform rendering. In those browsers
   *   fixed element's containing block is always the window.
   * - Absolute element's containing block is the closest ancestor element that
   *   is transformed or positioned (any element which is not static), or
   *   document if no positioned or transformed ancestor is not found.
   * - Sticky element is a special case since "left", "right", "top" and
   *   "bottom" CSS properties do not always affect the element's position.
   *   However, for consistency, the closest scrolling ancestor element is
   *   always considered as sticky element's containing block, and if no
   *   scrolling ancestor is found window is returned.
   * - Root element and body element are considered as equals with all other
   *   elements and are treated equally with all other elements.
   *
   * @example
   * mezr.containingBlock(elemA);
   *
   * @example
   * mezr.containingBlock(elemA, 'fixed');
   *
   * @public
   * @param {(Document|Element|Window)} el
   * @param {String} [fakePosition]
   *   - An optional argument which allows you to get the element's containing
   *     block as if the element had this CSS position value applied. Using this
   *     argument does not modify the element's true CSS position in any way,
   *     it's only used for the calculations.
   * @returns {?(Document|Element|Window)}
   */
  function getContainingBlock(el, fakePosition) {

    var ret;
    var scrollProps;
    var parent;
    var style;
    var i;

    // If we have document return null right away.
    if (el === doc) {
      return null;
    }

    // If we have window return document right away.
    if (el === win) {
      return doc;
    }

    // Now that we know we have an element in our hands, let's get it's
    // position. Get element's current position value if a specific position is
    // not provided.
    var position = fakePosition || getStyle(el, 'position');

    // Relative element's container is always the element itself.
    if (position === 'relative') {
      return el;
    }

    // If the element is fixed or absolute positioned.
    else if (position === 'fixed' || position === 'absolute') {

      // If the element is fixed and transforms leak fixed elements, always
      // return window.
      if (position === 'fixed' && settings.transformLeaksFixed) {
        return win;
      }

      // Alrighty, so now fetch the element's parent (which is document for the
      // root) and set it as the initial containing block. Fallback to null if
      // everything else fails.
      ret = el === root ? doc : el.parentElement || null;

      // If element is fixed positioned: as long as the containing block is an
      // element and is not transformed, try to get the element's parent element
      // and fallback to document.
      if (position === 'fixed') {
        while (ret && ret !== doc && !isTransformed(ret)) {
          ret = ret.parentElement || doc;
        }
        return ret === doc ? win : ret;
      }

      // If the element is absolute positioned: as long as the containing block
      // is an element, is static and is not transformed, try to get the
      // element's parent element and fallback to document.
      else {
        while (ret && ret !== doc && getStyle(ret, 'position') === 'static' && !isTransformed(ret)) {
          ret = ret.parentElement || doc;
        }
        return ret;
      }

    }

    // Sticky element's container is always the closest scrolling ancestor or
    // window.
    else if (position === 'sticky' || position === '-webkit-sticky') {

      scrollProps = ['overflow', 'overflow-y', 'overflow-x'];
      parent = el.parentNode;
      el = null;

      while (!el && parent && parent !== doc) {

        for (i = 0; i < 3; i++) {
          style = getStyle(parent, scrollProps[i]);
          if (style === 'auto' || style === 'scroll') {
            el = parent;
            break;
          }
        }

        if (!el) {
          parent = parent.parentNode;
        }

      }

      return el || win;

    }

    // If the element is static or an invalid position is provided always return
    // null.
    return null;

  }

  /**
   * Calculate the distance between two elements or rectangles. Returns a
   * number. If the elements/rectangles overlap the function returns -1. In
   * other cases the function returns the distance in pixels (fractional)
   * between the the two elements/rectangles.
   *
   * @example
   * mezr.distance(elemA, elemB);
   *
   * @example
   * mezr.distance([elemA, 'padding'], [elemB, 'margin']);

   * @example
   * mezr.distance(elemA, {left: 34, top: 56, width: 100, height: 200});
   *
   * @public
   * @param {(Array|Document|Element|Window|Rectangle)} a
   * @param {(Array|Document|Element|Window|Rectangle)} b
   * @returns {Number}
   */
  function getDistance(a, b) {

    var aRect = getSanitizedRect(a);
    var bRect = getSanitizedRect(b);

    return getIntersection(aRect, bRect) ? -1 : getDistanceBetweenRects(aRect, bRect);

  }

  /**
   * Detect if all of the provided elements overlap and calculate the possible
   * intersection area's dimensions and offsets. If the intersection area exists
   * the function returns an object containing the intersection area's
   * dimensions and offsets. Otherwise null is returned.
   *
   * @example
   * mezr.intersection(elemA, elemB);
   *
   * @example
   * mezr.intersection(elemA, [elemB, 'padding'], {
   *   left: 0,
   *   top: 10,
   *   width: 100,
   *   height: 200
   * });
   *
   * @public
   * @param {...(Array|Document|Element|Window|Rectangle)} el
   * @returns {?Rectangle}
   */
  function getIntersectionMultiple() {

    // Get the initial intersection of the first two items.
    var intersection = getIntersection(arguments[0], arguments[1]);

    // If there are more than two items.
    if (arguments.length > 2) {

      // Loop the arguments until the end or until the intersection is
      // non-existent.
      for (var i = 2; i < arguments.length; ++i) {
        intersection = getIntersection(intersection, arguments[i]);
        if (!intersection) {
          break;
        }
      }

    }

    return intersection;

  }

  /**
   * Calculate how much an element overflows another element per each side.
   *
   * @example
   * mezr.overflow(elemA, elemB);
   *
   * @example
   * mezr.overflow(elemA, [elemB, 'padding']);
   *
   * @public
   * @param {(Array|Document|Element|Window|Rectangle)} elA
   * @param {(Array|Document|Element|Window|Rectangle)} elB
   * @returns {Overflow}
   */
  function getOverflow(elA, elB) {

    var ret = getOverlap(elB, elA);

    return {
      left: -ret.left,
      right: -ret.right,
      top: -ret.top,
      bottom: -ret.bottom
    };

  }

  /**
   * Calculate an element's position (left/top CSS properties) when positioned
   * relative to another element, window or the document.
   *
   * @example
   * var newElementPosition = mezr.place({
   *   element: [elemA, 'content'],
   *   target: [elemB, 'margin'],
   *   position: 'left top center center',
   *   offsetX: -5,
   *   offsetY: '50%',
   *   contain: {
   *     within: [elemC, 'padding'],
   *     onOverflow: {
   *       left: 'forcepush',
   *       right: 'push',
   *       top: 'none',
   *       bottom: 'push'
   *     }
   *   },
   *   adjust: function (position, data) {
   *     position.left -= 1;
   *     position.top += 1;
   *   }
   * });
   *
   * @public
   * @param {PlaceOptions} options
   * @returns {PlaceData}
   */
  function getPlace(options) {

    var ret = {};
    var opts = mergeObjects([settings.placeDefaultOptions, options || {}]);
    var position = typeof opts.position === 'string' ? opts.position.split(' ') : opts.position;
    var eRect = getSanitizedRect(opts.element, true);
    var tRect = getSanitizedRect(opts.target);
    var isContainDefined = isPlainObject(opts.contain);
    var container = isContainDefined && opts.contain.within;
    var overflowAction = isContainDefined && getOverflowAction(opts.contain.onOverflow);
    var overflowFixLeft = 0;
    var overflowFixTop = 0;
    var offsetX = opts.offsetX;
    var offsetY = opts.offsetY;
    var cRect;
    var overlap;
    var eCurrentOffset;

    // Sanitize offsets and check for percentage values.
    offsetX = typeof offsetX === 'string' && offsetX.indexOf('%') > -1 ? toFloat(offsetX) / 100 * eRect.width : toFloat(offsetX);
    offsetY = typeof offsetY === 'string' && offsetY.indexOf('%') > -1 ? toFloat(offsetY) / 100 * eRect.height : toFloat(offsetY);

    // Calculate element's new position (left/top coordinates).
    ret.left = getPlacePosition(position[0], position[2], tRect.width, tRect.left, eRect.width, eRect.left, offsetX);
    ret.top = getPlacePosition(position[1], position[3], tRect.height, tRect.top, eRect.height, eRect.top, offsetY);

    // Update element offset data to match the newly calculated position.
    eRect.left += ret.left;
    eRect.top += ret.top;

    // If container element and overflow action are defined, let's handle
    // container's possible overflow.
    if (container && overflowAction) {

      // Get container rect and overlap data.
      cRect = getSanitizedRect(container);
      overlap = getOverlap(eRect, cRect);

      // Handle horizontal overflow.
      if (overlap.left < 0 || overlap.right < 0) {
        overflowFixLeft = getPlaceOverflowPush(overflowAction, overlap);
        ret.left += overflowFixLeft;
      }

      // Handle vertical overflow.
      if (overlap.top < 0 || overlap.bottom < 0) {
        overflowFixTop = getPlaceOverflowPush(overflowAction, overlap, 1);
        ret.top += overflowFixTop;
      }

    }

    if (typeof opts.adjust === 'function') {

      // Update element's left and right rect data to account for the possible
      // overflow correction.
      if (overflowFixLeft !== 0) {
        eRect.left += overflowFixLeft;
        eRect.right = eRect.left + eRect.width;
      }

      // Update element's top and bottom rect data to account for the possible
      // overflow correction.
      if (overflowFixTop !== 0) {
        eRect.top += overflowFixTop;
        eRect.bottom = eRect.left + eRect.width;
      }

      // Get container rect.
      cRect = container ? cRect || getSanitizedRect(container) : null;

      // Get the element's current offset so we can calculate how much the
      // element moved.
      eCurrentOffset = isPlainObject(opts.element) ? opts.element : getOffsetFromDocument.apply(null, [].concat(opts.element));

      // Calculate overlap data based on the new position.
      overlap = cRect ? getOverlap(eRect, cRect) : null;

      // Provide the final position hash as the first argument (which can be
      // modified and it affects the return value of this method) and all the
      // positioning data as the second argument.
      opts.adjust(ret, {
        elementRect: eRect,
        targetRect: tRect,
        containerRect: cRect,
        shift: {
          left: eRect.left - eCurrentOffset.left,
          top: eRect.top - eCurrentOffset.top
        },
        overflow: !overlap ? null : {
          left: -overlap.left,
          right: -overlap.right,
          top: -overlap.top,
          bottom: -overlap.bottom
        },
        overflowCorrection: {
          left: overflowFixLeft,
          top: overflowFixTop
        }
      });

    }

    return ret;

  }

  /**
   * Private helper functions
   * ************************
   */

  /**
   * Check if a value is a plain object.
   *
   * @private
   * @param {*} val
   * @returns {Boolean}
   */
  function isPlainObject(val) {

    return typeof val === 'object' && Object.prototype.toString.call(val) === '[object Object]';

  }

  /**
   * Returns the supported transform property's prefix, property name and style
   * name or null if transforms are not supported.
   *
   * @private
   * @returns {?Object}
   */
  function getSupportedTransform() {

    var transforms = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];

    for (var i = 0; i < transforms.length; i++) {
      if (root.style[transforms[i]] !== undefined) {

        var prop = transforms[i];
        var prefix = prop.toLowerCase().split('transform')[0];

        return {
          prefix: prefix,
          propName: prop,
          styleName: prefix ? '-' + prefix + '-transform' : prop
        };

      }
    }

    return null;

  }

  /**
   * Detects if transformed elements leak fixed elements. According W3C
   * transform rendering spec a transformed element should contain even fixed
   * elements. Meaning that fixed elements are positioned relative to the
   * closest transformed ancestor element instead of window. However, not every
   * browser follows the spec (IE and older Firefox), so we need to test it.
   * https://www.w3.org/TR/css3-2d-transforms/#transform-rendering
   *
   * @private
   * @returns {Boolean}
   *   - Returns true if transformed elements leak fixed elements, false
   *     otherwise.
   */
  function doesTransformLeakFixed() {

    if (!settings.transform) {
      return true;
    }

    var outer = doc.createElement('div');
    var inner = doc.createElement('div');
    var leftNotTransformed;
    var leftTransformed;

    setStyles(outer, {
      display: 'block',
      visibility: 'hidden',
      position: 'absolute',
      width: '1px',
      height: '1px',
      left: '1px',
      top: '0',
      margin: '0'
    });

    setStyles(inner, {
      display: 'block',
      position: 'fixed',
      width: '1px',
      height: '1px',
      left: '0',
      top: '0',
      margin: '0'
    });

    outer.appendChild(inner);
    body.appendChild(outer);
    leftNotTransformed = inner.getBoundingClientRect().left;
    outer.style[settings.transform.propName] = 'translateX(0)';
    leftTransformed = inner.getBoundingClientRect().left;
    body.removeChild(outer);

    return leftTransformed === leftNotTransformed;

  }

  /**
   * Returns true if element is transformed, false if not. In practice the
   * element's display value must be anything else than "none" or "inline" as
   * well as have a valid transform value applied in order to be counted as a
   * transformed element.
   *
   * @private
   * @param {Element} el
   * @returns {Boolean}
   */
  function isTransformed(el) {

    var transform = getStyle(el, settings.transform.styleName);
    var display = getStyle(el, 'display');

    return transform !== 'none' && display !== 'inline' && display !== 'none';

  }

  /**
   * Customized parseFloat function which returns 0 instead of NaN.
   *
   * @private
   * @param {Number|String} val
   * @returns {Number}
   */
  function toFloat(val) {

    return parseFloat(val) || 0;

  }

  /**
   * Deep merge an array of objects into a new object.
   *
   * @private
   * @param {Array} array
   * @returns {Object}
   */
  function mergeObjects(array) {

    var ret = {};
    var propName;
    var propVal;

    for (var i = 0, len = array.length; i < len; i++) {
      for (propName in array[i]) {
        if (array[i].hasOwnProperty(propName)) {
          propVal = array[i][propName];
          ret[propName] = isPlainObject(propVal) ? mergeObjects([propVal]) :
                          Array.isArray(propVal) ? propVal.slice() :
                                                   propVal;
        }
      }
    }

    return ret;

  }

  /**
   * Returns the computed value of an element's style property as a string.
   *
   * @private
   * @param {Element} el
   * @param {String} style
   * @returns {String}
   */
  function getStyle(el, style) {

    return win.getComputedStyle(el, null).getPropertyValue(style);

  }

  /**
   * Returns the computed value of an element's style property transformed into
   * a float value.
   *
   * @private
   * @param {Element} el
   * @param {String} style
   * @returns {Number}
   */
  function getStyleAsFloat(el, style) {

    return toFloat(getStyle(el, style));

  }

  /**
   * Set inline styles to an element.
   *
   * @private
   * @param {Element} el
   * @param {Object} styles
   */
  function setStyles(el, styles) {

    Object.keys(styles).forEach(function (styleName) {
      el.style[styleName] = styles[styleName];
    });

  }

  /**
   * Calculates how much element overlaps another element from each side.
   *
   * @private
   * @param {(Array|Document|Element|Window|Rectangle)} elA
   * @param {(Array|Document|Element|Window|Rectangle)} elB
   * @returns {Overlap}
   */
  function getOverlap(elA, elB) {

    var aRect = getSanitizedRect(elA);
    var bRect = getSanitizedRect(elB);

    return {
      left: aRect.left - bRect.left,
      right: (bRect.left + bRect.width) - (aRect.left + aRect.width),
      top: aRect.top - bRect.top,
      bottom: (bRect.top + bRect.height) - (aRect.top + aRect.height)
    };

  }

  /**
   * Detect if two elements overlap and calculate the possible intersection
   * area's dimensions and offsets. If the intersection area exists the function
   * returns an object containing the intersection area's dimensions and
   * offsets. Otherwise null is returned.
   *
   * @private
   * @param {(Array|Document|Element|Window|Rectangle)} elA
   * @param {(Array|Document|Element|Window|Rectangle)} elB
   * @returns {?RectangleExtended}
   */
  function getIntersection(elA, elB) {

    var ret = {};
    var aRect = getSanitizedRect(elA);
    var bRect = getSanitizedRect(elB);
    var overlap = getOverlap(aRect, bRect);
    var intWidth = max(aRect.width + min(overlap.left, 0) + min(overlap.right, 0), 0);
    var intHeight = max(aRect.height + min(overlap.top, 0) + min(overlap.bottom, 0), 0);
    var hasIntersection = intWidth > 0 && intHeight > 0;

    if (hasIntersection) {
      ret.width = intWidth;
      ret.height = intHeight;
      ret.left = aRect.left + abs(min(overlap.left, 0));
      ret.top = aRect.top + abs(min(overlap.top, 0));
      ret.right = ret.left + ret.width;
      ret.bottom = ret.top + ret.height;
    }

    return hasIntersection ? ret : null;

  }

  /**
   * Calculates the distance between two points in 2D space.
   *
   * @private
   * @param {Number} aLeft
   * @param {Number} aTop
   * @param {Number} bLeft
   * @param {Number} bTop
   * @returns {Number}
   */
  function getDistanceBetweenPoints(aLeft, aTop, bLeft, bTop) {

    return Math.sqrt(Math.pow(bLeft - aLeft, 2) + Math.pow(bTop - aTop, 2));

  }

  /**
   * Calculates the distance between two unrotated rectangles in 2D space. This
   * function assumes that the rectangles do not intersect.
   *
   * @private
   * @param {Rectangle} rectA
   * @param {Rectangle} rectB
   * @returns {Number}
   */
  function getDistanceBetweenRects(rectA, rectB) {

    var ret = 0;
    var aLeft = rectA.left;
    var aRight = aLeft + rectA.width;
    var aTop = rectA.top;
    var aBottom = aTop + rectA.height;
    var bLeft = rectB.left;
    var bRight = bLeft + rectB.width;
    var bTop = rectB.top;
    var bBottom = bTop + rectB.height;

    // Calculate shortest corner distance
    if ((bLeft > aRight || bRight < aLeft) && (bTop > aBottom || bBottom < aTop)) {
      if (bLeft > aRight) {
        ret = bBottom < aTop ? getDistanceBetweenPoints(aRight, aTop, bLeft, bBottom) : getDistanceBetweenPoints(aRight, aBottom, bLeft, bTop);
      }
      else {
        ret = bBottom < aTop ? getDistanceBetweenPoints(aLeft, aTop, bRight, bBottom) : getDistanceBetweenPoints(aLeft, aBottom, bRight, bTop);
      }
    }

    // Calculate shortest edge distance
    else {
      ret = bBottom < aTop ? aTop - bBottom :
            bLeft > aRight ? bLeft - aRight :
            bTop > aBottom ? bTop - aBottom :
            aLeft - bRight;
    }

    return ret;

  }

  /**
   * Returns the height/width of an element in pixels. The function also accepts
   * the window object (for obtaining the viewport dimensions) and the document
   * object (for obtaining the dimensions of the document) in place of element.
   * Note that this function considers root element's scrollbars as the
   * document's and window's scrollbars also. Since the root element's
   * scrollbars are always stuck on the right/bottom edge of the window (even if
   * you specify width and/or height to root element) they are generally
   * referred to as viewport scrollbars in the docs. Also note that only
   * positive margins are included in the result when includeMargin argument is
   * true.
   *
   * @private
   * @param {String} dimension
   *   - Accepts "width" or "height".
   * @param {(Document|Element|Window)} el
   * @param {Boolean} [includePadding=false]
   * @param {Boolean} [includeScrollbar=false]
   * @param {Boolean} [includeBorder=false]
   * @param {Boolean} [includeMargin=false]
   * @returns {Number}
   *   - The return value may be fractional when calculating the width of an
   *     element. For window and document objects the value is always an integer
   *     though.
   */
  function getDimension(dimension, el, includePadding, includeScrollbar, includeBorder, includeMargin) {

    var ret;
    var isHeight = dimension === 'height';
    var dimensionCapitalized = isHeight ? 'Height' : 'Width';
    var innerDimension = 'inner' + dimensionCapitalized;
    var clientDimension = 'client' + dimensionCapitalized;
    var scrollDimension = 'scroll' + dimensionCapitalized;
    var sbSize = 0;
    var edgeA;
    var edgeB;
    var borderA;
    var borderB;
    var marginA;
    var marginB;

    if (el.self === win.self) {

      ret = includeScrollbar ? win[innerDimension] : root[clientDimension];

    }
    else if (el === doc) {

      if (includeScrollbar) {
        sbSize = win[innerDimension] - root[clientDimension];
        ret = max(root[scrollDimension] + sbSize, body[scrollDimension] + sbSize, win[innerDimension]);
      }
      else {
        ret = max(root[scrollDimension], body[scrollDimension], root[clientDimension]);
      }

    }
    else {

      edgeA = isHeight ? 'top' : 'left';
      edgeB = isHeight ? 'bottom' : 'right';
      ret = (tempBCR || el.getBoundingClientRect())[dimension];

      if (!includeScrollbar) {

        if (el === root) {
          sbSize = win[innerDimension] - root[clientDimension];
        }
        else if (unscrollableDisplayValues.indexOf(getStyle(el, 'display')) < 0) {
          borderA = getStyleAsFloat(el, 'border-' + edgeA + '-width');
          borderB = getStyleAsFloat(el, 'border-' + edgeB + '-width');
          sbSize = Math.round(ret) - (el[clientDimension] + borderA + borderB);
        }

        ret -= sbSize > 0 ? sbSize : 0;

      }

      if (!includePadding) {
        ret -= getStyleAsFloat(el, 'padding-' + edgeA);
        ret -= getStyleAsFloat(el, 'padding-' + edgeB);
      }

      if (!includeBorder) {
        ret -= borderA !== undefined ? borderA : getStyleAsFloat(el, 'border-' + edgeA + '-width');
        ret -= borderB !== undefined ? borderB : getStyleAsFloat(el, 'border-' + edgeB + '-width');
      }

      if (includeMargin) {
        marginA = getStyleAsFloat(el, 'margin-' + edgeA);
        marginB = getStyleAsFloat(el, 'margin-' + edgeB);
        ret += marginA > 0 ? marginA : 0;
        ret += marginB > 0 ? marginB : 0;
      }

    }

    return ret > 0 ? ret : 0;

  }

  /**
   * Returns the element's (or window's) document offset, which in practice
   * means the vertical and horizontal distance between the element's northwest
   * corner and the document's northwest corner.
   *
   * @public
   * @param {(Document|Element|Window)} el
   * @param {Edge} [edge='border']
   * @returns {Offset}
   */
  function getOffsetFromDocument(el, edge) {

    var ret = {
      left: 0,
      top: 0
    };

    // Document's offsets are always 0.
    if (el === doc) {
      return ret;
    }

    // Add viewport's scroll left/top to the respective offsets.
    ret.left = win.pageXOffset || 0;
    ret.top = win.pageYOffset || 0;

    // Window's offsets are the viewport's scroll left/top values.
    if (el.self === win.self) {
      return ret;
    }

    // Now we know we are calculating an element's offsets so let's first get
    // the element's bounding client rect. If it is not cached, then just fetch
    // it.
    var gbcr = tempBCR || el.getBoundingClientRect();

    // Add bounding client rect's left/top values to the offsets.
    ret.left += gbcr.left;
    ret.top += gbcr.top;

    // Sanitize edge.
    edge = edge && edges[edge] || 4;

    // Exclude element's positive margin size from the offset if needed.
    if (edge === 5) {
      var marginLeft = getStyleAsFloat(el, 'margin-left');
      var marginTop = getStyleAsFloat(el, 'margin-top');
      ret.left -= marginLeft > 0 ? marginLeft : 0;
      ret.top -= marginTop > 0 ? marginTop : 0;
    }

    // Include element's border size to the offset if needed.
    if (edge < 4) {
      ret.left += getStyleAsFloat(el, 'border-left-width');
      ret.top += getStyleAsFloat(el, 'border-top-width');
    }

    // Include element's padding size to the offset if needed.
    if (edge === 1) {
      ret.left += getStyleAsFloat(el, 'padding-left');
      ret.top += getStyleAsFloat(el, 'padding-top');
    }

    return ret;

  }

  /**
   * Returns an object containing the provided element's dimensions and offsets.
   * This is basically just a wrapper for the getRectInternal function which
   * does some argument normalization before doing the actal calculations. Used
   * only internally.
   *
   * @private
   * @param {(Array|Document|Element|Window|Rectangle)} el
   * @param {Boolean} [useStaticOffset=false]
   * @returns {?Rectangle}
   */
  function getSanitizedRect(el, useStaticOffset) {

    // Can't have an empty value.
    if (!el) {
      return null;
    }

    // Let's assume that plain objects are static rectangle definitions.
    if (isPlainObject(el)) {
      return el;
    }

    // We don't know for sure if the provided element is defined with an edge
    // layer (array syntax) or not. So let's play it safe an normalize the value
    // to an array.
    el = [].concat(el);

    return getRectInternal(el[0], el[1], useStaticOffset);

  }

  /**
   * Returns an object containing the provided element's dimensions and offsets.
   * This is basically a helper method for calculating an element's dimensions
   * and offsets simultaneously. Mimics the native getBoundingClientRect method
   * with the added bonus of allowing to provide the "edge" of the element.
   *
   * @public
   * @param {(Document|Element|Window)} el
   * @param {Edge} [edge='border']
   * @param {Boolean} [useStaticOffset=false]
   * @returns {Rectangle}
   */
  function getRectInternal(el, edge, useStaticOffset) {

    var isElem = el !== doc && el.self !== win.self;
    var rect;

    // Sanitize edge.
    edge = edge || 'border';

    // If static offset is required we have to get it before temporary bounding
    // client rect is cached, since it might need to get the offset of another
    // element than the cached one.
    if (useStaticOffset) {
      rect = getStaticOffset(el, edge);
    }

    // Cache element's bounding client rect.
    if (isElem) {
      tempBCR = el.getBoundingClientRect();
    }

    // If static offset is not required we know for sure that the temporary
    // bounding client rect is the same element we need to get offset for.
    if (!useStaticOffset) {
      rect = getOffsetFromDocument(el, edge);
    }

    // Get element's width and height.
    rect.width = getWidth(el, edge);
    rect.height = getHeight(el, edge);

    // Calculate element's bottom and right.
    rect.bottom = rect.top + rect.height;
    rect.right = rect.left + rect.width;

    // Nullify temporary bounding client rect cache.
    if (isElem) {
      tempBCR = null;
    }

    return rect;

  }

  /**
   * Returns an element's static offset which in this case means the element's
   * offset in a state where the element's left and top CSS properties are set
   * to 0.
   *
   * @private
   * @param {(Document|Element|Window)} el
   * @param {Edge} edge
   * @returns {Offset}
   */
  function getStaticOffset(el, edge) {

    // Sanitize edge.
    edge = edge || 'border';

    // For window and document just return normal offset.
    if (el === win || el === doc) {
      return getOffsetFromDocument(el, edge);
    }

    var position = getStyle(el, 'position');
    var offset = position === 'absolute' || position === 'fixed' ? getOffsetFromDocument(getContainingBlock(el) || doc, 'padding') : getOffsetFromDocument(el, edge);

    if (position === 'relative') {

      var left = getStyle(el, 'left');
      var right = getStyle(el, 'right');
      var top = getStyle(el, 'top');
      var bottom = getStyle(el, 'bottom');

      if (left !== 'auto' || right !== 'auto') {
        offset.left -= left === 'auto' ? -toFloat(right) : toFloat(left);
      }

      if (top !== 'auto' || bottom !== 'auto') {
        offset.top -= top === 'auto' ? -toFloat(bottom) : toFloat(top);
      }

    }
    else if (position === 'absolute' || position === 'fixed') {

      // Get edge number.
      edge = edges[edge];

      // Get left and top margins.
      var marginLeft = getStyleAsFloat(el, 'margin-left');
      var marginTop = getStyleAsFloat(el, 'margin-top');

      // If edge is "margin" remove negative left/top margins from offset to
      // account for their effect on position.
      if (edge === 5) {
        offset.left -= abs(min(marginLeft, 0));
        offset.top -= abs(min(marginTop, 0));
      }

      // If edge is "border" or smaller add positive left/top margins and remove
      // negative left/top margins from offset to account for their effect on
      // position.
      if (edge < 5) {
        offset.left += marginLeft;
        offset.top += marginTop;
      }

      // If edge is "scroll" or smaller add left/top borders to offset to
      // account for their effect on position.
      if (edge < 4) {
        offset.left += getStyleAsFloat(el, 'border-left-width');
        offset.top += getStyleAsFloat(el, 'border-top-width');
      }

      // If edge is "content" add left/top paddings to offset to account for
      // their effect on position.
      if (edge === 1) {
        offset.left += getStyleAsFloat(el, 'padding-left');
        offset.top += getStyleAsFloat(el, 'padding-top');
      }

    }

    return offset;

  }

  /**
   * Returns the horizontal or vertical base position of an element relative to
   * the target element. In other words, this function returns the left and top
   * CSS values which should be set as to the target element in order to
   * position it according to the desired position.
   *
   * @private
   * @param {String} elementPosition
   *   - Element's position: "left", "right", "top", "bottom" or "center".
   * @param {String} targetPosition
   *   - Target's position: "left", "right", "top", "bottom" or "center".
   * @param {Number} targetSize
   *   - Target's width/height in pixels.
   * @param {Number} targetOffset
   *   - Target's left/top offset in pixels.
   * @param {Number} elementSize
   *   - Element's width/height in pixels.
   * @param {Number} elementNwOffset
   *   - Element's left/top northwest offset in pixels.
   * @param {Number} extraOffset
   *   - Additional left/top offset in pixels.
   * @returns {Number}
   */
  function getPlacePosition(elementPosition, targetPosition, targetSize, targetOffset, elementSize, elementNwOffset, extraOffset) {

    var placement = elementPosition.charAt(0) + targetPosition.charAt(0);
    var northwestPoint = targetOffset + extraOffset - elementNwOffset;

    return placement === 'll' || placement === 'tt' ? northwestPoint :
           placement === 'lc' || placement === 'tc' ? northwestPoint + (targetSize / 2) :
           placement === 'lr' || placement === 'tb' ? northwestPoint + targetSize :
           placement === 'cl' || placement === 'ct' ? northwestPoint - (elementSize / 2) :
           placement === 'cr' || placement === 'cb' ? northwestPoint + targetSize - (elementSize / 2) :
           placement === 'rl' || placement === 'bt' ? northwestPoint - elementSize :
           placement === 'rc' || placement === 'bc' ? northwestPoint - elementSize + (targetSize / 2) :
           placement === 'rr' || placement === 'bb' ? northwestPoint - elementSize + targetSize :
                                                      northwestPoint + (targetSize / 2) - (elementSize / 2);

  }

  /**
   * Calculates the distance in pixels that the element needs to be moved in
   * order to be aligned correctly if the target element overlaps the container.
   *
   * @private
   * @param {OverflowConfig} overflowConfig
   * @param {Overlap} targetOverlap
   * @param {Boolean} isVertical
   * @returns {Number}
   */
  function getPlaceOverflowPush(overflowConfig, targetOverlap, isVertical) {

    var ret = 0;
    var push = 'push';
    var forcePush = 'forcepush';
    var sideA = isVertical ? 'top' : 'left';
    var sideB = isVertical ? 'bottom' : 'right';
    var sideAConfig = overflowConfig[sideA];
    var sideBConfig = overflowConfig[sideB];
    var sideAOverlap = targetOverlap[sideA];
    var sideBOverlap = targetOverlap[sideB];
    var sizeDifference = sideAOverlap + sideBOverlap;

    // If pushing is needed from both sides.
    if ((sideAConfig === push || sideAConfig === forcePush) && (sideBConfig === push || sideBConfig === forcePush) && (sideAOverlap < 0 || sideBOverlap < 0)) {

      // Do push correction from opposite sides with equal force.
      if (sideAOverlap < sideBOverlap) {
        ret -= sizeDifference < 0 ? sideAOverlap + abs(sizeDifference / 2) : sideAOverlap;
      }

      // Do push correction from opposite sides with equal force.
      if (sideBOverlap < sideAOverlap) {
        ret += sizeDifference < 0 ? sideBOverlap + abs(sizeDifference / 2) : sideBOverlap;
      }

      // Update overlap data.
      sideAOverlap += ret;
      sideBOverlap -= ret;

      // Check if left/top side forced push correction is needed.
      if (sideAConfig === forcePush && sideBConfig !== forcePush && sideAOverlap < 0) {
        ret -= sideAOverlap;
      }

      // Check if right/top side forced push correction is needed.
      if (sideBConfig === forcePush && sideAConfig !== forcePush && sideBOverlap < 0) {
        ret += sideBOverlap;
      }

    }

    // Check if pushing is needed from left or top side only.
    else if ((sideAConfig === forcePush || sideAConfig === push) && sideAOverlap < 0) {
      ret -= sideAOverlap;
    }

    // Check if pushing is needed from right or bottom side only.
    else if ((sideBConfig === forcePush || sideBConfig === push) && sideBOverlap < 0) {
      ret += sideBOverlap;
    }

    return ret;

  }

  /**
   * Sanitize contain.onOverflow option of .place() method.
   *
   * @private
   * @param {OverflowConfig} overflowConfig
   * @returns {?overflowConfigSanitized}
   */
  function getOverflowAction(overflowConfig) {

    var actionType = typeof overflowConfig;
    var left = 'none';
    var right = 'none';
    var top = 'none';
    var bottom = 'none';

    // onOverflow string value is always used for all sides.
    if (actionType === 'string') {
      left = right = top = bottom = overflowConfig;
    }

    // onOverflow object value can have properties that present a side
    // (left/right/top/bottom) or an axis (x/y). Always try to use the side
    // value first and then fallback to axis value. If all else fails fallback
    // to "none".
    else if (actionType === 'object') {
      left = overflowConfig.left || overflowConfig.x || left;
      right = overflowConfig.right || overflowConfig.x || right;
      top = overflowConfig.top || overflowConfig.y || top;
      bottom = overflowConfig.bottom || overflowConfig.y || bottom;
    }

    // If one side (or more) has a value other than "none" we know that the
    // contain option might have an effect on the positioning.
    if (left !== 'none' || right !== 'none' || top !== 'none' || bottom !== 'none') {
      return {
        left: left,
        right: right,
        top: top,
        bottom: bottom
      };
    }

    return null;

  }

  /**
   * Custom type definitions
   * ***********************
   */

  /**
   * The browser's window object.
   *
   * @typedef {Object} Window
   */

  /**
   * The document contained in browser's window object.
   *
   * @typedef {Object} Document
   */

  /**
   * Any HTML element including root and body elements.
   *
   * @typedef {Object} Element
   */

  /**
   * The name of an element's box model edge which allows you to decide which
   * areas of the element you want to include in the calculations. Valid edge
   * values are "content", "padding", "scroll", "border" and "margin", in that
   * specific order. Note that "scroll" is not a valid element edge accroding to
   * W3C spec, but it is used here to define whether or not the scrollbar's size
   * should be included in the calculations. For window and document objects
   * this argument behaves a bit differently since they cannot have any
   * paddings, borders or margins. Only "content" (without vertical scrollbars
   * width) and "scroll" (with vertical scrollbars width) are effective values.
   * "padding" is normalized to "content" while "border" and "margin" are
   * normalized to "scroll".
   *
   * @typedef {String} Edge
   */

  /**
   * @typedef {Object} Rectangle
   * @property {Number} left
   *   - Element's horizontal distance from the left edge of the document.
   * @property {Number} top
   *   - Element's vertical distance from the top edge of the document.
   * @property {Number} height
   *   - Element's height.
   * @property {Number} width
   *   - Element's width.
   */

  /**
   * @typedef {Object} RectangleExtended
   * @property {Number} left
   *   - Element's horizontal distance from the left edge of the document.
   * @property {Number} right
   *   - Element's horizontal distance from the left edge of the document plus
   *     width.
   * @property {Number} top
   *   - Element's vertical distance from the top edge of the document
   * @property {Number} bottom
   *   - Element's vertical distance from the top edge of the document plus
   *     height.
   * @property {Number} height
   *   - Element's height.
   * @property {Number} width
   *   - Element's width.
   */

  /**
   * @typedef {Object} Offset
   * @property {Number} left
   *   - Element's horizontal distance from the left edge of the document,
   *     window or other element.
   * @property {Number} top
   *   - Element's vertical distance from the top edge of the document, window,
   *     or other element.
   */

  /**
   * @typedef {Object} Overlap
   * @property {Number} left
   * @property {Number} top
   * @property {Number} right
   * @property {Number} bottom
   */

  /**
   * @typedef {Object} Overflow
   * @property {Number} left
   * @property {Number} top
   * @property {Number} right
   * @property {Number} bottom
   */

  /**
   * @typedef {Object} PlaceOptions
   * @param {(Array|Document|Element|Window|Rectangle)} element
   * @property {(Array|Document|Element|Window|Rectangle)} target
   * @property {PlaceOptionsPosition} [position='left top left top']
   * @property {Number} [offsetX=0]
   * @property {Number} [offsetY=0]
   * @property {?PlaceOptionsContainment} [contain=null]
   */

  /**
   * Raw positioning data for position option of .place() method.
   * String syntax: "elemX elemY targetX targetY".
   * Array syntax: ["elemX", "elemY", "targetX", "targetY"].
   * Possible values for elemX and targetX: "left", "center", "right".
   * Possible values for elemY and targetY: "top", "center", "bottom".
   *
   * @typedef {(Array|String)} PlaceOptionsPosition
   */

  /**
   * All properties accepts the following values: "push", "forcepush" and
   * "none".
   *
   * @typedef {Object} PlaceOptionsContainment
   * @property {?(Array|Document|Element|Window|Rectangle)} within
   * @property {?(OverflowConfig|String)} onOverflow
   */

  /**
   * All properties accepts the following values: "push", "forcepush" and
   * "none". The properties left, right, top and bottom are used to define the
   * overflow action that should be called when the positioned element overflows
   * the container element from the respective side. Alternatively you can also
   * use the properties x and y to define the overflow action per axis. If you
   * mix side overflow properties with axis overflow properties remember that
   * the side configuration overwrites the axis configuration.
   *
   * @typedef {Object} OverflowConfig
   * @property {String} [left='none']
   * @property {String} [right='none']
   * @property {String} [top='none']
   * @property {String} [bottom='none']
   * @property {String} [x='none']
   * @property {String} [y='none']
   */

  /**
   * A sanitized configuration data object for contain.onOverflow option of
   * .place() method.
   *
   * @typedef {Object} OverflowConfigSanitized
   * @property {String} left
   * @property {String} right
   * @property {String} top
   * @property {String} bottom
   */

  /**
   * @typedef {Object} PlaceData
   * @property {Number} left
   *   - Target element's new left position.
   * @property {Number} top
   *   - Target element's new top position.
   */

  // Name and return the public methods.
  return {
    width: getWidth,
    height: getHeight,
    offset: getOffset,
    rect: getRect,
    containingBlock: getContainingBlock,
    distance: getDistance,
    intersection: getIntersectionMultiple,
    overflow: getOverflow,
    place: getPlace,
    _settings: settings
  };

}));
}, {}];
window.modules["514"] = [function(require,module,exports){var bn = require(252);
var brorand = require(273);

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};
}, {"252":252,"273":273}];
window.modules["190"] = [function(require,module,exports){//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));
}, {}];
window.modules["928"] = [function(require,module,exports){(function (Buffer){
var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

function checkBuffer (buf, name) {
  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
    throw new TypeError(name + ' must be a buffer or string')
  }
}

module.exports = function (password, salt, iterations, keylen) {
  checkBuffer(password, 'Password')
  checkBuffer(salt, 'Salt')

  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}

}).call(this,{"isBuffer":require(362)})}, {"362":362}];
window.modules["933"] = [function(require,module,exports){var parse = require(932).syntax.parse;

function getInfo(postcssNode) {
    return {
        postcssNode: postcssNode
    };
}

function appendChildren(cssoNode, nodes) {
    cssoNode.children.fromArray(nodes.map(postcssToCsso));
    return cssoNode;
}

function parseToCsso(css, config, postcssNode) {
    var cssoNode;

    try {
        cssoNode = parse(css || '', config);
    } catch (e) {
        if (e.name === 'CssSyntaxError') {
            throw postcssNode.error(e.message, { index: e.offset });
        }

        throw e;
    }

    cssoNode.loc = getInfo(postcssNode);

    return cssoNode;
}

function postcssToCsso(node) {
    switch (node.type) {
        case 'root':
            return appendChildren(
                parseToCsso('', { context: 'stylesheet' }, node),
                node.nodes
            );

        case 'rule':
            return {
                type: 'Rule',
                loc: getInfo(node),
                selector: parseToCsso(node.selector, { context: 'selectorList' }, node),
                block: appendChildren(
                    parseToCsso('{}', { context: 'block' }, node),
                    node.nodes
                )
            };

        case 'atrule':
            var cssoNode = {
                type: 'Atrule',
                loc: getInfo(node),
                name: node.name,
                expression: node.params
                    ? parseToCsso(node.params, { context: 'atruleExpression', atrule: node.name }, node)
                    : null,
                block: null
            };

            if (node.nodes) {
                cssoNode.block = appendChildren(
                    parseToCsso('{}', { context: 'block' }, node),
                    node.nodes
                );
            }

            return cssoNode;

        case 'decl':
            return parseToCsso(
                (node.raws.before || '').trimLeft() + node.toString(),
                { context: 'declaration' },
                node
            );

        case 'comment':
            return {
                type: 'Comment',
                loc: getInfo(node),
                value: node.raws.left + node.text + node.raws.right
            };
    }
}

module.exports = postcssToCsso;
}, {"932":932}];
window.modules["956"] = [function(require,module,exports){function packNumber(value) {
    // 100 -> '100'
    // 00100 -> '100'
    // +100 -> '100'
    // -100 -> '-100'
    // 0.123 -> '.123'
    // 0.12300 -> '.123'
    // 0.0 -> ''
    // 0 -> ''
    value = String(value).replace(/^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/, '$1$2$3');

    if (value.length === 0 || value === '-') {
        value = '0';
    }

    return value;
};

module.exports = function(node) {
    node.value = packNumber(node.value);
};
module.exports.pack = packNumber;
}, {}];
window.modules["974"] = [function(require,module,exports){var translate = require(378).translate;
var specificity = require(975);

var nonFreezePseudoElements = {
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};
var nonFreezePseudoClasses = {
    'link': true,
    'visited': true,
    'hover': true,
    'active': true,
    'first-letter': true,
    'first-line': true,
    'after': true,
    'before': true
};

module.exports = function freeze(node, usageData) {
    var pseudos = Object.create(null);
    var hasPseudo = false;

    node.selector.children.each(function(simpleSelector) {
        var tagName = '*';
        var scope = 0;

        simpleSelector.children.some(function(node) {
            switch (node.type) {
                case 'ClassSelector':
                    if (usageData && usageData.scopes) {
                        var classScope = usageData.scopes[node.name] || 0;

                        if (scope !== 0 && classScope !== scope) {
                            throw new Error('Selector can\'t has classes from different scopes: ' + translate(simpleSelector));
                        }

                        scope = classScope;
                    }
                    break;

                case 'PseudoClassSelector':
                    var name = node.name.toLowerCase();

                    if (!nonFreezePseudoClasses.hasOwnProperty(name)) {
                        pseudos[name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'PseudoElementSelector':
                    var name = node.name.toLowerCase();

                    if (!nonFreezePseudoElements.hasOwnProperty(name)) {
                        pseudos[name] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'TypeSelector':
                    tagName = node.name.toLowerCase();
                    break;

                case 'AttributeSelector':
                    if (node.flags) {
                        pseudos['[' + node.flags.toLowerCase() + ']'] = true;
                        hasPseudo = true;
                    }
                    break;

                case 'WhiteSpace':
                case 'Combinator':
                    tagName = '*';
                    break;
            }
        });

        simpleSelector.compareMarker = specificity(simpleSelector).toString();
        simpleSelector.id = null; // pre-init property to avoid multiple hidden class
        simpleSelector.id = translate(simpleSelector);

        if (scope) {
            simpleSelector.compareMarker += ':' + scope;
        }

        if (tagName !== '*') {
            simpleSelector.compareMarker += ',' + tagName;
        }
    });

    // add property to all rule nodes to avoid multiple hidden class
    node.pseudoSignature = hasPseudo && Object.keys(pseudos).sort().join(',');
};
}, {"378":378,"975":975}];
window.modules["951"] = [function(require,module,exports){module.exports={
  "_from": "csso@~3.0.0",
  "_id": "csso@3.0.1",
  "_inBundle": false,
  "_integrity": "sha1-FGmvXuLsUJrdrdh3eqDkWstrL1g=",
  "_location": "/postcss-csso/csso",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "csso@~3.0.0",
    "name": "csso",
    "escapedName": "csso",
    "rawSpec": "~3.0.0",
    "saveSpec": null,
    "fetchSpec": "~3.0.0"
  },
  "_requiredBy": [
    "/postcss-csso"
  ],
  "_resolved": "https://registry.npmjs.org/csso/-/csso-3.0.1.tgz",
  "_shasum": "1469af5ee2ec509addadd8777aa0e45acb6b2f58",
  "_spec": "csso@~3.0.0",
  "_where": "/Users/snash/workspace/sites/node_modules/postcss-csso",
  "author": {
    "name": "Sergey Kryzhanovsky",
    "email": "skryzhanovsky@ya.ru",
    "url": "https://github.com/afelix"
  },
  "bugs": {
    "url": "https://github.com/css/csso/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "css-tree": "1.0.0-alpha17"
  },
  "deprecated": false,
  "description": "CSSO (CSS Optimizer) is a CSS minifier with structural optimisations",
  "devDependencies": {
    "browserify": "^13.0.0",
    "coveralls": "^2.11.6",
    "eslint": "^2.2.0",
    "istanbul": "^0.4.2",
    "jscs": "~2.10.0",
    "mocha": "~2.4.2",
    "source-map": "^0.5.6",
    "uglify-js": "^2.6.1"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "eslintConfig": {
    "env": {
      "node": true,
      "mocha": true,
      "es6": true
    },
    "rules": {
      "no-duplicate-case": 2,
      "no-undef": 2,
      "no-unused-vars": [
        2,
        {
          "vars": "all",
          "args": "after-used"
        }
      ]
    }
  },
  "files": [
    "bin",
    "dist/csso-browser.js",
    "lib",
    "HISTORY.md",
    "LICENSE",
    "README.md"
  ],
  "homepage": "https://github.com/css/csso",
  "keywords": [
    "css",
    "minifier",
    "minify",
    "compress",
    "optimisation"
  ],
  "license": "MIT",
  "main": "./lib/index",
  "maintainers": [
    {
      "name": "Roman Dvornov",
      "email": "rdvornov@gmail.com"
    }
  ],
  "name": "csso",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/css/csso.git"
  },
  "scripts": {
    "browserify": "browserify --standalone csso lib/index.js | uglifyjs --compress --mangle -o dist/csso-browser.js",
    "codestyle": "jscs lib test && eslint lib test",
    "codestyle-and-test": "npm run codestyle && npm test",
    "coverage": "istanbul cover _mocha -- -R dot",
    "coveralls": "istanbul cover _mocha --report lcovonly -- -R dot && cat ./coverage/lcov.info | coveralls",
    "gh-pages": "git clone -b gh-pages https://github.com/css/csso.git .gh-pages && npm run browserify && cp dist/csso-browser.js .gh-pages/ && cd .gh-pages && git commit -am \"update\" && git push && cd .. && rm -rf .gh-pages",
    "hydrogen": "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/csso --stat -o /dev/null",
    "prepublish": "npm run browserify",
    "test": "mocha --reporter dot",
    "travis": "npm run codestyle-and-test && npm run coveralls"
  },
  "version": "3.0.1"
}
}, {}];
window.modules["993"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _jsBase = require(610);

var _sourceMap = require(995);

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _path = require(924);

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MapGenerator = function () {
    function MapGenerator(stringify, root, opts) {
        _classCallCheck(this, MapGenerator);

        this.stringify = stringify;
        this.mapOpts = opts.map || {};
        this.root = root;
        this.opts = opts;
    }

    MapGenerator.prototype.isMap = function isMap() {
        if (typeof this.opts.map !== 'undefined') {
            return !!this.opts.map;
        } else {
            return this.previous().length > 0;
        }
    };

    MapGenerator.prototype.previous = function previous() {
        var _this = this;

        if (!this.previousMaps) {
            this.previousMaps = [];
            this.root.walk(function (node) {
                if (node.source && node.source.input.map) {
                    var map = node.source.input.map;
                    if (_this.previousMaps.indexOf(map) === -1) {
                        _this.previousMaps.push(map);
                    }
                }
            });
        }

        return this.previousMaps;
    };

    MapGenerator.prototype.isInline = function isInline() {
        if (typeof this.mapOpts.inline !== 'undefined') {
            return this.mapOpts.inline;
        }

        var annotation = this.mapOpts.annotation;
        if (typeof annotation !== 'undefined' && annotation !== true) {
            return false;
        }

        if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.inline;
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.isSourcesContent = function isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== 'undefined') {
            return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.withContent();
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.clearAnnotation = function clearAnnotation() {
        if (this.mapOpts.annotation === false) return;

        var node = void 0;
        for (var i = this.root.nodes.length - 1; i >= 0; i--) {
            node = this.root.nodes[i];
            if (node.type !== 'comment') continue;
            if (node.text.indexOf('# sourceMappingURL=') === 0) {
                this.root.removeChild(i);
            }
        }
    };

    MapGenerator.prototype.setSourcesContent = function setSourcesContent() {
        var _this2 = this;

        var already = {};
        this.root.walk(function (node) {
            if (node.source) {
                var from = node.source.input.from;
                if (from && !already[from]) {
                    already[from] = true;
                    var relative = _this2.relative(from);
                    _this2.map.setSourceContent(relative, node.source.input.css);
                }
            }
        });
    };

    MapGenerator.prototype.applyPrevMaps = function applyPrevMaps() {
        for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var prev = _ref;

            var from = this.relative(prev.file);
            var root = prev.root || _path2.default.dirname(prev.file);
            var map = void 0;

            if (this.mapOpts.sourcesContent === false) {
                map = new _sourceMap2.default.SourceMapConsumer(prev.text);
                if (map.sourcesContent) {
                    map.sourcesContent = map.sourcesContent.map(function () {
                        return null;
                    });
                }
            } else {
                map = prev.consumer();
            }

            this.map.applySourceMap(map, from, this.relative(root));
        }
    };

    MapGenerator.prototype.isAnnotation = function isAnnotation() {
        if (this.isInline()) {
            return true;
        } else if (typeof this.mapOpts.annotation !== 'undefined') {
            return this.mapOpts.annotation;
        } else if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.annotation;
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.addAnnotation = function addAnnotation() {
        var content = void 0;

        if (this.isInline()) {
            content = 'data:application/json;base64,' + _jsBase.Base64.encode(this.map.toString());
        } else if (typeof this.mapOpts.annotation === 'string') {
            content = this.mapOpts.annotation;
        } else {
            content = this.outputFile() + '.map';
        }

        var eol = '\n';
        if (this.css.indexOf('\r\n') !== -1) eol = '\r\n';

        this.css += eol + '/*# sourceMappingURL=' + content + ' */';
    };

    MapGenerator.prototype.outputFile = function outputFile() {
        if (this.opts.to) {
            return this.relative(this.opts.to);
        } else if (this.opts.from) {
            return this.relative(this.opts.from);
        } else {
            return 'to.css';
        }
    };

    MapGenerator.prototype.generateMap = function generateMap() {
        this.generateString();
        if (this.isSourcesContent()) this.setSourcesContent();
        if (this.previous().length > 0) this.applyPrevMaps();
        if (this.isAnnotation()) this.addAnnotation();

        if (this.isInline()) {
            return [this.css];
        } else {
            return [this.css, this.map];
        }
    };

    MapGenerator.prototype.relative = function relative(file) {
        if (file.indexOf('<') === 0) return file;
        if (/^\w+:\/\//.test(file)) return file;

        var from = this.opts.to ? _path2.default.dirname(this.opts.to) : '.';

        if (typeof this.mapOpts.annotation === 'string') {
            from = _path2.default.dirname(_path2.default.resolve(from, this.mapOpts.annotation));
        }

        file = _path2.default.relative(from, file);
        if (_path2.default.sep === '\\') {
            return file.replace(/\\/g, '/');
        } else {
            return file;
        }
    };

    MapGenerator.prototype.sourcePath = function sourcePath(node) {
        if (this.mapOpts.from) {
            return this.mapOpts.from;
        } else {
            return this.relative(node.source.input.from);
        }
    };

    MapGenerator.prototype.generateString = function generateString() {
        var _this3 = this;

        this.css = '';
        this.map = new _sourceMap2.default.SourceMapGenerator({ file: this.outputFile() });

        var line = 1;
        var column = 1;

        var lines = void 0,
            last = void 0;
        this.stringify(this.root, function (str, node, type) {
            _this3.css += str;

            if (node && type !== 'end') {
                if (node.source && node.source.start) {
                    _this3.map.addMapping({
                        source: _this3.sourcePath(node),
                        generated: { line: line, column: column - 1 },
                        original: {
                            line: node.source.start.line,
                            column: node.source.start.column - 1
                        }
                    });
                } else {
                    _this3.map.addMapping({
                        source: '<no source>',
                        original: { line: 1, column: 0 },
                        generated: { line: line, column: column - 1 }
                    });
                }
            }

            lines = str.match(/\n/g);
            if (lines) {
                line += lines.length;
                last = str.lastIndexOf('\n');
                column = str.length - last;
            } else {
                column += str.length;
            }

            if (node && type !== 'start') {
                if (node.source && node.source.end) {
                    _this3.map.addMapping({
                        source: _this3.sourcePath(node),
                        generated: { line: line, column: column - 1 },
                        original: {
                            line: node.source.end.line,
                            column: node.source.end.column
                        }
                    });
                } else {
                    _this3.map.addMapping({
                        source: '<no source>',
                        original: { line: 1, column: 0 },
                        generated: { line: line, column: column - 1 }
                    });
                }
            }
        });
    };

    MapGenerator.prototype.generate = function generate() {
        this.clearAnnotation();

        if (this.isMap()) {
            return this.generateMap();
        } else {
            var result = '';
            this.stringify(this.root, function (i) {
                result += i;
            });
            return [result];
        }
    };

    return MapGenerator;
}();

exports.default = MapGenerator;
module.exports = exports['default'];

}, {"610":610,"924":924,"995":995}];
window.modules["980"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _cssSyntaxError = require(985);

var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);

var _stringifier = require(996);

var _stringifier2 = _interopRequireDefault(_stringifier);

var _stringify = require(991);

var _stringify2 = _interopRequireDefault(_stringify);

var _warnOnce = require(977);

var _warnOnce2 = _interopRequireDefault(_warnOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cloneNode = function cloneNode(obj, parent) {
    var cloned = new obj.constructor();

    for (var i in obj) {
        if (!obj.hasOwnProperty(i)) continue;
        var value = obj[i];
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

        if (i === 'parent' && type === 'object') {
            if (parent) cloned[i] = parent;
        } else if (i === 'source') {
            cloned[i] = value;
        } else if (value instanceof Array) {
            cloned[i] = value.map(function (j) {
                return cloneNode(j, cloned);
            });
        } else if (i !== 'before' && i !== 'after' && i !== 'between' && i !== 'semicolon') {
            if (type === 'object' && value !== null) value = cloneNode(value);
            cloned[i] = value;
        }
    }

    return cloned;
};

/**
 * All node classes inherit the following common methods.
 *
 * @abstract
 */

var Node = function () {

    /**
     * @param {object} [defaults] - value for node properties
     */
    function Node() {
        var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Node);

        this.raws = {};
        if ((typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) !== 'object' && typeof defaults !== 'undefined') {
            throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));
        }
        for (var name in defaults) {
            this[name] = defaults[name];
        }
    }

    /**
     * Returns a CssSyntaxError instance containing the original position
     * of the node in the source, showing line and column numbers and also
     * a small excerpt to facilitate debugging.
     *
     * If present, an input source map will be used to get the original position
     * of the source, even from a previous compilation step
     * (e.g., from Sass compilation).
     *
     * This method produces very useful error messages.
     *
     * @param {string} message     - error description
     * @param {object} [opts]      - options
     * @param {string} opts.plugin - plugin name that created this error.
     *                               PostCSS will set it automatically.
     * @param {string} opts.word   - a word inside a nodes string that should
     *                               be highlighted as the source of the error
     * @param {number} opts.index  - an index inside a nodes string that should
     *                               be highlighted as the source of the error
     *
     * @return {CssSyntaxError} error object to throw it
     *
     * @example
     * if ( !variables[name] ) {
     *   throw decl.error('Unknown variable ' + name, { word: name });
     *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
     *   //   color: $black
     *   // a
     *   //          ^
     *   //   background: white
     * }
     */


    Node.prototype.error = function error(message) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (this.source) {
            var pos = this.positionBy(opts);
            return this.source.input.error(message, pos.line, pos.column, opts);
        } else {
            return new _cssSyntaxError2.default(message);
        }
    };

    /**
     * This method is provided as a convenience wrapper for {@link Result#warn}.
     *
     * @param {Result} result      - the {@link Result} instance
     *                               that will receive the warning
     * @param {string} text        - warning message
     * @param {object} [opts]      - options
     * @param {string} opts.plugin - plugin name that created this warning.
     *                               PostCSS will set it automatically.
     * @param {string} opts.word   - a word inside a nodes string that should
     *                               be highlighted as the source of the warning
     * @param {number} opts.index  - an index inside a nodes string that should
     *                               be highlighted as the source of the warning
     *
     * @return {Warning} created warning object
     *
     * @example
     * const plugin = postcss.plugin('postcss-deprecated', () => {
     *   return (root, result) => {
     *     root.walkDecls('bad', decl => {
     *       decl.warn(result, 'Deprecated property bad');
     *     });
     *   };
     * });
     */


    Node.prototype.warn = function warn(result, text, opts) {
        var data = { node: this };
        for (var i in opts) {
            data[i] = opts[i];
        }return result.warn(text, data);
    };

    /**
     * Removes the node from its parent and cleans the parent properties
     * from the node and its children.
     *
     * @example
     * if ( decl.prop.match(/^-webkit-/) ) {
     *   decl.remove();
     * }
     *
     * @return {Node} node to make calls chain
     */


    Node.prototype.remove = function remove() {
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.parent = undefined;
        return this;
    };

    /**
     * Returns a CSS string representing the node.
     *
     * @param {stringifier|syntax} [stringifier] - a syntax to use
     *                                             in string generation
     *
     * @return {string} CSS string of this node
     *
     * @example
     * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
     */


    Node.prototype.toString = function toString() {
        var stringifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _stringify2.default;

        if (stringifier.stringify) stringifier = stringifier.stringify;
        var result = '';
        stringifier(this, function (i) {
            result += i;
        });
        return result;
    };

    /**
     * Returns a clone of the node.
     *
     * The resulting cloned node and its (cloned) children will have
     * a clean parent and code style properties.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @example
     * const cloned = decl.clone({ prop: '-moz-' + decl.prop });
     * cloned.raws.before  //=> undefined
     * cloned.parent       //=> undefined
     * cloned.toString()   //=> -moz-transform: scale(0)
     *
     * @return {Node} clone of the node
     */


    Node.prototype.clone = function clone() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = cloneNode(this);
        for (var name in overrides) {
            cloned[name] = overrides[name];
        }
        return cloned;
    };

    /**
     * Shortcut to clone the node and insert the resulting cloned node
     * before the current node.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @example
     * decl.cloneBefore({ prop: '-moz-' + decl.prop });
     *
     * @return {Node} - new node
     */


    Node.prototype.cloneBefore = function cloneBefore() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
    };

    /**
     * Shortcut to clone the node and insert the resulting cloned node
     * after the current node.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @return {Node} - new node
     */


    Node.prototype.cloneAfter = function cloneAfter() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
    };

    /**
     * Inserts node(s) before the current node and removes the current node.
     *
     * @param {...Node} nodes - node(s) to replace current one
     *
     * @example
     * if ( atrule.name == 'mixin' ) {
     *   atrule.replaceWith(mixinRules[atrule.params]);
     * }
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.replaceWith = function replaceWith() {
        if (this.parent) {
            for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
                nodes[_key] = arguments[_key];
            }

            for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var node = _ref;

                this.parent.insertBefore(this, node);
            }

            this.remove();
        }

        return this;
    };

    /**
     * Removes the node from its current parent and inserts it
     * at the end of `newParent`.
     *
     * This will clean the `before` and `after` code {@link Node#raws} data
     * from the node and replace them with the indentation style of `newParent`.
     * It will also clean the `between` property
     * if `newParent` is in another {@link Root}.
     *
     * @param {Container} newParent - container node where the current node
     *                                will be moved
     *
     * @example
     * atrule.moveTo(atrule.root());
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveTo = function moveTo(newParent) {
        this.cleanRaws(this.root() === newParent.root());
        this.remove();
        newParent.append(this);
        return this;
    };

    /**
     * Removes the node from its current parent and inserts it into
     * a new parent before `otherNode`.
     *
     * This will also clean the nodes code style properties just as it would
     * in {@link Node#moveTo}.
     *
     * @param {Node} otherNode - node that will be before current node
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveBefore = function moveBefore(otherNode) {
        this.cleanRaws(this.root() === otherNode.root());
        this.remove();
        otherNode.parent.insertBefore(otherNode, this);
        return this;
    };

    /**
     * Removes the node from its current parent and inserts it into
     * a new parent after `otherNode`.
     *
     * This will also clean the nodes code style properties just as it would
     * in {@link Node#moveTo}.
     *
     * @param {Node} otherNode - node that will be after current node
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveAfter = function moveAfter(otherNode) {
        this.cleanRaws(this.root() === otherNode.root());
        this.remove();
        otherNode.parent.insertAfter(otherNode, this);
        return this;
    };

    /**
     * Returns the next child of the nodes parent.
     * Returns `undefined` if the current node is the last child.
     *
     * @return {Node|undefined} next node
     *
     * @example
     * if ( comment.text === 'delete next' ) {
     *   const next = comment.next();
     *   if ( next ) {
     *     next.remove();
     *   }
     * }
     */


    Node.prototype.next = function next() {
        var index = this.parent.index(this);
        return this.parent.nodes[index + 1];
    };

    /**
     * Returns the previous child of the nodes parent.
     * Returns `undefined` if the current node is the first child.
     *
     * @return {Node|undefined} previous node
     *
     * @example
     * const annotation = decl.prev();
     * if ( annotation.type == 'comment' ) {
     *  readAnnotation(annotation.text);
     * }
     */


    Node.prototype.prev = function prev() {
        var index = this.parent.index(this);
        return this.parent.nodes[index - 1];
    };

    Node.prototype.toJSON = function toJSON() {
        var fixed = {};

        for (var name in this) {
            if (!this.hasOwnProperty(name)) continue;
            if (name === 'parent') continue;
            var value = this[name];

            if (value instanceof Array) {
                fixed[name] = value.map(function (i) {
                    if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && i.toJSON) {
                        return i.toJSON();
                    } else {
                        return i;
                    }
                });
            } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.toJSON) {
                fixed[name] = value.toJSON();
            } else {
                fixed[name] = value;
            }
        }

        return fixed;
    };

    /**
     * Returns a {@link Node#raws} value. If the node is missing
     * the code style property (because the node was manually built or cloned),
     * PostCSS will try to autodetect the code style property by looking
     * at other nodes in the tree.
     *
     * @param {string} prop          - name of code style property
     * @param {string} [defaultType] - name of default value, it can be missed
     *                                 if the value is the same as prop
     *
     * @example
     * const root = postcss.parse('a { background: white }');
     * root.nodes[0].append({ prop: 'color', value: 'black' });
     * root.nodes[0].nodes[1].raws.before   //=> undefined
     * root.nodes[0].nodes[1].raw('before') //=> ' '
     *
     * @return {string} code style value
     */


    Node.prototype.raw = function raw(prop, defaultType) {
        var str = new _stringifier2.default();
        return str.raw(this, prop, defaultType);
    };

    /**
     * Finds the Root instance of the nodes tree.
     *
     * @example
     * root.nodes[0].nodes[0].root() === root
     *
     * @return {Root} root parent
     */


    Node.prototype.root = function root() {
        var result = this;
        while (result.parent) {
            result = result.parent;
        }return result;
    };

    Node.prototype.cleanRaws = function cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween) delete this.raws.between;
    };

    Node.prototype.positionInside = function positionInside(index) {
        var string = this.toString();
        var column = this.source.start.column;
        var line = this.source.start.line;

        for (var i = 0; i < index; i++) {
            if (string[i] === '\n') {
                column = 1;
                line += 1;
            } else {
                column += 1;
            }
        }

        return { line: line, column: column };
    };

    Node.prototype.positionBy = function positionBy(opts) {
        var pos = this.source.start;
        if (opts.index) {
            pos = this.positionInside(opts.index);
        } else if (opts.word) {
            var index = this.toString().indexOf(opts.word);
            if (index !== -1) pos = this.positionInside(index);
        }
        return pos;
    };

    Node.prototype.removeSelf = function removeSelf() {
        (0, _warnOnce2.default)('Node#removeSelf is deprecated. Use Node#remove.');
        return this.remove();
    };

    Node.prototype.replace = function replace(nodes) {
        (0, _warnOnce2.default)('Node#replace is deprecated. Use Node#replaceWith');
        return this.replaceWith(nodes);
    };

    Node.prototype.style = function style(own, detect) {
        (0, _warnOnce2.default)('Node#style() is deprecated. Use Node#raw()');
        return this.raw(own, detect);
    };

    Node.prototype.cleanStyles = function cleanStyles(keepBetween) {
        (0, _warnOnce2.default)('Node#cleanStyles() is deprecated. Use Node#cleanRaws()');
        return this.cleanRaws(keepBetween);
    };

    _createClass(Node, [{
        key: 'before',
        get: function get() {
            (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');
            return this.raws.before;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');
            this.raws.before = val;
        }
    }, {
        key: 'between',
        get: function get() {
            (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');
            return this.raws.between;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');
            this.raws.between = val;
        }

        /**
         * @memberof Node#
         * @member {string} type - String representing the nodes type.
         *                         Possible values are `root`, `atrule`, `rule`,
         *                         `decl`, or `comment`.
         *
         * @example
         * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
         */

        /**
         * @memberof Node#
         * @member {Container} parent - the nodes parent node.
         *
         * @example
         * root.nodes[0].parent == root;
         */

        /**
         * @memberof Node#
         * @member {source} source - the input source of the node
         *
         * The property is used in source map generation.
         *
         * If you create a node manually (e.g., with `postcss.decl()`),
         * that node will not have a `source` property and will be absent
         * from the source map. For this reason, the plugin developer should
         * consider cloning nodes to create new ones (in which case the new nodes
         * source will reference the original, cloned node) or setting
         * the `source` property manually.
         *
         * ```js
         * // Bad
         * const prefixed = postcss.decl({
         *   prop: '-moz-' + decl.prop,
         *   value: decl.value
         * });
         *
         * // Good
         * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });
         * ```
         *
         * ```js
         * if ( atrule.name == 'add-link' ) {
         *   const rule = postcss.rule({ selector: 'a', source: atrule.source });
         *   atrule.parent.insertBefore(atrule, rule);
         * }
         * ```
         *
         * @example
         * decl.source.input.from //=> '/home/ai/a.sass'
         * decl.source.start      //=> { line: 10, column: 2 }
         * decl.source.end        //=> { line: 10, column: 12 }
         */

        /**
         * @memberof Node#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `after`: the space symbols after the last child of the node
         *   to the end of the node.
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `semicolon`: contains true if the last child has
         *   an (optional) semicolon.
         * * `afterName`: the space between the at-rule name and its parameters.
         * * `left`: the space symbols between `/*` and the comments text.
         * * `right`: the space symbols between the comments text
         *   and <code>*&#47;</code>.
         * * `important`: the content of the important statement,
         *   if it is not just `!important`.
         *
         * PostCSS cleans selectors, declaration values and at-rule parameters
         * from comments and extra spaces, but it stores origin content in raws
         * properties. As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('a {\n  color:black\n}')
         * root.first.first.raws //=> { before: '\n  ', between: ':' }
         */

    }]);

    return Node;
}();

exports.default = Node;

/**
 * @typedef {object} position
 * @property {number} line   - source line in file
 * @property {number} column - source column in file
 */

/**
 * @typedef {object} source
 * @property {Input} input    - {@link Input} with input file
 * @property {position} start - The starting position of the nodes source
 * @property {position} end   - The ending position of the nodes source
 */

module.exports = exports['default'];

}, {"977":977,"985":985,"991":991,"996":996}];
window.modules["982"] = [function(require,module,exports){'use strict';

exports.__esModule = true;
exports.default = parse;

var _parser = require(997);

var _parser2 = _interopRequireDefault(_parser);

var _input = require(988);

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(css, opts) {
    if (opts && opts.safe) {
        throw new Error('Option safe was removed. ' + 'Use parser: require("postcss-safe-parser")');
    }

    var input = new _input2.default(css, opts);

    var parser = new _parser2.default(input);
    try {
        parser.tokenize();
        parser.loop();
    } catch (e) {
        if (e.name === 'CssSyntaxError' && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
                e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';
            } else if (/\.sass/i.test(opts.from)) {
                e.message += '\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';
            } else if (/\.less$/i.test(opts.from)) {
                e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';
            }
        }
        throw e;
    }

    return parser.root;
}
module.exports = exports['default'];

}, {"988":988,"997":997}];
window.modules["997"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _declaration = require(981);

var _declaration2 = _interopRequireDefault(_declaration);

var _tokenize = require(998);

var _tokenize2 = _interopRequireDefault(_tokenize);

var _comment = require(979);

var _comment2 = _interopRequireDefault(_comment);

var _atRule = require(976);

var _atRule2 = _interopRequireDefault(_atRule);

var _root = require(984);

var _root2 = _interopRequireDefault(_root);

var _rule = require(983);

var _rule2 = _interopRequireDefault(_rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Parser = function () {
    function Parser(input) {
        _classCallCheck(this, Parser);

        this.input = input;

        this.pos = 0;
        this.root = new _root2.default();
        this.current = this.root;
        this.spaces = '';
        this.semicolon = false;

        this.root.source = { input: input, start: { line: 1, column: 1 } };
    }

    Parser.prototype.tokenize = function tokenize() {
        this.tokens = (0, _tokenize2.default)(this.input);
    };

    Parser.prototype.loop = function loop() {
        var token = void 0;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];

            switch (token[0]) {

                case 'space':
                case ';':
                    this.spaces += token[1];
                    break;

                case '}':
                    this.end(token);
                    break;

                case 'comment':
                    this.comment(token);
                    break;

                case 'at-word':
                    this.atrule(token);
                    break;

                case '{':
                    this.emptyRule(token);
                    break;

                default:
                    this.other();
                    break;
            }

            this.pos += 1;
        }
        this.endFile();
    };

    Parser.prototype.comment = function comment(token) {
        var node = new _comment2.default();
        this.init(node, token[2], token[3]);
        node.source.end = { line: token[4], column: token[5] };

        var text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
        } else {
            var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
        }
    };

    Parser.prototype.emptyRule = function emptyRule(token) {
        var node = new _rule2.default();
        this.init(node, token[2], token[3]);
        node.selector = '';
        node.raws.between = '';
        this.current = node;
    };

    Parser.prototype.other = function other() {
        var token = void 0;
        var end = false;
        var type = null;
        var colon = false;
        var bracket = null;
        var brackets = [];

        var start = this.pos;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];
            type = token[0];

            if (type === '(' || type === '[') {
                if (!bracket) bracket = token;
                brackets.push(type === '(' ? ')' : ']');
            } else if (brackets.length === 0) {
                if (type === ';') {
                    if (colon) {
                        this.decl(this.tokens.slice(start, this.pos + 1));
                        return;
                    } else {
                        break;
                    }
                } else if (type === '{') {
                    this.rule(this.tokens.slice(start, this.pos + 1));
                    return;
                } else if (type === '}') {
                    this.pos -= 1;
                    end = true;
                    break;
                } else if (type === ':') {
                    colon = true;
                }
            } else if (type === brackets[brackets.length - 1]) {
                brackets.pop();
                if (brackets.length === 0) bracket = null;
            }

            this.pos += 1;
        }
        if (this.pos === this.tokens.length) {
            this.pos -= 1;
            end = true;
        }

        if (brackets.length > 0) this.unclosedBracket(bracket);

        if (end && colon) {
            while (this.pos > start) {
                token = this.tokens[this.pos][0];
                if (token !== 'space' && token !== 'comment') break;
                this.pos -= 1;
            }
            this.decl(this.tokens.slice(start, this.pos + 1));
            return;
        }

        this.unknownWord(start);
    };

    Parser.prototype.rule = function rule(tokens) {
        tokens.pop();

        var node = new _rule2.default();
        this.init(node, tokens[0][2], tokens[0][3]);

        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, 'selector', tokens);
        this.current = node;
    };

    Parser.prototype.decl = function decl(tokens) {
        var node = new _declaration2.default();
        this.init(node);

        var last = tokens[tokens.length - 1];
        if (last[0] === ';') {
            this.semicolon = true;
            tokens.pop();
        }
        if (last[4]) {
            node.source.end = { line: last[4], column: last[5] };
        } else {
            node.source.end = { line: last[2], column: last[3] };
        }

        while (tokens[0][0] !== 'word') {
            node.raws.before += tokens.shift()[1];
        }
        node.source.start = { line: tokens[0][2], column: tokens[0][3] };

        node.prop = '';
        while (tokens.length) {
            var type = tokens[0][0];
            if (type === ':' || type === 'space' || type === 'comment') {
                break;
            }
            node.prop += tokens.shift()[1];
        }

        node.raws.between = '';

        var token = void 0;
        while (tokens.length) {
            token = tokens.shift();

            if (token[0] === ':') {
                node.raws.between += token[1];
                break;
            } else {
                node.raws.between += token[1];
            }
        }

        if (node.prop[0] === '_' || node.prop[0] === '*') {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
        }
        node.raws.between += this.spacesAndCommentsFromStart(tokens);
        this.precheckMissedSemicolon(tokens);

        for (var i = tokens.length - 1; i > 0; i--) {
            token = tokens[i];
            if (token[1] === '!important') {
                node.important = true;
                var string = this.stringFrom(tokens, i);
                string = this.spacesFromEnd(tokens) + string;
                if (string !== ' !important') node.raws.important = string;
                break;
            } else if (token[1] === 'important') {
                var cache = tokens.slice(0);
                var str = '';
                for (var j = i; j > 0; j--) {
                    var _type = cache[j][0];
                    if (str.trim().indexOf('!') === 0 && _type !== 'space') {
                        break;
                    }
                    str = cache.pop()[1] + str;
                }
                if (str.trim().indexOf('!') === 0) {
                    node.important = true;
                    node.raws.important = str;
                    tokens = cache;
                }
            }

            if (token[0] !== 'space' && token[0] !== 'comment') {
                break;
            }
        }

        this.raw(node, 'value', tokens);

        if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);
    };

    Parser.prototype.atrule = function atrule(token) {
        var node = new _atRule2.default();
        node.name = token[1].slice(1);
        if (node.name === '') {
            this.unnamedAtrule(node, token);
        }
        this.init(node, token[2], token[3]);

        var last = false;
        var open = false;
        var params = [];

        this.pos += 1;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];

            if (token[0] === ';') {
                node.source.end = { line: token[2], column: token[3] };
                this.semicolon = true;
                break;
            } else if (token[0] === '{') {
                open = true;
                break;
            } else if (token[0] === '}') {
                this.end(token);
                break;
            } else {
                params.push(token);
            }

            this.pos += 1;
        }
        if (this.pos === this.tokens.length) {
            last = true;
        }

        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, 'params', params);
            if (last) {
                token = params[params.length - 1];
                node.source.end = { line: token[4], column: token[5] };
                this.spaces = node.raws.between;
                node.raws.between = '';
            }
        } else {
            node.raws.afterName = '';
            node.params = '';
        }

        if (open) {
            node.nodes = [];
            this.current = node;
        }
    };

    Parser.prototype.end = function end(token) {
        if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;

        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
        this.spaces = '';

        if (this.current.parent) {
            this.current.source.end = { line: token[2], column: token[3] };
            this.current = this.current.parent;
        } else {
            this.unexpectedClose(token);
        }
    };

    Parser.prototype.endFile = function endFile() {
        if (this.current.parent) this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
    };

    // Helpers

    Parser.prototype.init = function init(node, line, column) {
        this.current.push(node);

        node.source = { start: { line: line, column: column }, input: this.input };
        node.raws.before = this.spaces;
        this.spaces = '';
        if (node.type !== 'comment') this.semicolon = false;
    };

    Parser.prototype.raw = function raw(node, prop, tokens) {
        var token = void 0,
            type = void 0;
        var length = tokens.length;
        var value = '';
        var clean = true;
        for (var i = 0; i < length; i += 1) {
            token = tokens[i];
            type = token[0];
            if (type === 'comment' || type === 'space' && i === length - 1) {
                clean = false;
            } else {
                value += token[1];
            }
        }
        if (!clean) {
            var raw = tokens.reduce(function (all, i) {
                return all + i[1];
            }, '');
            node.raws[prop] = { value: value, raw: raw };
        }
        node[prop] = value;
    };

    Parser.prototype.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {
        var lastTokenType = void 0;
        var spaces = '';
        while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
            spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
    };

    Parser.prototype.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {
        var next = void 0;
        var spaces = '';
        while (tokens.length) {
            next = tokens[0][0];
            if (next !== 'space' && next !== 'comment') break;
            spaces += tokens.shift()[1];
        }
        return spaces;
    };

    Parser.prototype.spacesFromEnd = function spacesFromEnd(tokens) {
        var lastTokenType = void 0;
        var spaces = '';
        while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space') break;
            spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
    };

    Parser.prototype.stringFrom = function stringFrom(tokens, from) {
        var result = '';
        for (var i = from; i < tokens.length; i++) {
            result += tokens[i][1];
        }
        tokens.splice(from, tokens.length - from);
        return result;
    };

    Parser.prototype.colon = function colon(tokens) {
        var brackets = 0;
        var token = void 0,
            type = void 0,
            prev = void 0;
        for (var i = 0; i < tokens.length; i++) {
            token = tokens[i];
            type = token[0];

            if (type === '(') {
                brackets += 1;
            } else if (type === ')') {
                brackets -= 1;
            } else if (brackets === 0 && type === ':') {
                if (!prev) {
                    this.doubleColon(token);
                } else if (prev[0] === 'word' && prev[1] === 'progid') {
                    continue;
                } else {
                    return i;
                }
            }

            prev = token;
        }
        return false;
    };

    // Errors

    Parser.prototype.unclosedBracket = function unclosedBracket(bracket) {
        throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);
    };

    Parser.prototype.unknownWord = function unknownWord(start) {
        var token = this.tokens[start];
        throw this.input.error('Unknown word', token[2], token[3]);
    };

    Parser.prototype.unexpectedClose = function unexpectedClose(token) {
        throw this.input.error('Unexpected }', token[2], token[3]);
    };

    Parser.prototype.unclosedBlock = function unclosedBlock() {
        var pos = this.current.source.start;
        throw this.input.error('Unclosed block', pos.line, pos.column);
    };

    Parser.prototype.doubleColon = function doubleColon(token) {
        throw this.input.error('Double colon', token[2], token[3]);
    };

    Parser.prototype.unnamedAtrule = function unnamedAtrule(node, token) {
        throw this.input.error('At-rule without name', token[2], token[3]);
    };

    Parser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {
        // Hook for Safe Parser
        tokens;
    };

    Parser.prototype.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
        var colon = this.colon(tokens);
        if (colon === false) return;

        var founded = 0;
        var token = void 0;
        for (var j = colon - 1; j >= 0; j--) {
            token = tokens[j];
            if (token[0] !== 'space') {
                founded += 1;
                if (founded === 2) break;
            }
        }
        throw this.input.error('Missed semicolon', token[2], token[3]);
    };

    return Parser;
}();

exports.default = Parser;
module.exports = exports['default'];

}, {"976":976,"979":979,"981":981,"983":983,"984":984,"998":998}];
window.modules["934"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _declaration = require(981);

var _declaration2 = _interopRequireDefault(_declaration);

var _processor = require(1000);

var _processor2 = _interopRequireDefault(_processor);

var _stringify = require(991);

var _stringify2 = _interopRequireDefault(_stringify);

var _comment = require(979);

var _comment2 = _interopRequireDefault(_comment);

var _atRule = require(976);

var _atRule2 = _interopRequireDefault(_atRule);

var _vendor = require(999);

var _vendor2 = _interopRequireDefault(_vendor);

var _parse = require(982);

var _parse2 = _interopRequireDefault(_parse);

var _list = require(994);

var _list2 = _interopRequireDefault(_list);

var _rule = require(983);

var _rule2 = _interopRequireDefault(_rule);

var _root = require(984);

var _root2 = _interopRequireDefault(_root);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create a new {@link Processor} instance that will apply `plugins`
 * as CSS processors.
 *
 * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
 *        plugins. See {@link Processor#use} for plugin format.
 *
 * @return {Processor} Processor to process multiple CSS
 *
 * @example
 * import postcss from 'postcss';
 *
 * postcss(plugins).process(css, { from, to }).then(result => {
 *   console.log(result.css);
 * });
 *
 * @namespace postcss
 */
function postcss() {
  for (var _len = arguments.length, plugins = Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new _processor2.default(plugins);
}

/**
 * Creates a PostCSS plugin with a standard API.
 *
 * The newly-wrapped function will provide both the name and PostCSS
 * version of the plugin.
 *
 * ```js
 *  const processor = postcss([replace]);
 *  processor.plugins[0].postcssPlugin  //=> 'postcss-replace'
 *  processor.plugins[0].postcssVersion //=> '5.1.0'
 * ```
 *
 * The plugin function receives 2 arguments: {@link Root}
 * and {@link Result} instance. The function should mutate the provided
 * `Root` node. Alternatively, you can create a new `Root` node
 * and override the `result.root` property.
 *
 * ```js
 * const cleaner = postcss.plugin('postcss-cleaner', () => {
 *   return (root, result) => {
 *     result.root = postcss.root();
 *   };
 * });
 * ```
 *
 * As a convenience, plugins also expose a `process` method so that you can use
 * them as standalone tools.
 *
 * ```js
 * cleaner.process(css, options);
 * // This is equivalent to:
 * postcss([ cleaner(options) ]).process(css);
 * ```
 *
 * Asynchronous plugins should return a `Promise` instance.
 *
 * ```js
 * postcss.plugin('postcss-import', () => {
 *   return (root, result) => {
 *     return new Promise( (resolve, reject) => {
 *       fs.readFile('base.css', (base) => {
 *         root.prepend(base);
 *         resolve();
 *       });
 *     });
 *   };
 * });
 * ```
 *
 * Add warnings using the {@link Node#warn} method.
 * Send data to other plugins using the {@link Result#messages} array.
 *
 * ```js
 * postcss.plugin('postcss-caniuse-test', () => {
 *   return (root, result) => {
 *     css.walkDecls(decl => {
 *       if ( !caniuse.support(decl.prop) ) {
 *         decl.warn(result, 'Some browsers do not support ' + decl.prop);
 *       }
 *     });
 *   };
 * });
 * ```
 *
 * @param {string} name          - PostCSS plugin name. Same as in `name`
 *                                 property in `package.json`. It will be saved
 *                                 in `plugin.postcssPlugin` property.
 * @param {function} initializer - will receive plugin options
 *                                 and should return {@link pluginFunction}
 *
 * @return {Plugin} PostCSS plugin
 */
postcss.plugin = function plugin(name, initializer) {
  var creator = function creator() {
    var transformer = initializer.apply(undefined, arguments);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new _processor2.default().version;
    return transformer;
  };

  var cache = void 0;
  Object.defineProperty(creator, 'postcss', {
    get: function get() {
      if (!cache) cache = creator();
      return cache;
    }
  });

  creator.process = function (root, opts) {
    return postcss([creator(opts)]).process(root, opts);
  };

  return creator;
};

/**
 * Default function to convert a node tree into a CSS string.
 *
 * @param {Node} node       - start node for stringifing. Usually {@link Root}.
 * @param {builder} builder - function to concatenate CSS from nodes parts
 *                            or generate string and source map
 *
 * @return {void}
 *
 * @function
 */
postcss.stringify = _stringify2.default;

/**
 * Parses source css and returns a new {@link Root} node,
 * which contains the source CSS nodes.
 *
 * @param {string|toString} css   - string with input CSS or any object
 *                                  with toString() method, like a Buffer
 * @param {processOptions} [opts] - options with only `from` and `map` keys
 *
 * @return {Root} PostCSS AST
 *
 * @example
 * // Simple CSS concatenation with source map support
 * const root1 = postcss.parse(css1, { from: file1 });
 * const root2 = postcss.parse(css2, { from: file2 });
 * root1.append(root2).toResult().css;
 *
 * @function
 */
postcss.parse = _parse2.default;

/**
 * @member {vendor} - Contains the {@link vendor} module.
 *
 * @example
 * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']
 */
postcss.vendor = _vendor2.default;

/**
 * @member {list} - Contains the {@link list} module.
 *
 * @example
 * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']
 */
postcss.list = _list2.default;

/**
 * Creates a new {@link Comment} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Comment} new Comment node
 *
 * @example
 * postcss.comment({ text: 'test' })
 */
postcss.comment = function (defaults) {
  return new _comment2.default(defaults);
};

/**
 * Creates a new {@link AtRule} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {AtRule} new AtRule node
 *
 * @example
 * postcss.atRule({ name: 'charset' }).toString() //=> "@charset"
 */
postcss.atRule = function (defaults) {
  return new _atRule2.default(defaults);
};

/**
 * Creates a new {@link Declaration} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Declaration} new Declaration node
 *
 * @example
 * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> "color: red"
 */
postcss.decl = function (defaults) {
  return new _declaration2.default(defaults);
};

/**
 * Creates a new {@link Rule} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {AtRule} new Rule node
 *
 * @example
 * postcss.rule({ selector: 'a' }).toString() //=> "a {\n}"
 */
postcss.rule = function (defaults) {
  return new _rule2.default(defaults);
};

/**
 * Creates a new {@link Root} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Root} new Root node
 *
 * @example
 * postcss.root({ after: '\n' }).toString() //=> "\n"
 */
postcss.root = function (defaults) {
  return new _root2.default(defaults);
};

exports.default = postcss;
module.exports = exports['default'];

}, {"976":976,"979":979,"981":981,"982":982,"983":983,"984":984,"991":991,"994":994,"999":999,"1000":1000}];
window.modules["989"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _jsBase = require(610);

var _sourceMap = require(995);

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _path = require(924);

var _path2 = _interopRequireDefault(_path);

var _fs = require(272);

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Source map information from input CSS.
 * For example, source map after Sass compiler.
 *
 * This class will automatically find source map in input CSS or in file system
 * near input file (according `from` option).
 *
 * @example
 * const root = postcss.parse(css, { from: 'a.sass.css' });
 * root.input.map //=> PreviousMap
 */
var PreviousMap = function () {

    /**
     * @param {string}         css    - input CSS source
     * @param {processOptions} [opts] - {@link Processor#process} options
     */
    function PreviousMap(css, opts) {
        _classCallCheck(this, PreviousMap);

        this.loadAnnotation(css);
        /**
         * @member {boolean} - Was source map inlined by data-uri to input CSS.
         */
        this.inline = this.startWith(this.annotation, 'data:');

        var prev = opts.map ? opts.map.prev : undefined;
        var text = this.loadMap(opts.from, prev);
        if (text) this.text = text;
    }

    /**
     * Create a instance of `SourceMapGenerator` class
     * from the `source-map` library to work with source map information.
     *
     * It is lazy method, so it will create object only on first call
     * and then it will use cache.
     *
     * @return {SourceMapGenerator} object with source map information
     */


    PreviousMap.prototype.consumer = function consumer() {
        if (!this.consumerCache) {
            this.consumerCache = new _sourceMap2.default.SourceMapConsumer(this.text);
        }
        return this.consumerCache;
    };

    /**
     * Does source map contains `sourcesContent` with input source text.
     *
     * @return {boolean} Is `sourcesContent` present
     */


    PreviousMap.prototype.withContent = function withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    };

    PreviousMap.prototype.startWith = function startWith(string, start) {
        if (!string) return false;
        return string.substr(0, start.length) === start;
    };

    PreviousMap.prototype.loadAnnotation = function loadAnnotation(css) {
        var match = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//);
        if (match) this.annotation = match[1].trim();
    };

    PreviousMap.prototype.decodeInline = function decodeInline(text) {
        var utfd64 = 'data:application/json;charset=utf-8;base64,';
        var utf64 = 'data:application/json;charset=utf8;base64,';
        var b64 = 'data:application/json;base64,';
        var uri = 'data:application/json,';

        if (this.startWith(text, uri)) {
            return decodeURIComponent(text.substr(uri.length));
        } else if (this.startWith(text, b64)) {
            return _jsBase.Base64.decode(text.substr(b64.length));
        } else if (this.startWith(text, utf64)) {
            return _jsBase.Base64.decode(text.substr(utf64.length));
        } else if (this.startWith(text, utfd64)) {
            return _jsBase.Base64.decode(text.substr(utfd64.length));
        } else {
            var encoding = text.match(/data:application\/json;([^,]+),/)[1];
            throw new Error('Unsupported source map encoding ' + encoding);
        }
    };

    PreviousMap.prototype.loadMap = function loadMap(file, prev) {
        if (prev === false) return false;

        if (prev) {
            if (typeof prev === 'string') {
                return prev;
            } else if (typeof prev === 'function') {
                var prevPath = prev(file);
                if (prevPath && _fs2.default.existsSync && _fs2.default.existsSync(prevPath)) {
                    return _fs2.default.readFileSync(prevPath, 'utf-8').toString().trim();
                } else {
                    throw new Error('Unable to load previous source map: ' + prevPath.toString());
                }
            } else if (prev instanceof _sourceMap2.default.SourceMapConsumer) {
                return _sourceMap2.default.SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof _sourceMap2.default.SourceMapGenerator) {
                return prev.toString();
            } else if (this.isMap(prev)) {
                return JSON.stringify(prev);
            } else {
                throw new Error('Unsupported previous source map format: ' + prev.toString());
            }
        } else if (this.inline) {
            return this.decodeInline(this.annotation);
        } else if (this.annotation) {
            var map = this.annotation;
            if (file) map = _path2.default.join(_path2.default.dirname(file), map);

            this.root = _path2.default.dirname(map);
            if (_fs2.default.existsSync && _fs2.default.existsSync(map)) {
                return _fs2.default.readFileSync(map, 'utf-8').toString().trim();
            } else {
                return false;
            }
        }
    };

    PreviousMap.prototype.isMap = function isMap(map) {
        if ((typeof map === 'undefined' ? 'undefined' : _typeof(map)) !== 'object') return false;
        return typeof map.mappings === 'string' || typeof map._mappings === 'string';
    };

    return PreviousMap;
}();

exports.default = PreviousMap;
module.exports = exports['default'];

}, {"272":272,"610":610,"924":924,"995":995}];
window.modules["1000"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _lazyResult = require(990);

var _lazyResult2 = _interopRequireDefault(_lazyResult);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * @example
 * const processor = postcss([autoprefixer, precss]);
 * processor.process(css1).then(result => console.log(result.css));
 * processor.process(css2).then(result => console.log(result.css));
 */
var Processor = function () {

  /**
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
   *        plugins. See {@link Processor#use} for plugin format.
   */
  function Processor() {
    var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, Processor);

    /**
     * @member {string} - Current PostCSS version.
     *
     * @example
     * if ( result.processor.version.split('.')[0] !== '5' ) {
     *   throw new Error('This plugin works only with PostCSS 5');
     * }
     */
    this.version = '5.2.18';
    /**
     * @member {pluginFunction[]} - Plugins added to this processor.
     *
     * @example
     * const processor = postcss([autoprefixer, precss]);
     * processor.plugins.length //=> 2
     */
    this.plugins = this.normalize(plugins);
  }

  /**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin created by {@link postcss.plugin} method.
   * * A function. PostCSS will pass the function a @{link Root}
   *   as the first argument and current {@link Result} instance
   *   as the second.
   * * An object with a `postcss` method. PostCSS will use that method
   *   as described in #2.
   * * Another {@link Processor} instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * @param {Plugin|pluginFunction|Processor} plugin - PostCSS plugin
   *                                                   or {@link Processor}
   *                                                   with plugins
   *
   * @example
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(precss);
   *
   * @return {Processes} current processor to make methods chain
   */


  Processor.prototype.use = function use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]));
    return this;
  };

  /**
   * Parses source CSS and returns a {@link LazyResult} Promise proxy.
   * Because some plugins can be asynchronous it doesnt make
   * any transformations. Transformations will be applied
   * in the {@link LazyResult} methods.
   *
   * @param {string|toString|Result} css - String with input CSS or
   *                                       any object with a `toString()`
   *                                       method, like a Buffer.
   *                                       Optionally, send a {@link Result}
   *                                       instance and the processor will
   *                                       take the {@link Root} from it.
   * @param {processOptions} [opts]      - options
   *
   * @return {LazyResult} Promise proxy
   *
   * @example
   * processor.process(css, { from: 'a.css', to: 'a.out.css' })
   *   .then(result => {
   *      console.log(result.css);
   *   });
   */


  Processor.prototype.process = function process(css) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return new _lazyResult2.default(this, css, opts);
  };

  Processor.prototype.normalize = function normalize(plugins) {
    var normalized = [];
    for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var i = _ref;

      if (i.postcss) i = i.postcss;

      if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins);
      } else if (typeof i === 'function') {
        normalized.push(i);
      } else if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && (i.parse || i.stringify)) {
        throw new Error('PostCSS syntaxes cannot be used as plugins. ' + 'Instead, please use one of the ' + 'syntax/parser/stringifier options as ' + 'outlined in your PostCSS ' + 'runner documentation.');
      } else {
        throw new Error(i + ' is not a PostCSS plugin');
      }
    }
    return normalized;
  };

  return Processor;
}();

exports.default = Processor;

/**
 * @callback builder
 * @param {string} part          - part of generated CSS connected to this node
 * @param {Node}   node          - AST node
 * @param {"start"|"end"} [type] - nodes part type
 */

/**
 * @callback parser
 *
 * @param {string|toString} css   - string with input CSS or any object
 *                                  with toString() method, like a Buffer
 * @param {processOptions} [opts] - options with only `from` and `map` keys
 *
 * @return {Root} PostCSS AST
 */

/**
 * @callback stringifier
 *
 * @param {Node} node       - start node for stringifing. Usually {@link Root}.
 * @param {builder} builder - function to concatenate CSS from nodes parts
 *                            or generate string and source map
 *
 * @return {void}
 */

/**
 * @typedef {object} syntax
 * @property {parser} parse          - function to generate AST by string
 * @property {stringifier} stringify - function to generate string by AST
 */

/**
 * @typedef {object} toString
 * @property {function} toString
 */

/**
 * @callback pluginFunction
 * @param {Root} root     - parsed input CSS
 * @param {Result} result - result to set warnings or check other plugins
 */

/**
 * @typedef {object} Plugin
 * @property {function} postcss - PostCSS plugin function
 */

/**
 * @typedef {object} processOptions
 * @property {string} from             - the path of the CSS source file.
 *                                       You should always set `from`,
 *                                       because it is used in source map
 *                                       generation and syntax error messages.
 * @property {string} to               - the path where youll put the output
 *                                       CSS file. You should always set `to`
 *                                       to generate correct source maps.
 * @property {parser} parser           - function to generate AST by string
 * @property {stringifier} stringifier - class to generate string by AST
 * @property {syntax} syntax           - object with `parse` and `stringify`
 * @property {object} map              - source map options
 * @property {boolean} map.inline                    - does source map should
 *                                                     be embedded in the output
 *                                                     CSS as a base64-encoded
 *                                                     comment
 * @property {string|object|false|function} map.prev - source map content
 *                                                     from a previous
 *                                                     processing step
 *                                                     (for example, Sass).
 *                                                     PostCSS will try to find
 *                                                     previous map
 *                                                     automatically, so you
 *                                                     could disable it by
 *                                                     `false` value.
 * @property {boolean} map.sourcesContent            - does PostCSS should set
 *                                                     the origin content to map
 * @property {string|false} map.annotation           - does PostCSS should set
 *                                                     annotation comment to map
 * @property {string} map.from                       - override `from` in maps
 *                                                     `sources`
 */

module.exports = exports['default'];

}, {"990":990}];
window.modules["1007"] = [function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require(1003);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;
}, {"1003":1003}];
window.modules["1034"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _jsBase = require(610);

var _sourceMap = require(1036);

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _path = require(924);

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MapGenerator = function () {
    function MapGenerator(stringify, root, opts) {
        _classCallCheck(this, MapGenerator);

        this.stringify = stringify;
        this.mapOpts = opts.map || {};
        this.root = root;
        this.opts = opts;
    }

    MapGenerator.prototype.isMap = function isMap() {
        if (typeof this.opts.map !== 'undefined') {
            return !!this.opts.map;
        } else {
            return this.previous().length > 0;
        }
    };

    MapGenerator.prototype.previous = function previous() {
        var _this = this;

        if (!this.previousMaps) {
            this.previousMaps = [];
            this.root.walk(function (node) {
                if (node.source && node.source.input.map) {
                    var map = node.source.input.map;
                    if (_this.previousMaps.indexOf(map) === -1) {
                        _this.previousMaps.push(map);
                    }
                }
            });
        }

        return this.previousMaps;
    };

    MapGenerator.prototype.isInline = function isInline() {
        if (typeof this.mapOpts.inline !== 'undefined') {
            return this.mapOpts.inline;
        }

        var annotation = this.mapOpts.annotation;
        if (typeof annotation !== 'undefined' && annotation !== true) {
            return false;
        }

        if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.inline;
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.isSourcesContent = function isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== 'undefined') {
            return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.withContent();
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.clearAnnotation = function clearAnnotation() {
        if (this.mapOpts.annotation === false) return;

        var node = void 0;
        for (var i = this.root.nodes.length - 1; i >= 0; i--) {
            node = this.root.nodes[i];
            if (node.type !== 'comment') continue;
            if (node.text.indexOf('# sourceMappingURL=') === 0) {
                this.root.removeChild(i);
            }
        }
    };

    MapGenerator.prototype.setSourcesContent = function setSourcesContent() {
        var _this2 = this;

        var already = {};
        this.root.walk(function (node) {
            if (node.source) {
                var from = node.source.input.from;
                if (from && !already[from]) {
                    already[from] = true;
                    var relative = _this2.relative(from);
                    _this2.map.setSourceContent(relative, node.source.input.css);
                }
            }
        });
    };

    MapGenerator.prototype.applyPrevMaps = function applyPrevMaps() {
        for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var prev = _ref;

            var from = this.relative(prev.file);
            var root = prev.root || _path2.default.dirname(prev.file);
            var map = void 0;

            if (this.mapOpts.sourcesContent === false) {
                map = new _sourceMap2.default.SourceMapConsumer(prev.text);
                if (map.sourcesContent) {
                    map.sourcesContent = map.sourcesContent.map(function () {
                        return null;
                    });
                }
            } else {
                map = prev.consumer();
            }

            this.map.applySourceMap(map, from, this.relative(root));
        }
    };

    MapGenerator.prototype.isAnnotation = function isAnnotation() {
        if (this.isInline()) {
            return true;
        } else if (typeof this.mapOpts.annotation !== 'undefined') {
            return this.mapOpts.annotation;
        } else if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.annotation;
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.addAnnotation = function addAnnotation() {
        var content = void 0;

        if (this.isInline()) {
            content = 'data:application/json;base64,' + _jsBase.Base64.encode(this.map.toString());
        } else if (typeof this.mapOpts.annotation === 'string') {
            content = this.mapOpts.annotation;
        } else {
            content = this.outputFile() + '.map';
        }

        var eol = '\n';
        if (this.css.indexOf('\r\n') !== -1) eol = '\r\n';

        this.css += eol + '/*# sourceMappingURL=' + content + ' */';
    };

    MapGenerator.prototype.outputFile = function outputFile() {
        if (this.opts.to) {
            return this.relative(this.opts.to);
        } else if (this.opts.from) {
            return this.relative(this.opts.from);
        } else {
            return 'to.css';
        }
    };

    MapGenerator.prototype.generateMap = function generateMap() {
        this.generateString();
        if (this.isSourcesContent()) this.setSourcesContent();
        if (this.previous().length > 0) this.applyPrevMaps();
        if (this.isAnnotation()) this.addAnnotation();

        if (this.isInline()) {
            return [this.css];
        } else {
            return [this.css, this.map];
        }
    };

    MapGenerator.prototype.relative = function relative(file) {
        if (file.indexOf('<') === 0) return file;
        if (/^\w+:\/\//.test(file)) return file;

        var from = this.opts.to ? _path2.default.dirname(this.opts.to) : '.';

        if (typeof this.mapOpts.annotation === 'string') {
            from = _path2.default.dirname(_path2.default.resolve(from, this.mapOpts.annotation));
        }

        file = _path2.default.relative(from, file);
        if (_path2.default.sep === '\\') {
            return file.replace(/\\/g, '/');
        } else {
            return file;
        }
    };

    MapGenerator.prototype.sourcePath = function sourcePath(node) {
        if (this.mapOpts.from) {
            return this.mapOpts.from;
        } else {
            return this.relative(node.source.input.from);
        }
    };

    MapGenerator.prototype.generateString = function generateString() {
        var _this3 = this;

        this.css = '';
        this.map = new _sourceMap2.default.SourceMapGenerator({ file: this.outputFile() });

        var line = 1;
        var column = 1;

        var lines = void 0,
            last = void 0;
        this.stringify(this.root, function (str, node, type) {
            _this3.css += str;

            if (node && type !== 'end') {
                if (node.source && node.source.start) {
                    _this3.map.addMapping({
                        source: _this3.sourcePath(node),
                        generated: { line: line, column: column - 1 },
                        original: {
                            line: node.source.start.line,
                            column: node.source.start.column - 1
                        }
                    });
                } else {
                    _this3.map.addMapping({
                        source: '<no source>',
                        original: { line: 1, column: 0 },
                        generated: { line: line, column: column - 1 }
                    });
                }
            }

            lines = str.match(/\n/g);
            if (lines) {
                line += lines.length;
                last = str.lastIndexOf('\n');
                column = str.length - last;
            } else {
                column += str.length;
            }

            if (node && type !== 'start') {
                if (node.source && node.source.end) {
                    _this3.map.addMapping({
                        source: _this3.sourcePath(node),
                        generated: { line: line, column: column - 1 },
                        original: {
                            line: node.source.end.line,
                            column: node.source.end.column
                        }
                    });
                } else {
                    _this3.map.addMapping({
                        source: '<no source>',
                        original: { line: 1, column: 0 },
                        generated: { line: line, column: column - 1 }
                    });
                }
            }
        });
    };

    MapGenerator.prototype.generate = function generate() {
        this.clearAnnotation();

        if (this.isMap()) {
            return this.generateMap();
        } else {
            var result = '';
            this.stringify(this.root, function (i) {
                result += i;
            });
            return [result];
        }
    };

    return MapGenerator;
}();

exports.default = MapGenerator;
module.exports = exports['default'];

}, {"610":610,"924":924,"1036":1036}];
window.modules["1021"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _cssSyntaxError = require(1026);

var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);

var _stringifier = require(1037);

var _stringifier2 = _interopRequireDefault(_stringifier);

var _stringify = require(1032);

var _stringify2 = _interopRequireDefault(_stringify);

var _warnOnce = require(1018);

var _warnOnce2 = _interopRequireDefault(_warnOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cloneNode = function cloneNode(obj, parent) {
    var cloned = new obj.constructor();

    for (var i in obj) {
        if (!obj.hasOwnProperty(i)) continue;
        var value = obj[i];
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

        if (i === 'parent' && type === 'object') {
            if (parent) cloned[i] = parent;
        } else if (i === 'source') {
            cloned[i] = value;
        } else if (value instanceof Array) {
            cloned[i] = value.map(function (j) {
                return cloneNode(j, cloned);
            });
        } else if (i !== 'before' && i !== 'after' && i !== 'between' && i !== 'semicolon') {
            if (type === 'object' && value !== null) value = cloneNode(value);
            cloned[i] = value;
        }
    }

    return cloned;
};

/**
 * All node classes inherit the following common methods.
 *
 * @abstract
 */

var Node = function () {

    /**
     * @param {object} [defaults] - value for node properties
     */
    function Node() {
        var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Node);

        this.raws = {};
        if ((typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) !== 'object' && typeof defaults !== 'undefined') {
            throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));
        }
        for (var name in defaults) {
            this[name] = defaults[name];
        }
    }

    /**
     * Returns a CssSyntaxError instance containing the original position
     * of the node in the source, showing line and column numbers and also
     * a small excerpt to facilitate debugging.
     *
     * If present, an input source map will be used to get the original position
     * of the source, even from a previous compilation step
     * (e.g., from Sass compilation).
     *
     * This method produces very useful error messages.
     *
     * @param {string} message     - error description
     * @param {object} [opts]      - options
     * @param {string} opts.plugin - plugin name that created this error.
     *                               PostCSS will set it automatically.
     * @param {string} opts.word   - a word inside a nodes string that should
     *                               be highlighted as the source of the error
     * @param {number} opts.index  - an index inside a nodes string that should
     *                               be highlighted as the source of the error
     *
     * @return {CssSyntaxError} error object to throw it
     *
     * @example
     * if ( !variables[name] ) {
     *   throw decl.error('Unknown variable ' + name, { word: name });
     *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
     *   //   color: $black
     *   // a
     *   //          ^
     *   //   background: white
     * }
     */


    Node.prototype.error = function error(message) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (this.source) {
            var pos = this.positionBy(opts);
            return this.source.input.error(message, pos.line, pos.column, opts);
        } else {
            return new _cssSyntaxError2.default(message);
        }
    };

    /**
     * This method is provided as a convenience wrapper for {@link Result#warn}.
     *
     * @param {Result} result      - the {@link Result} instance
     *                               that will receive the warning
     * @param {string} text        - warning message
     * @param {object} [opts]      - options
     * @param {string} opts.plugin - plugin name that created this warning.
     *                               PostCSS will set it automatically.
     * @param {string} opts.word   - a word inside a nodes string that should
     *                               be highlighted as the source of the warning
     * @param {number} opts.index  - an index inside a nodes string that should
     *                               be highlighted as the source of the warning
     *
     * @return {Warning} created warning object
     *
     * @example
     * const plugin = postcss.plugin('postcss-deprecated', () => {
     *   return (root, result) => {
     *     root.walkDecls('bad', decl => {
     *       decl.warn(result, 'Deprecated property bad');
     *     });
     *   };
     * });
     */


    Node.prototype.warn = function warn(result, text, opts) {
        var data = { node: this };
        for (var i in opts) {
            data[i] = opts[i];
        }return result.warn(text, data);
    };

    /**
     * Removes the node from its parent and cleans the parent properties
     * from the node and its children.
     *
     * @example
     * if ( decl.prop.match(/^-webkit-/) ) {
     *   decl.remove();
     * }
     *
     * @return {Node} node to make calls chain
     */


    Node.prototype.remove = function remove() {
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.parent = undefined;
        return this;
    };

    /**
     * Returns a CSS string representing the node.
     *
     * @param {stringifier|syntax} [stringifier] - a syntax to use
     *                                             in string generation
     *
     * @return {string} CSS string of this node
     *
     * @example
     * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
     */


    Node.prototype.toString = function toString() {
        var stringifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _stringify2.default;

        if (stringifier.stringify) stringifier = stringifier.stringify;
        var result = '';
        stringifier(this, function (i) {
            result += i;
        });
        return result;
    };

    /**
     * Returns a clone of the node.
     *
     * The resulting cloned node and its (cloned) children will have
     * a clean parent and code style properties.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @example
     * const cloned = decl.clone({ prop: '-moz-' + decl.prop });
     * cloned.raws.before  //=> undefined
     * cloned.parent       //=> undefined
     * cloned.toString()   //=> -moz-transform: scale(0)
     *
     * @return {Node} clone of the node
     */


    Node.prototype.clone = function clone() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = cloneNode(this);
        for (var name in overrides) {
            cloned[name] = overrides[name];
        }
        return cloned;
    };

    /**
     * Shortcut to clone the node and insert the resulting cloned node
     * before the current node.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @example
     * decl.cloneBefore({ prop: '-moz-' + decl.prop });
     *
     * @return {Node} - new node
     */


    Node.prototype.cloneBefore = function cloneBefore() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
    };

    /**
     * Shortcut to clone the node and insert the resulting cloned node
     * after the current node.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @return {Node} - new node
     */


    Node.prototype.cloneAfter = function cloneAfter() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
    };

    /**
     * Inserts node(s) before the current node and removes the current node.
     *
     * @param {...Node} nodes - node(s) to replace current one
     *
     * @example
     * if ( atrule.name == 'mixin' ) {
     *   atrule.replaceWith(mixinRules[atrule.params]);
     * }
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.replaceWith = function replaceWith() {
        if (this.parent) {
            for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
                nodes[_key] = arguments[_key];
            }

            for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var node = _ref;

                this.parent.insertBefore(this, node);
            }

            this.remove();
        }

        return this;
    };

    /**
     * Removes the node from its current parent and inserts it
     * at the end of `newParent`.
     *
     * This will clean the `before` and `after` code {@link Node#raws} data
     * from the node and replace them with the indentation style of `newParent`.
     * It will also clean the `between` property
     * if `newParent` is in another {@link Root}.
     *
     * @param {Container} newParent - container node where the current node
     *                                will be moved
     *
     * @example
     * atrule.moveTo(atrule.root());
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveTo = function moveTo(newParent) {
        this.cleanRaws(this.root() === newParent.root());
        this.remove();
        newParent.append(this);
        return this;
    };

    /**
     * Removes the node from its current parent and inserts it into
     * a new parent before `otherNode`.
     *
     * This will also clean the nodes code style properties just as it would
     * in {@link Node#moveTo}.
     *
     * @param {Node} otherNode - node that will be before current node
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveBefore = function moveBefore(otherNode) {
        this.cleanRaws(this.root() === otherNode.root());
        this.remove();
        otherNode.parent.insertBefore(otherNode, this);
        return this;
    };

    /**
     * Removes the node from its current parent and inserts it into
     * a new parent after `otherNode`.
     *
     * This will also clean the nodes code style properties just as it would
     * in {@link Node#moveTo}.
     *
     * @param {Node} otherNode - node that will be after current node
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveAfter = function moveAfter(otherNode) {
        this.cleanRaws(this.root() === otherNode.root());
        this.remove();
        otherNode.parent.insertAfter(otherNode, this);
        return this;
    };

    /**
     * Returns the next child of the nodes parent.
     * Returns `undefined` if the current node is the last child.
     *
     * @return {Node|undefined} next node
     *
     * @example
     * if ( comment.text === 'delete next' ) {
     *   const next = comment.next();
     *   if ( next ) {
     *     next.remove();
     *   }
     * }
     */


    Node.prototype.next = function next() {
        var index = this.parent.index(this);
        return this.parent.nodes[index + 1];
    };

    /**
     * Returns the previous child of the nodes parent.
     * Returns `undefined` if the current node is the first child.
     *
     * @return {Node|undefined} previous node
     *
     * @example
     * const annotation = decl.prev();
     * if ( annotation.type == 'comment' ) {
     *  readAnnotation(annotation.text);
     * }
     */


    Node.prototype.prev = function prev() {
        var index = this.parent.index(this);
        return this.parent.nodes[index - 1];
    };

    Node.prototype.toJSON = function toJSON() {
        var fixed = {};

        for (var name in this) {
            if (!this.hasOwnProperty(name)) continue;
            if (name === 'parent') continue;
            var value = this[name];

            if (value instanceof Array) {
                fixed[name] = value.map(function (i) {
                    if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && i.toJSON) {
                        return i.toJSON();
                    } else {
                        return i;
                    }
                });
            } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.toJSON) {
                fixed[name] = value.toJSON();
            } else {
                fixed[name] = value;
            }
        }

        return fixed;
    };

    /**
     * Returns a {@link Node#raws} value. If the node is missing
     * the code style property (because the node was manually built or cloned),
     * PostCSS will try to autodetect the code style property by looking
     * at other nodes in the tree.
     *
     * @param {string} prop          - name of code style property
     * @param {string} [defaultType] - name of default value, it can be missed
     *                                 if the value is the same as prop
     *
     * @example
     * const root = postcss.parse('a { background: white }');
     * root.nodes[0].append({ prop: 'color', value: 'black' });
     * root.nodes[0].nodes[1].raws.before   //=> undefined
     * root.nodes[0].nodes[1].raw('before') //=> ' '
     *
     * @return {string} code style value
     */


    Node.prototype.raw = function raw(prop, defaultType) {
        var str = new _stringifier2.default();
        return str.raw(this, prop, defaultType);
    };

    /**
     * Finds the Root instance of the nodes tree.
     *
     * @example
     * root.nodes[0].nodes[0].root() === root
     *
     * @return {Root} root parent
     */


    Node.prototype.root = function root() {
        var result = this;
        while (result.parent) {
            result = result.parent;
        }return result;
    };

    Node.prototype.cleanRaws = function cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween) delete this.raws.between;
    };

    Node.prototype.positionInside = function positionInside(index) {
        var string = this.toString();
        var column = this.source.start.column;
        var line = this.source.start.line;

        for (var i = 0; i < index; i++) {
            if (string[i] === '\n') {
                column = 1;
                line += 1;
            } else {
                column += 1;
            }
        }

        return { line: line, column: column };
    };

    Node.prototype.positionBy = function positionBy(opts) {
        var pos = this.source.start;
        if (opts.index) {
            pos = this.positionInside(opts.index);
        } else if (opts.word) {
            var index = this.toString().indexOf(opts.word);
            if (index !== -1) pos = this.positionInside(index);
        }
        return pos;
    };

    Node.prototype.removeSelf = function removeSelf() {
        (0, _warnOnce2.default)('Node#removeSelf is deprecated. Use Node#remove.');
        return this.remove();
    };

    Node.prototype.replace = function replace(nodes) {
        (0, _warnOnce2.default)('Node#replace is deprecated. Use Node#replaceWith');
        return this.replaceWith(nodes);
    };

    Node.prototype.style = function style(own, detect) {
        (0, _warnOnce2.default)('Node#style() is deprecated. Use Node#raw()');
        return this.raw(own, detect);
    };

    Node.prototype.cleanStyles = function cleanStyles(keepBetween) {
        (0, _warnOnce2.default)('Node#cleanStyles() is deprecated. Use Node#cleanRaws()');
        return this.cleanRaws(keepBetween);
    };

    _createClass(Node, [{
        key: 'before',
        get: function get() {
            (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');
            return this.raws.before;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');
            this.raws.before = val;
        }
    }, {
        key: 'between',
        get: function get() {
            (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');
            return this.raws.between;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');
            this.raws.between = val;
        }

        /**
         * @memberof Node#
         * @member {string} type - String representing the nodes type.
         *                         Possible values are `root`, `atrule`, `rule`,
         *                         `decl`, or `comment`.
         *
         * @example
         * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
         */

        /**
         * @memberof Node#
         * @member {Container} parent - the nodes parent node.
         *
         * @example
         * root.nodes[0].parent == root;
         */

        /**
         * @memberof Node#
         * @member {source} source - the input source of the node
         *
         * The property is used in source map generation.
         *
         * If you create a node manually (e.g., with `postcss.decl()`),
         * that node will not have a `source` property and will be absent
         * from the source map. For this reason, the plugin developer should
         * consider cloning nodes to create new ones (in which case the new nodes
         * source will reference the original, cloned node) or setting
         * the `source` property manually.
         *
         * ```js
         * // Bad
         * const prefixed = postcss.decl({
         *   prop: '-moz-' + decl.prop,
         *   value: decl.value
         * });
         *
         * // Good
         * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });
         * ```
         *
         * ```js
         * if ( atrule.name == 'add-link' ) {
         *   const rule = postcss.rule({ selector: 'a', source: atrule.source });
         *   atrule.parent.insertBefore(atrule, rule);
         * }
         * ```
         *
         * @example
         * decl.source.input.from //=> '/home/ai/a.sass'
         * decl.source.start      //=> { line: 10, column: 2 }
         * decl.source.end        //=> { line: 10, column: 12 }
         */

        /**
         * @memberof Node#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `after`: the space symbols after the last child of the node
         *   to the end of the node.
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `semicolon`: contains true if the last child has
         *   an (optional) semicolon.
         * * `afterName`: the space between the at-rule name and its parameters.
         * * `left`: the space symbols between `/*` and the comments text.
         * * `right`: the space symbols between the comments text
         *   and <code>*&#47;</code>.
         * * `important`: the content of the important statement,
         *   if it is not just `!important`.
         *
         * PostCSS cleans selectors, declaration values and at-rule parameters
         * from comments and extra spaces, but it stores origin content in raws
         * properties. As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('a {\n  color:black\n}')
         * root.first.first.raws //=> { before: '\n  ', between: ':' }
         */

    }]);

    return Node;
}();

exports.default = Node;

/**
 * @typedef {object} position
 * @property {number} line   - source line in file
 * @property {number} column - source column in file
 */

/**
 * @typedef {object} source
 * @property {Input} input    - {@link Input} with input file
 * @property {position} start - The starting position of the nodes source
 * @property {position} end   - The ending position of the nodes source
 */

module.exports = exports['default'];

}, {"1018":1018,"1026":1026,"1032":1032,"1037":1037}];
window.modules["1023"] = [function(require,module,exports){'use strict';

exports.__esModule = true;
exports.default = parse;

var _parser = require(1038);

var _parser2 = _interopRequireDefault(_parser);

var _input = require(1029);

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(css, opts) {
    if (opts && opts.safe) {
        throw new Error('Option safe was removed. ' + 'Use parser: require("postcss-safe-parser")');
    }

    var input = new _input2.default(css, opts);

    var parser = new _parser2.default(input);
    try {
        parser.tokenize();
        parser.loop();
    } catch (e) {
        if (e.name === 'CssSyntaxError' && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
                e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';
            } else if (/\.sass/i.test(opts.from)) {
                e.message += '\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';
            } else if (/\.less$/i.test(opts.from)) {
                e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';
            }
        }
        throw e;
    }

    return parser.root;
}
module.exports = exports['default'];

}, {"1029":1029,"1038":1038}];
window.modules["1038"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _declaration = require(1022);

var _declaration2 = _interopRequireDefault(_declaration);

var _tokenize = require(1039);

var _tokenize2 = _interopRequireDefault(_tokenize);

var _comment = require(1020);

var _comment2 = _interopRequireDefault(_comment);

var _atRule = require(1017);

var _atRule2 = _interopRequireDefault(_atRule);

var _root = require(1025);

var _root2 = _interopRequireDefault(_root);

var _rule = require(1024);

var _rule2 = _interopRequireDefault(_rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Parser = function () {
    function Parser(input) {
        _classCallCheck(this, Parser);

        this.input = input;

        this.pos = 0;
        this.root = new _root2.default();
        this.current = this.root;
        this.spaces = '';
        this.semicolon = false;

        this.root.source = { input: input, start: { line: 1, column: 1 } };
    }

    Parser.prototype.tokenize = function tokenize() {
        this.tokens = (0, _tokenize2.default)(this.input);
    };

    Parser.prototype.loop = function loop() {
        var token = void 0;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];

            switch (token[0]) {

                case 'space':
                case ';':
                    this.spaces += token[1];
                    break;

                case '}':
                    this.end(token);
                    break;

                case 'comment':
                    this.comment(token);
                    break;

                case 'at-word':
                    this.atrule(token);
                    break;

                case '{':
                    this.emptyRule(token);
                    break;

                default:
                    this.other();
                    break;
            }

            this.pos += 1;
        }
        this.endFile();
    };

    Parser.prototype.comment = function comment(token) {
        var node = new _comment2.default();
        this.init(node, token[2], token[3]);
        node.source.end = { line: token[4], column: token[5] };

        var text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
        } else {
            var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
        }
    };

    Parser.prototype.emptyRule = function emptyRule(token) {
        var node = new _rule2.default();
        this.init(node, token[2], token[3]);
        node.selector = '';
        node.raws.between = '';
        this.current = node;
    };

    Parser.prototype.other = function other() {
        var token = void 0;
        var end = false;
        var type = null;
        var colon = false;
        var bracket = null;
        var brackets = [];

        var start = this.pos;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];
            type = token[0];

            if (type === '(' || type === '[') {
                if (!bracket) bracket = token;
                brackets.push(type === '(' ? ')' : ']');
            } else if (brackets.length === 0) {
                if (type === ';') {
                    if (colon) {
                        this.decl(this.tokens.slice(start, this.pos + 1));
                        return;
                    } else {
                        break;
                    }
                } else if (type === '{') {
                    this.rule(this.tokens.slice(start, this.pos + 1));
                    return;
                } else if (type === '}') {
                    this.pos -= 1;
                    end = true;
                    break;
                } else if (type === ':') {
                    colon = true;
                }
            } else if (type === brackets[brackets.length - 1]) {
                brackets.pop();
                if (brackets.length === 0) bracket = null;
            }

            this.pos += 1;
        }
        if (this.pos === this.tokens.length) {
            this.pos -= 1;
            end = true;
        }

        if (brackets.length > 0) this.unclosedBracket(bracket);

        if (end && colon) {
            while (this.pos > start) {
                token = this.tokens[this.pos][0];
                if (token !== 'space' && token !== 'comment') break;
                this.pos -= 1;
            }
            this.decl(this.tokens.slice(start, this.pos + 1));
            return;
        }

        this.unknownWord(start);
    };

    Parser.prototype.rule = function rule(tokens) {
        tokens.pop();

        var node = new _rule2.default();
        this.init(node, tokens[0][2], tokens[0][3]);

        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, 'selector', tokens);
        this.current = node;
    };

    Parser.prototype.decl = function decl(tokens) {
        var node = new _declaration2.default();
        this.init(node);

        var last = tokens[tokens.length - 1];
        if (last[0] === ';') {
            this.semicolon = true;
            tokens.pop();
        }
        if (last[4]) {
            node.source.end = { line: last[4], column: last[5] };
        } else {
            node.source.end = { line: last[2], column: last[3] };
        }

        while (tokens[0][0] !== 'word') {
            node.raws.before += tokens.shift()[1];
        }
        node.source.start = { line: tokens[0][2], column: tokens[0][3] };

        node.prop = '';
        while (tokens.length) {
            var type = tokens[0][0];
            if (type === ':' || type === 'space' || type === 'comment') {
                break;
            }
            node.prop += tokens.shift()[1];
        }

        node.raws.between = '';

        var token = void 0;
        while (tokens.length) {
            token = tokens.shift();

            if (token[0] === ':') {
                node.raws.between += token[1];
                break;
            } else {
                node.raws.between += token[1];
            }
        }

        if (node.prop[0] === '_' || node.prop[0] === '*') {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
        }
        node.raws.between += this.spacesAndCommentsFromStart(tokens);
        this.precheckMissedSemicolon(tokens);

        for (var i = tokens.length - 1; i > 0; i--) {
            token = tokens[i];
            if (token[1] === '!important') {
                node.important = true;
                var string = this.stringFrom(tokens, i);
                string = this.spacesFromEnd(tokens) + string;
                if (string !== ' !important') node.raws.important = string;
                break;
            } else if (token[1] === 'important') {
                var cache = tokens.slice(0);
                var str = '';
                for (var j = i; j > 0; j--) {
                    var _type = cache[j][0];
                    if (str.trim().indexOf('!') === 0 && _type !== 'space') {
                        break;
                    }
                    str = cache.pop()[1] + str;
                }
                if (str.trim().indexOf('!') === 0) {
                    node.important = true;
                    node.raws.important = str;
                    tokens = cache;
                }
            }

            if (token[0] !== 'space' && token[0] !== 'comment') {
                break;
            }
        }

        this.raw(node, 'value', tokens);

        if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);
    };

    Parser.prototype.atrule = function atrule(token) {
        var node = new _atRule2.default();
        node.name = token[1].slice(1);
        if (node.name === '') {
            this.unnamedAtrule(node, token);
        }
        this.init(node, token[2], token[3]);

        var last = false;
        var open = false;
        var params = [];

        this.pos += 1;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];

            if (token[0] === ';') {
                node.source.end = { line: token[2], column: token[3] };
                this.semicolon = true;
                break;
            } else if (token[0] === '{') {
                open = true;
                break;
            } else if (token[0] === '}') {
                this.end(token);
                break;
            } else {
                params.push(token);
            }

            this.pos += 1;
        }
        if (this.pos === this.tokens.length) {
            last = true;
        }

        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, 'params', params);
            if (last) {
                token = params[params.length - 1];
                node.source.end = { line: token[4], column: token[5] };
                this.spaces = node.raws.between;
                node.raws.between = '';
            }
        } else {
            node.raws.afterName = '';
            node.params = '';
        }

        if (open) {
            node.nodes = [];
            this.current = node;
        }
    };

    Parser.prototype.end = function end(token) {
        if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;

        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
        this.spaces = '';

        if (this.current.parent) {
            this.current.source.end = { line: token[2], column: token[3] };
            this.current = this.current.parent;
        } else {
            this.unexpectedClose(token);
        }
    };

    Parser.prototype.endFile = function endFile() {
        if (this.current.parent) this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
    };

    // Helpers

    Parser.prototype.init = function init(node, line, column) {
        this.current.push(node);

        node.source = { start: { line: line, column: column }, input: this.input };
        node.raws.before = this.spaces;
        this.spaces = '';
        if (node.type !== 'comment') this.semicolon = false;
    };

    Parser.prototype.raw = function raw(node, prop, tokens) {
        var token = void 0,
            type = void 0;
        var length = tokens.length;
        var value = '';
        var clean = true;
        for (var i = 0; i < length; i += 1) {
            token = tokens[i];
            type = token[0];
            if (type === 'comment' || type === 'space' && i === length - 1) {
                clean = false;
            } else {
                value += token[1];
            }
        }
        if (!clean) {
            var raw = tokens.reduce(function (all, i) {
                return all + i[1];
            }, '');
            node.raws[prop] = { value: value, raw: raw };
        }
        node[prop] = value;
    };

    Parser.prototype.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {
        var lastTokenType = void 0;
        var spaces = '';
        while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
            spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
    };

    Parser.prototype.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {
        var next = void 0;
        var spaces = '';
        while (tokens.length) {
            next = tokens[0][0];
            if (next !== 'space' && next !== 'comment') break;
            spaces += tokens.shift()[1];
        }
        return spaces;
    };

    Parser.prototype.spacesFromEnd = function spacesFromEnd(tokens) {
        var lastTokenType = void 0;
        var spaces = '';
        while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space') break;
            spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
    };

    Parser.prototype.stringFrom = function stringFrom(tokens, from) {
        var result = '';
        for (var i = from; i < tokens.length; i++) {
            result += tokens[i][1];
        }
        tokens.splice(from, tokens.length - from);
        return result;
    };

    Parser.prototype.colon = function colon(tokens) {
        var brackets = 0;
        var token = void 0,
            type = void 0,
            prev = void 0;
        for (var i = 0; i < tokens.length; i++) {
            token = tokens[i];
            type = token[0];

            if (type === '(') {
                brackets += 1;
            } else if (type === ')') {
                brackets -= 1;
            } else if (brackets === 0 && type === ':') {
                if (!prev) {
                    this.doubleColon(token);
                } else if (prev[0] === 'word' && prev[1] === 'progid') {
                    continue;
                } else {
                    return i;
                }
            }

            prev = token;
        }
        return false;
    };

    // Errors

    Parser.prototype.unclosedBracket = function unclosedBracket(bracket) {
        throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);
    };

    Parser.prototype.unknownWord = function unknownWord(start) {
        var token = this.tokens[start];
        throw this.input.error('Unknown word', token[2], token[3]);
    };

    Parser.prototype.unexpectedClose = function unexpectedClose(token) {
        throw this.input.error('Unexpected }', token[2], token[3]);
    };

    Parser.prototype.unclosedBlock = function unclosedBlock() {
        var pos = this.current.source.start;
        throw this.input.error('Unclosed block', pos.line, pos.column);
    };

    Parser.prototype.doubleColon = function doubleColon(token) {
        throw this.input.error('Double colon', token[2], token[3]);
    };

    Parser.prototype.unnamedAtrule = function unnamedAtrule(node, token) {
        throw this.input.error('At-rule without name', token[2], token[3]);
    };

    Parser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {
        // Hook for Safe Parser
        tokens;
    };

    Parser.prototype.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
        var colon = this.colon(tokens);
        if (colon === false) return;

        var founded = 0;
        var token = void 0;
        for (var j = colon - 1; j >= 0; j--) {
            token = tokens[j];
            if (token[0] !== 'space') {
                founded += 1;
                if (founded === 2) break;
            }
        }
        throw this.input.error('Missed semicolon', token[2], token[3]);
    };

    return Parser;
}();

exports.default = Parser;
module.exports = exports['default'];

}, {"1017":1017,"1020":1020,"1022":1022,"1024":1024,"1025":1025,"1039":1039}];
window.modules["1013"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _declaration = require(1022);

var _declaration2 = _interopRequireDefault(_declaration);

var _processor = require(1041);

var _processor2 = _interopRequireDefault(_processor);

var _stringify = require(1032);

var _stringify2 = _interopRequireDefault(_stringify);

var _comment = require(1020);

var _comment2 = _interopRequireDefault(_comment);

var _atRule = require(1017);

var _atRule2 = _interopRequireDefault(_atRule);

var _vendor = require(1040);

var _vendor2 = _interopRequireDefault(_vendor);

var _parse = require(1023);

var _parse2 = _interopRequireDefault(_parse);

var _list = require(1035);

var _list2 = _interopRequireDefault(_list);

var _rule = require(1024);

var _rule2 = _interopRequireDefault(_rule);

var _root = require(1025);

var _root2 = _interopRequireDefault(_root);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create a new {@link Processor} instance that will apply `plugins`
 * as CSS processors.
 *
 * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
 *        plugins. See {@link Processor#use} for plugin format.
 *
 * @return {Processor} Processor to process multiple CSS
 *
 * @example
 * import postcss from 'postcss';
 *
 * postcss(plugins).process(css, { from, to }).then(result => {
 *   console.log(result.css);
 * });
 *
 * @namespace postcss
 */
function postcss() {
  for (var _len = arguments.length, plugins = Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new _processor2.default(plugins);
}

/**
 * Creates a PostCSS plugin with a standard API.
 *
 * The newly-wrapped function will provide both the name and PostCSS
 * version of the plugin.
 *
 * ```js
 *  const processor = postcss([replace]);
 *  processor.plugins[0].postcssPlugin  //=> 'postcss-replace'
 *  processor.plugins[0].postcssVersion //=> '5.1.0'
 * ```
 *
 * The plugin function receives 2 arguments: {@link Root}
 * and {@link Result} instance. The function should mutate the provided
 * `Root` node. Alternatively, you can create a new `Root` node
 * and override the `result.root` property.
 *
 * ```js
 * const cleaner = postcss.plugin('postcss-cleaner', () => {
 *   return (root, result) => {
 *     result.root = postcss.root();
 *   };
 * });
 * ```
 *
 * As a convenience, plugins also expose a `process` method so that you can use
 * them as standalone tools.
 *
 * ```js
 * cleaner.process(css, options);
 * // This is equivalent to:
 * postcss([ cleaner(options) ]).process(css);
 * ```
 *
 * Asynchronous plugins should return a `Promise` instance.
 *
 * ```js
 * postcss.plugin('postcss-import', () => {
 *   return (root, result) => {
 *     return new Promise( (resolve, reject) => {
 *       fs.readFile('base.css', (base) => {
 *         root.prepend(base);
 *         resolve();
 *       });
 *     });
 *   };
 * });
 * ```
 *
 * Add warnings using the {@link Node#warn} method.
 * Send data to other plugins using the {@link Result#messages} array.
 *
 * ```js
 * postcss.plugin('postcss-caniuse-test', () => {
 *   return (root, result) => {
 *     css.walkDecls(decl => {
 *       if ( !caniuse.support(decl.prop) ) {
 *         decl.warn(result, 'Some browsers do not support ' + decl.prop);
 *       }
 *     });
 *   };
 * });
 * ```
 *
 * @param {string} name          - PostCSS plugin name. Same as in `name`
 *                                 property in `package.json`. It will be saved
 *                                 in `plugin.postcssPlugin` property.
 * @param {function} initializer - will receive plugin options
 *                                 and should return {@link pluginFunction}
 *
 * @return {Plugin} PostCSS plugin
 */
postcss.plugin = function plugin(name, initializer) {
  var creator = function creator() {
    var transformer = initializer.apply(undefined, arguments);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new _processor2.default().version;
    return transformer;
  };

  var cache = void 0;
  Object.defineProperty(creator, 'postcss', {
    get: function get() {
      if (!cache) cache = creator();
      return cache;
    }
  });

  creator.process = function (root, opts) {
    return postcss([creator(opts)]).process(root, opts);
  };

  return creator;
};

/**
 * Default function to convert a node tree into a CSS string.
 *
 * @param {Node} node       - start node for stringifing. Usually {@link Root}.
 * @param {builder} builder - function to concatenate CSS from nodes parts
 *                            or generate string and source map
 *
 * @return {void}
 *
 * @function
 */
postcss.stringify = _stringify2.default;

/**
 * Parses source css and returns a new {@link Root} node,
 * which contains the source CSS nodes.
 *
 * @param {string|toString} css   - string with input CSS or any object
 *                                  with toString() method, like a Buffer
 * @param {processOptions} [opts] - options with only `from` and `map` keys
 *
 * @return {Root} PostCSS AST
 *
 * @example
 * // Simple CSS concatenation with source map support
 * const root1 = postcss.parse(css1, { from: file1 });
 * const root2 = postcss.parse(css2, { from: file2 });
 * root1.append(root2).toResult().css;
 *
 * @function
 */
postcss.parse = _parse2.default;

/**
 * @member {vendor} - Contains the {@link vendor} module.
 *
 * @example
 * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']
 */
postcss.vendor = _vendor2.default;

/**
 * @member {list} - Contains the {@link list} module.
 *
 * @example
 * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']
 */
postcss.list = _list2.default;

/**
 * Creates a new {@link Comment} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Comment} new Comment node
 *
 * @example
 * postcss.comment({ text: 'test' })
 */
postcss.comment = function (defaults) {
  return new _comment2.default(defaults);
};

/**
 * Creates a new {@link AtRule} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {AtRule} new AtRule node
 *
 * @example
 * postcss.atRule({ name: 'charset' }).toString() //=> "@charset"
 */
postcss.atRule = function (defaults) {
  return new _atRule2.default(defaults);
};

/**
 * Creates a new {@link Declaration} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Declaration} new Declaration node
 *
 * @example
 * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> "color: red"
 */
postcss.decl = function (defaults) {
  return new _declaration2.default(defaults);
};

/**
 * Creates a new {@link Rule} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {AtRule} new Rule node
 *
 * @example
 * postcss.rule({ selector: 'a' }).toString() //=> "a {\n}"
 */
postcss.rule = function (defaults) {
  return new _rule2.default(defaults);
};

/**
 * Creates a new {@link Root} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Root} new Root node
 *
 * @example
 * postcss.root({ after: '\n' }).toString() //=> "\n"
 */
postcss.root = function (defaults) {
  return new _root2.default(defaults);
};

exports.default = postcss;
module.exports = exports['default'];

}, {"1017":1017,"1020":1020,"1022":1022,"1023":1023,"1024":1024,"1025":1025,"1032":1032,"1035":1035,"1040":1040,"1041":1041}];
window.modules["1030"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _jsBase = require(610);

var _sourceMap = require(1036);

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _path = require(924);

var _path2 = _interopRequireDefault(_path);

var _fs = require(272);

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Source map information from input CSS.
 * For example, source map after Sass compiler.
 *
 * This class will automatically find source map in input CSS or in file system
 * near input file (according `from` option).
 *
 * @example
 * const root = postcss.parse(css, { from: 'a.sass.css' });
 * root.input.map //=> PreviousMap
 */
var PreviousMap = function () {

    /**
     * @param {string}         css    - input CSS source
     * @param {processOptions} [opts] - {@link Processor#process} options
     */
    function PreviousMap(css, opts) {
        _classCallCheck(this, PreviousMap);

        this.loadAnnotation(css);
        /**
         * @member {boolean} - Was source map inlined by data-uri to input CSS.
         */
        this.inline = this.startWith(this.annotation, 'data:');

        var prev = opts.map ? opts.map.prev : undefined;
        var text = this.loadMap(opts.from, prev);
        if (text) this.text = text;
    }

    /**
     * Create a instance of `SourceMapGenerator` class
     * from the `source-map` library to work with source map information.
     *
     * It is lazy method, so it will create object only on first call
     * and then it will use cache.
     *
     * @return {SourceMapGenerator} object with source map information
     */


    PreviousMap.prototype.consumer = function consumer() {
        if (!this.consumerCache) {
            this.consumerCache = new _sourceMap2.default.SourceMapConsumer(this.text);
        }
        return this.consumerCache;
    };

    /**
     * Does source map contains `sourcesContent` with input source text.
     *
     * @return {boolean} Is `sourcesContent` present
     */


    PreviousMap.prototype.withContent = function withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    };

    PreviousMap.prototype.startWith = function startWith(string, start) {
        if (!string) return false;
        return string.substr(0, start.length) === start;
    };

    PreviousMap.prototype.loadAnnotation = function loadAnnotation(css) {
        var match = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//);
        if (match) this.annotation = match[1].trim();
    };

    PreviousMap.prototype.decodeInline = function decodeInline(text) {
        var utfd64 = 'data:application/json;charset=utf-8;base64,';
        var utf64 = 'data:application/json;charset=utf8;base64,';
        var b64 = 'data:application/json;base64,';
        var uri = 'data:application/json,';

        if (this.startWith(text, uri)) {
            return decodeURIComponent(text.substr(uri.length));
        } else if (this.startWith(text, b64)) {
            return _jsBase.Base64.decode(text.substr(b64.length));
        } else if (this.startWith(text, utf64)) {
            return _jsBase.Base64.decode(text.substr(utf64.length));
        } else if (this.startWith(text, utfd64)) {
            return _jsBase.Base64.decode(text.substr(utfd64.length));
        } else {
            var encoding = text.match(/data:application\/json;([^,]+),/)[1];
            throw new Error('Unsupported source map encoding ' + encoding);
        }
    };

    PreviousMap.prototype.loadMap = function loadMap(file, prev) {
        if (prev === false) return false;

        if (prev) {
            if (typeof prev === 'string') {
                return prev;
            } else if (typeof prev === 'function') {
                var prevPath = prev(file);
                if (prevPath && _fs2.default.existsSync && _fs2.default.existsSync(prevPath)) {
                    return _fs2.default.readFileSync(prevPath, 'utf-8').toString().trim();
                } else {
                    throw new Error('Unable to load previous source map: ' + prevPath.toString());
                }
            } else if (prev instanceof _sourceMap2.default.SourceMapConsumer) {
                return _sourceMap2.default.SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof _sourceMap2.default.SourceMapGenerator) {
                return prev.toString();
            } else if (this.isMap(prev)) {
                return JSON.stringify(prev);
            } else {
                throw new Error('Unsupported previous source map format: ' + prev.toString());
            }
        } else if (this.inline) {
            return this.decodeInline(this.annotation);
        } else if (this.annotation) {
            var map = this.annotation;
            if (file) map = _path2.default.join(_path2.default.dirname(file), map);

            this.root = _path2.default.dirname(map);
            if (_fs2.default.existsSync && _fs2.default.existsSync(map)) {
                return _fs2.default.readFileSync(map, 'utf-8').toString().trim();
            } else {
                return false;
            }
        }
    };

    PreviousMap.prototype.isMap = function isMap(map) {
        if ((typeof map === 'undefined' ? 'undefined' : _typeof(map)) !== 'object') return false;
        return typeof map.mappings === 'string' || typeof map._mappings === 'string';
    };

    return PreviousMap;
}();

exports.default = PreviousMap;
module.exports = exports['default'];

}, {"272":272,"610":610,"924":924,"1036":1036}];
window.modules["1041"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _lazyResult = require(1031);

var _lazyResult2 = _interopRequireDefault(_lazyResult);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * @example
 * const processor = postcss([autoprefixer, precss]);
 * processor.process(css1).then(result => console.log(result.css));
 * processor.process(css2).then(result => console.log(result.css));
 */
var Processor = function () {

  /**
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
   *        plugins. See {@link Processor#use} for plugin format.
   */
  function Processor() {
    var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, Processor);

    /**
     * @member {string} - Current PostCSS version.
     *
     * @example
     * if ( result.processor.version.split('.')[0] !== '5' ) {
     *   throw new Error('This plugin works only with PostCSS 5');
     * }
     */
    this.version = '5.2.18';
    /**
     * @member {pluginFunction[]} - Plugins added to this processor.
     *
     * @example
     * const processor = postcss([autoprefixer, precss]);
     * processor.plugins.length //=> 2
     */
    this.plugins = this.normalize(plugins);
  }

  /**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin created by {@link postcss.plugin} method.
   * * A function. PostCSS will pass the function a @{link Root}
   *   as the first argument and current {@link Result} instance
   *   as the second.
   * * An object with a `postcss` method. PostCSS will use that method
   *   as described in #2.
   * * Another {@link Processor} instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * @param {Plugin|pluginFunction|Processor} plugin - PostCSS plugin
   *                                                   or {@link Processor}
   *                                                   with plugins
   *
   * @example
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(precss);
   *
   * @return {Processes} current processor to make methods chain
   */


  Processor.prototype.use = function use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]));
    return this;
  };

  /**
   * Parses source CSS and returns a {@link LazyResult} Promise proxy.
   * Because some plugins can be asynchronous it doesnt make
   * any transformations. Transformations will be applied
   * in the {@link LazyResult} methods.
   *
   * @param {string|toString|Result} css - String with input CSS or
   *                                       any object with a `toString()`
   *                                       method, like a Buffer.
   *                                       Optionally, send a {@link Result}
   *                                       instance and the processor will
   *                                       take the {@link Root} from it.
   * @param {processOptions} [opts]      - options
   *
   * @return {LazyResult} Promise proxy
   *
   * @example
   * processor.process(css, { from: 'a.css', to: 'a.out.css' })
   *   .then(result => {
   *      console.log(result.css);
   *   });
   */


  Processor.prototype.process = function process(css) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return new _lazyResult2.default(this, css, opts);
  };

  Processor.prototype.normalize = function normalize(plugins) {
    var normalized = [];
    for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var i = _ref;

      if (i.postcss) i = i.postcss;

      if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins);
      } else if (typeof i === 'function') {
        normalized.push(i);
      } else if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && (i.parse || i.stringify)) {
        throw new Error('PostCSS syntaxes cannot be used as plugins. ' + 'Instead, please use one of the ' + 'syntax/parser/stringifier options as ' + 'outlined in your PostCSS ' + 'runner documentation.');
      } else {
        throw new Error(i + ' is not a PostCSS plugin');
      }
    }
    return normalized;
  };

  return Processor;
}();

exports.default = Processor;

/**
 * @callback builder
 * @param {string} part          - part of generated CSS connected to this node
 * @param {Node}   node          - AST node
 * @param {"start"|"end"} [type] - nodes part type
 */

/**
 * @callback parser
 *
 * @param {string|toString} css   - string with input CSS or any object
 *                                  with toString() method, like a Buffer
 * @param {processOptions} [opts] - options with only `from` and `map` keys
 *
 * @return {Root} PostCSS AST
 */

/**
 * @callback stringifier
 *
 * @param {Node} node       - start node for stringifing. Usually {@link Root}.
 * @param {builder} builder - function to concatenate CSS from nodes parts
 *                            or generate string and source map
 *
 * @return {void}
 */

/**
 * @typedef {object} syntax
 * @property {parser} parse          - function to generate AST by string
 * @property {stringifier} stringify - function to generate string by AST
 */

/**
 * @typedef {object} toString
 * @property {function} toString
 */

/**
 * @callback pluginFunction
 * @param {Root} root     - parsed input CSS
 * @param {Result} result - result to set warnings or check other plugins
 */

/**
 * @typedef {object} Plugin
 * @property {function} postcss - PostCSS plugin function
 */

/**
 * @typedef {object} processOptions
 * @property {string} from             - the path of the CSS source file.
 *                                       You should always set `from`,
 *                                       because it is used in source map
 *                                       generation and syntax error messages.
 * @property {string} to               - the path where youll put the output
 *                                       CSS file. You should always set `to`
 *                                       to generate correct source maps.
 * @property {parser} parser           - function to generate AST by string
 * @property {stringifier} stringifier - class to generate string by AST
 * @property {syntax} syntax           - object with `parse` and `stringify`
 * @property {object} map              - source map options
 * @property {boolean} map.inline                    - does source map should
 *                                                     be embedded in the output
 *                                                     CSS as a base64-encoded
 *                                                     comment
 * @property {string|object|false|function} map.prev - source map content
 *                                                     from a previous
 *                                                     processing step
 *                                                     (for example, Sass).
 *                                                     PostCSS will try to find
 *                                                     previous map
 *                                                     automatically, so you
 *                                                     could disable it by
 *                                                     `false` value.
 * @property {boolean} map.sourcesContent            - does PostCSS should set
 *                                                     the origin content to map
 * @property {string|false} map.annotation           - does PostCSS should set
 *                                                     annotation comment to map
 * @property {string} map.from                       - override `from` in maps
 *                                                     `sources`
 */

module.exports = exports['default'];

}, {"1031":1031}];
window.modules["1048"] = [function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require(1044);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;
}, {"1044":1044}];
window.modules["1077"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _jsBase = require(610);

var _sourceMap = require(1079);

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _path = require(924);

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MapGenerator = function () {
    function MapGenerator(stringify, root, opts) {
        _classCallCheck(this, MapGenerator);

        this.stringify = stringify;
        this.mapOpts = opts.map || {};
        this.root = root;
        this.opts = opts;
    }

    MapGenerator.prototype.isMap = function isMap() {
        if (typeof this.opts.map !== 'undefined') {
            return !!this.opts.map;
        } else {
            return this.previous().length > 0;
        }
    };

    MapGenerator.prototype.previous = function previous() {
        var _this = this;

        if (!this.previousMaps) {
            this.previousMaps = [];
            this.root.walk(function (node) {
                if (node.source && node.source.input.map) {
                    var map = node.source.input.map;
                    if (_this.previousMaps.indexOf(map) === -1) {
                        _this.previousMaps.push(map);
                    }
                }
            });
        }

        return this.previousMaps;
    };

    MapGenerator.prototype.isInline = function isInline() {
        if (typeof this.mapOpts.inline !== 'undefined') {
            return this.mapOpts.inline;
        }

        var annotation = this.mapOpts.annotation;
        if (typeof annotation !== 'undefined' && annotation !== true) {
            return false;
        }

        if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.inline;
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.isSourcesContent = function isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== 'undefined') {
            return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.withContent();
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.clearAnnotation = function clearAnnotation() {
        if (this.mapOpts.annotation === false) return;

        var node = void 0;
        for (var i = this.root.nodes.length - 1; i >= 0; i--) {
            node = this.root.nodes[i];
            if (node.type !== 'comment') continue;
            if (node.text.indexOf('# sourceMappingURL=') === 0) {
                this.root.removeChild(i);
            }
        }
    };

    MapGenerator.prototype.setSourcesContent = function setSourcesContent() {
        var _this2 = this;

        var already = {};
        this.root.walk(function (node) {
            if (node.source) {
                var from = node.source.input.from;
                if (from && !already[from]) {
                    already[from] = true;
                    var relative = _this2.relative(from);
                    _this2.map.setSourceContent(relative, node.source.input.css);
                }
            }
        });
    };

    MapGenerator.prototype.applyPrevMaps = function applyPrevMaps() {
        for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var prev = _ref;

            var from = this.relative(prev.file);
            var root = prev.root || _path2.default.dirname(prev.file);
            var map = void 0;

            if (this.mapOpts.sourcesContent === false) {
                map = new _sourceMap2.default.SourceMapConsumer(prev.text);
                if (map.sourcesContent) {
                    map.sourcesContent = map.sourcesContent.map(function () {
                        return null;
                    });
                }
            } else {
                map = prev.consumer();
            }

            this.map.applySourceMap(map, from, this.relative(root));
        }
    };

    MapGenerator.prototype.isAnnotation = function isAnnotation() {
        if (this.isInline()) {
            return true;
        } else if (typeof this.mapOpts.annotation !== 'undefined') {
            return this.mapOpts.annotation;
        } else if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.annotation;
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.addAnnotation = function addAnnotation() {
        var content = void 0;

        if (this.isInline()) {
            content = 'data:application/json;base64,' + _jsBase.Base64.encode(this.map.toString());
        } else if (typeof this.mapOpts.annotation === 'string') {
            content = this.mapOpts.annotation;
        } else {
            content = this.outputFile() + '.map';
        }

        var eol = '\n';
        if (this.css.indexOf('\r\n') !== -1) eol = '\r\n';

        this.css += eol + '/*# sourceMappingURL=' + content + ' */';
    };

    MapGenerator.prototype.outputFile = function outputFile() {
        if (this.opts.to) {
            return this.relative(this.opts.to);
        } else if (this.opts.from) {
            return this.relative(this.opts.from);
        } else {
            return 'to.css';
        }
    };

    MapGenerator.prototype.generateMap = function generateMap() {
        this.generateString();
        if (this.isSourcesContent()) this.setSourcesContent();
        if (this.previous().length > 0) this.applyPrevMaps();
        if (this.isAnnotation()) this.addAnnotation();

        if (this.isInline()) {
            return [this.css];
        } else {
            return [this.css, this.map];
        }
    };

    MapGenerator.prototype.relative = function relative(file) {
        if (file.indexOf('<') === 0) return file;
        if (/^\w+:\/\//.test(file)) return file;

        var from = this.opts.to ? _path2.default.dirname(this.opts.to) : '.';

        if (typeof this.mapOpts.annotation === 'string') {
            from = _path2.default.dirname(_path2.default.resolve(from, this.mapOpts.annotation));
        }

        file = _path2.default.relative(from, file);
        if (_path2.default.sep === '\\') {
            return file.replace(/\\/g, '/');
        } else {
            return file;
        }
    };

    MapGenerator.prototype.sourcePath = function sourcePath(node) {
        if (this.mapOpts.from) {
            return this.mapOpts.from;
        } else {
            return this.relative(node.source.input.from);
        }
    };

    MapGenerator.prototype.generateString = function generateString() {
        var _this3 = this;

        this.css = '';
        this.map = new _sourceMap2.default.SourceMapGenerator({ file: this.outputFile() });

        var line = 1;
        var column = 1;

        var lines = void 0,
            last = void 0;
        this.stringify(this.root, function (str, node, type) {
            _this3.css += str;

            if (node && type !== 'end') {
                if (node.source && node.source.start) {
                    _this3.map.addMapping({
                        source: _this3.sourcePath(node),
                        generated: { line: line, column: column - 1 },
                        original: {
                            line: node.source.start.line,
                            column: node.source.start.column - 1
                        }
                    });
                } else {
                    _this3.map.addMapping({
                        source: '<no source>',
                        original: { line: 1, column: 0 },
                        generated: { line: line, column: column - 1 }
                    });
                }
            }

            lines = str.match(/\n/g);
            if (lines) {
                line += lines.length;
                last = str.lastIndexOf('\n');
                column = str.length - last;
            } else {
                column += str.length;
            }

            if (node && type !== 'start') {
                if (node.source && node.source.end) {
                    _this3.map.addMapping({
                        source: _this3.sourcePath(node),
                        generated: { line: line, column: column - 1 },
                        original: {
                            line: node.source.end.line,
                            column: node.source.end.column
                        }
                    });
                } else {
                    _this3.map.addMapping({
                        source: '<no source>',
                        original: { line: 1, column: 0 },
                        generated: { line: line, column: column - 1 }
                    });
                }
            }
        });
    };

    MapGenerator.prototype.generate = function generate() {
        this.clearAnnotation();

        if (this.isMap()) {
            return this.generateMap();
        } else {
            var result = '';
            this.stringify(this.root, function (i) {
                result += i;
            });
            return [result];
        }
    };

    return MapGenerator;
}();

exports.default = MapGenerator;
module.exports = exports['default'];

}, {"610":610,"924":924,"1079":1079}];
window.modules["1065"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _cssSyntaxError = require(1070);

var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);

var _stringifier = require(1080);

var _stringifier2 = _interopRequireDefault(_stringifier);

var _stringify = require(1075);

var _stringify2 = _interopRequireDefault(_stringify);

var _warnOnce = require(1063);

var _warnOnce2 = _interopRequireDefault(_warnOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cloneNode = function cloneNode(obj, parent) {
    var cloned = new obj.constructor();

    for (var i in obj) {
        if (!obj.hasOwnProperty(i)) continue;
        var value = obj[i];
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

        if (i === 'parent' && type === 'object') {
            if (parent) cloned[i] = parent;
        } else if (i === 'source') {
            cloned[i] = value;
        } else if (value instanceof Array) {
            cloned[i] = value.map(function (j) {
                return cloneNode(j, cloned);
            });
        } else if (i !== 'before' && i !== 'after' && i !== 'between' && i !== 'semicolon') {
            if (type === 'object' && value !== null) value = cloneNode(value);
            cloned[i] = value;
        }
    }

    return cloned;
};

/**
 * All node classes inherit the following common methods.
 *
 * @abstract
 */

var Node = function () {

    /**
     * @param {object} [defaults] - value for node properties
     */
    function Node() {
        var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Node);

        this.raws = {};
        if ((typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) !== 'object' && typeof defaults !== 'undefined') {
            throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));
        }
        for (var name in defaults) {
            this[name] = defaults[name];
        }
    }

    /**
     * Returns a CssSyntaxError instance containing the original position
     * of the node in the source, showing line and column numbers and also
     * a small excerpt to facilitate debugging.
     *
     * If present, an input source map will be used to get the original position
     * of the source, even from a previous compilation step
     * (e.g., from Sass compilation).
     *
     * This method produces very useful error messages.
     *
     * @param {string} message     - error description
     * @param {object} [opts]      - options
     * @param {string} opts.plugin - plugin name that created this error.
     *                               PostCSS will set it automatically.
     * @param {string} opts.word   - a word inside a nodes string that should
     *                               be highlighted as the source of the error
     * @param {number} opts.index  - an index inside a nodes string that should
     *                               be highlighted as the source of the error
     *
     * @return {CssSyntaxError} error object to throw it
     *
     * @example
     * if ( !variables[name] ) {
     *   throw decl.error('Unknown variable ' + name, { word: name });
     *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
     *   //   color: $black
     *   // a
     *   //          ^
     *   //   background: white
     * }
     */


    Node.prototype.error = function error(message) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (this.source) {
            var pos = this.positionBy(opts);
            return this.source.input.error(message, pos.line, pos.column, opts);
        } else {
            return new _cssSyntaxError2.default(message);
        }
    };

    /**
     * This method is provided as a convenience wrapper for {@link Result#warn}.
     *
     * @param {Result} result      - the {@link Result} instance
     *                               that will receive the warning
     * @param {string} text        - warning message
     * @param {object} [opts]      - options
     * @param {string} opts.plugin - plugin name that created this warning.
     *                               PostCSS will set it automatically.
     * @param {string} opts.word   - a word inside a nodes string that should
     *                               be highlighted as the source of the warning
     * @param {number} opts.index  - an index inside a nodes string that should
     *                               be highlighted as the source of the warning
     *
     * @return {Warning} created warning object
     *
     * @example
     * const plugin = postcss.plugin('postcss-deprecated', () => {
     *   return (root, result) => {
     *     root.walkDecls('bad', decl => {
     *       decl.warn(result, 'Deprecated property bad');
     *     });
     *   };
     * });
     */


    Node.prototype.warn = function warn(result, text, opts) {
        var data = { node: this };
        for (var i in opts) {
            data[i] = opts[i];
        }return result.warn(text, data);
    };

    /**
     * Removes the node from its parent and cleans the parent properties
     * from the node and its children.
     *
     * @example
     * if ( decl.prop.match(/^-webkit-/) ) {
     *   decl.remove();
     * }
     *
     * @return {Node} node to make calls chain
     */


    Node.prototype.remove = function remove() {
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.parent = undefined;
        return this;
    };

    /**
     * Returns a CSS string representing the node.
     *
     * @param {stringifier|syntax} [stringifier] - a syntax to use
     *                                             in string generation
     *
     * @return {string} CSS string of this node
     *
     * @example
     * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
     */


    Node.prototype.toString = function toString() {
        var stringifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _stringify2.default;

        if (stringifier.stringify) stringifier = stringifier.stringify;
        var result = '';
        stringifier(this, function (i) {
            result += i;
        });
        return result;
    };

    /**
     * Returns a clone of the node.
     *
     * The resulting cloned node and its (cloned) children will have
     * a clean parent and code style properties.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @example
     * const cloned = decl.clone({ prop: '-moz-' + decl.prop });
     * cloned.raws.before  //=> undefined
     * cloned.parent       //=> undefined
     * cloned.toString()   //=> -moz-transform: scale(0)
     *
     * @return {Node} clone of the node
     */


    Node.prototype.clone = function clone() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = cloneNode(this);
        for (var name in overrides) {
            cloned[name] = overrides[name];
        }
        return cloned;
    };

    /**
     * Shortcut to clone the node and insert the resulting cloned node
     * before the current node.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @example
     * decl.cloneBefore({ prop: '-moz-' + decl.prop });
     *
     * @return {Node} - new node
     */


    Node.prototype.cloneBefore = function cloneBefore() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
    };

    /**
     * Shortcut to clone the node and insert the resulting cloned node
     * after the current node.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @return {Node} - new node
     */


    Node.prototype.cloneAfter = function cloneAfter() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
    };

    /**
     * Inserts node(s) before the current node and removes the current node.
     *
     * @param {...Node} nodes - node(s) to replace current one
     *
     * @example
     * if ( atrule.name == 'mixin' ) {
     *   atrule.replaceWith(mixinRules[atrule.params]);
     * }
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.replaceWith = function replaceWith() {
        if (this.parent) {
            for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
                nodes[_key] = arguments[_key];
            }

            for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var node = _ref;

                this.parent.insertBefore(this, node);
            }

            this.remove();
        }

        return this;
    };

    /**
     * Removes the node from its current parent and inserts it
     * at the end of `newParent`.
     *
     * This will clean the `before` and `after` code {@link Node#raws} data
     * from the node and replace them with the indentation style of `newParent`.
     * It will also clean the `between` property
     * if `newParent` is in another {@link Root}.
     *
     * @param {Container} newParent - container node where the current node
     *                                will be moved
     *
     * @example
     * atrule.moveTo(atrule.root());
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveTo = function moveTo(newParent) {
        this.cleanRaws(this.root() === newParent.root());
        this.remove();
        newParent.append(this);
        return this;
    };

    /**
     * Removes the node from its current parent and inserts it into
     * a new parent before `otherNode`.
     *
     * This will also clean the nodes code style properties just as it would
     * in {@link Node#moveTo}.
     *
     * @param {Node} otherNode - node that will be before current node
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveBefore = function moveBefore(otherNode) {
        this.cleanRaws(this.root() === otherNode.root());
        this.remove();
        otherNode.parent.insertBefore(otherNode, this);
        return this;
    };

    /**
     * Removes the node from its current parent and inserts it into
     * a new parent after `otherNode`.
     *
     * This will also clean the nodes code style properties just as it would
     * in {@link Node#moveTo}.
     *
     * @param {Node} otherNode - node that will be after current node
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.moveAfter = function moveAfter(otherNode) {
        this.cleanRaws(this.root() === otherNode.root());
        this.remove();
        otherNode.parent.insertAfter(otherNode, this);
        return this;
    };

    /**
     * Returns the next child of the nodes parent.
     * Returns `undefined` if the current node is the last child.
     *
     * @return {Node|undefined} next node
     *
     * @example
     * if ( comment.text === 'delete next' ) {
     *   const next = comment.next();
     *   if ( next ) {
     *     next.remove();
     *   }
     * }
     */


    Node.prototype.next = function next() {
        var index = this.parent.index(this);
        return this.parent.nodes[index + 1];
    };

    /**
     * Returns the previous child of the nodes parent.
     * Returns `undefined` if the current node is the first child.
     *
     * @return {Node|undefined} previous node
     *
     * @example
     * const annotation = decl.prev();
     * if ( annotation.type == 'comment' ) {
     *  readAnnotation(annotation.text);
     * }
     */


    Node.prototype.prev = function prev() {
        var index = this.parent.index(this);
        return this.parent.nodes[index - 1];
    };

    Node.prototype.toJSON = function toJSON() {
        var fixed = {};

        for (var name in this) {
            if (!this.hasOwnProperty(name)) continue;
            if (name === 'parent') continue;
            var value = this[name];

            if (value instanceof Array) {
                fixed[name] = value.map(function (i) {
                    if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && i.toJSON) {
                        return i.toJSON();
                    } else {
                        return i;
                    }
                });
            } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.toJSON) {
                fixed[name] = value.toJSON();
            } else {
                fixed[name] = value;
            }
        }

        return fixed;
    };

    /**
     * Returns a {@link Node#raws} value. If the node is missing
     * the code style property (because the node was manually built or cloned),
     * PostCSS will try to autodetect the code style property by looking
     * at other nodes in the tree.
     *
     * @param {string} prop          - name of code style property
     * @param {string} [defaultType] - name of default value, it can be missed
     *                                 if the value is the same as prop
     *
     * @example
     * const root = postcss.parse('a { background: white }');
     * root.nodes[0].append({ prop: 'color', value: 'black' });
     * root.nodes[0].nodes[1].raws.before   //=> undefined
     * root.nodes[0].nodes[1].raw('before') //=> ' '
     *
     * @return {string} code style value
     */


    Node.prototype.raw = function raw(prop, defaultType) {
        var str = new _stringifier2.default();
        return str.raw(this, prop, defaultType);
    };

    /**
     * Finds the Root instance of the nodes tree.
     *
     * @example
     * root.nodes[0].nodes[0].root() === root
     *
     * @return {Root} root parent
     */


    Node.prototype.root = function root() {
        var result = this;
        while (result.parent) {
            result = result.parent;
        }return result;
    };

    Node.prototype.cleanRaws = function cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween) delete this.raws.between;
    };

    Node.prototype.positionInside = function positionInside(index) {
        var string = this.toString();
        var column = this.source.start.column;
        var line = this.source.start.line;

        for (var i = 0; i < index; i++) {
            if (string[i] === '\n') {
                column = 1;
                line += 1;
            } else {
                column += 1;
            }
        }

        return { line: line, column: column };
    };

    Node.prototype.positionBy = function positionBy(opts) {
        var pos = this.source.start;
        if (opts.index) {
            pos = this.positionInside(opts.index);
        } else if (opts.word) {
            var index = this.toString().indexOf(opts.word);
            if (index !== -1) pos = this.positionInside(index);
        }
        return pos;
    };

    Node.prototype.removeSelf = function removeSelf() {
        (0, _warnOnce2.default)('Node#removeSelf is deprecated. Use Node#remove.');
        return this.remove();
    };

    Node.prototype.replace = function replace(nodes) {
        (0, _warnOnce2.default)('Node#replace is deprecated. Use Node#replaceWith');
        return this.replaceWith(nodes);
    };

    Node.prototype.style = function style(own, detect) {
        (0, _warnOnce2.default)('Node#style() is deprecated. Use Node#raw()');
        return this.raw(own, detect);
    };

    Node.prototype.cleanStyles = function cleanStyles(keepBetween) {
        (0, _warnOnce2.default)('Node#cleanStyles() is deprecated. Use Node#cleanRaws()');
        return this.cleanRaws(keepBetween);
    };

    _createClass(Node, [{
        key: 'before',
        get: function get() {
            (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');
            return this.raws.before;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');
            this.raws.before = val;
        }
    }, {
        key: 'between',
        get: function get() {
            (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');
            return this.raws.between;
        },
        set: function set(val) {
            (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');
            this.raws.between = val;
        }

        /**
         * @memberof Node#
         * @member {string} type - String representing the nodes type.
         *                         Possible values are `root`, `atrule`, `rule`,
         *                         `decl`, or `comment`.
         *
         * @example
         * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
         */

        /**
         * @memberof Node#
         * @member {Container} parent - the nodes parent node.
         *
         * @example
         * root.nodes[0].parent == root;
         */

        /**
         * @memberof Node#
         * @member {source} source - the input source of the node
         *
         * The property is used in source map generation.
         *
         * If you create a node manually (e.g., with `postcss.decl()`),
         * that node will not have a `source` property and will be absent
         * from the source map. For this reason, the plugin developer should
         * consider cloning nodes to create new ones (in which case the new nodes
         * source will reference the original, cloned node) or setting
         * the `source` property manually.
         *
         * ```js
         * // Bad
         * const prefixed = postcss.decl({
         *   prop: '-moz-' + decl.prop,
         *   value: decl.value
         * });
         *
         * // Good
         * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });
         * ```
         *
         * ```js
         * if ( atrule.name == 'add-link' ) {
         *   const rule = postcss.rule({ selector: 'a', source: atrule.source });
         *   atrule.parent.insertBefore(atrule, rule);
         * }
         * ```
         *
         * @example
         * decl.source.input.from //=> '/home/ai/a.sass'
         * decl.source.start      //=> { line: 10, column: 2 }
         * decl.source.end        //=> { line: 10, column: 12 }
         */

        /**
         * @memberof Node#
         * @member {object} raws - Information to generate byte-to-byte equal
         *                         node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `after`: the space symbols after the last child of the node
         *   to the end of the node.
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `semicolon`: contains true if the last child has
         *   an (optional) semicolon.
         * * `afterName`: the space between the at-rule name and its parameters.
         * * `left`: the space symbols between `/*` and the comments text.
         * * `right`: the space symbols between the comments text
         *   and <code>*&#47;</code>.
         * * `important`: the content of the important statement,
         *   if it is not just `!important`.
         *
         * PostCSS cleans selectors, declaration values and at-rule parameters
         * from comments and extra spaces, but it stores origin content in raws
         * properties. As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('a {\n  color:black\n}')
         * root.first.first.raws //=> { before: '\n  ', between: ':' }
         */

    }]);

    return Node;
}();

exports.default = Node;

/**
 * @typedef {object} position
 * @property {number} line   - source line in file
 * @property {number} column - source column in file
 */

/**
 * @typedef {object} source
 * @property {Input} input    - {@link Input} with input file
 * @property {position} start - The starting position of the nodes source
 * @property {position} end   - The ending position of the nodes source
 */

module.exports = exports['default'];

}, {"1063":1063,"1070":1070,"1075":1075,"1080":1080}];
window.modules["1069"] = [function(require,module,exports){'use strict';

exports.__esModule = true;
exports.default = parse;

var _parser = require(1058);

var _parser2 = _interopRequireDefault(_parser);

var _input = require(1055);

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(css, opts) {
    if (opts && opts.safe) {
        throw new Error('Option safe was removed. ' + 'Use parser: require("postcss-safe-parser")');
    }

    var input = new _input2.default(css, opts);

    var parser = new _parser2.default(input);
    try {
        parser.tokenize();
        parser.loop();
    } catch (e) {
        if (e.name === 'CssSyntaxError' && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
                e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';
            } else if (/\.sass/i.test(opts.from)) {
                e.message += '\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';
            } else if (/\.less$/i.test(opts.from)) {
                e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';
            }
        }
        throw e;
    }

    return parser.root;
}
module.exports = exports['default'];

}, {"1055":1055,"1058":1058}];
window.modules["1058"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _declaration = require(1066);

var _declaration2 = _interopRequireDefault(_declaration);

var _tokenize = require(1056);

var _tokenize2 = _interopRequireDefault(_tokenize);

var _comment = require(1057);

var _comment2 = _interopRequireDefault(_comment);

var _atRule = require(1062);

var _atRule2 = _interopRequireDefault(_atRule);

var _root = require(1068);

var _root2 = _interopRequireDefault(_root);

var _rule = require(1067);

var _rule2 = _interopRequireDefault(_rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Parser = function () {
    function Parser(input) {
        _classCallCheck(this, Parser);

        this.input = input;

        this.pos = 0;
        this.root = new _root2.default();
        this.current = this.root;
        this.spaces = '';
        this.semicolon = false;

        this.root.source = { input: input, start: { line: 1, column: 1 } };
    }

    Parser.prototype.tokenize = function tokenize() {
        this.tokens = (0, _tokenize2.default)(this.input);
    };

    Parser.prototype.loop = function loop() {
        var token = void 0;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];

            switch (token[0]) {

                case 'space':
                case ';':
                    this.spaces += token[1];
                    break;

                case '}':
                    this.end(token);
                    break;

                case 'comment':
                    this.comment(token);
                    break;

                case 'at-word':
                    this.atrule(token);
                    break;

                case '{':
                    this.emptyRule(token);
                    break;

                default:
                    this.other();
                    break;
            }

            this.pos += 1;
        }
        this.endFile();
    };

    Parser.prototype.comment = function comment(token) {
        var node = new _comment2.default();
        this.init(node, token[2], token[3]);
        node.source.end = { line: token[4], column: token[5] };

        var text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
        } else {
            var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
        }
    };

    Parser.prototype.emptyRule = function emptyRule(token) {
        var node = new _rule2.default();
        this.init(node, token[2], token[3]);
        node.selector = '';
        node.raws.between = '';
        this.current = node;
    };

    Parser.prototype.other = function other() {
        var token = void 0;
        var end = false;
        var type = null;
        var colon = false;
        var bracket = null;
        var brackets = [];

        var start = this.pos;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];
            type = token[0];

            if (type === '(' || type === '[') {
                if (!bracket) bracket = token;
                brackets.push(type === '(' ? ')' : ']');
            } else if (brackets.length === 0) {
                if (type === ';') {
                    if (colon) {
                        this.decl(this.tokens.slice(start, this.pos + 1));
                        return;
                    } else {
                        break;
                    }
                } else if (type === '{') {
                    this.rule(this.tokens.slice(start, this.pos + 1));
                    return;
                } else if (type === '}') {
                    this.pos -= 1;
                    end = true;
                    break;
                } else if (type === ':') {
                    colon = true;
                }
            } else if (type === brackets[brackets.length - 1]) {
                brackets.pop();
                if (brackets.length === 0) bracket = null;
            }

            this.pos += 1;
        }
        if (this.pos === this.tokens.length) {
            this.pos -= 1;
            end = true;
        }

        if (brackets.length > 0) this.unclosedBracket(bracket);

        if (end && colon) {
            while (this.pos > start) {
                token = this.tokens[this.pos][0];
                if (token !== 'space' && token !== 'comment') break;
                this.pos -= 1;
            }
            this.decl(this.tokens.slice(start, this.pos + 1));
            return;
        }

        this.unknownWord(start);
    };

    Parser.prototype.rule = function rule(tokens) {
        tokens.pop();

        var node = new _rule2.default();
        this.init(node, tokens[0][2], tokens[0][3]);

        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, 'selector', tokens);
        this.current = node;
    };

    Parser.prototype.decl = function decl(tokens) {
        var node = new _declaration2.default();
        this.init(node);

        var last = tokens[tokens.length - 1];
        if (last[0] === ';') {
            this.semicolon = true;
            tokens.pop();
        }
        if (last[4]) {
            node.source.end = { line: last[4], column: last[5] };
        } else {
            node.source.end = { line: last[2], column: last[3] };
        }

        while (tokens[0][0] !== 'word') {
            node.raws.before += tokens.shift()[1];
        }
        node.source.start = { line: tokens[0][2], column: tokens[0][3] };

        node.prop = '';
        while (tokens.length) {
            var type = tokens[0][0];
            if (type === ':' || type === 'space' || type === 'comment') {
                break;
            }
            node.prop += tokens.shift()[1];
        }

        node.raws.between = '';

        var token = void 0;
        while (tokens.length) {
            token = tokens.shift();

            if (token[0] === ':') {
                node.raws.between += token[1];
                break;
            } else {
                node.raws.between += token[1];
            }
        }

        if (node.prop[0] === '_' || node.prop[0] === '*') {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
        }
        node.raws.between += this.spacesAndCommentsFromStart(tokens);
        this.precheckMissedSemicolon(tokens);

        for (var i = tokens.length - 1; i > 0; i--) {
            token = tokens[i];
            if (token[1] === '!important') {
                node.important = true;
                var string = this.stringFrom(tokens, i);
                string = this.spacesFromEnd(tokens) + string;
                if (string !== ' !important') node.raws.important = string;
                break;
            } else if (token[1] === 'important') {
                var cache = tokens.slice(0);
                var str = '';
                for (var j = i; j > 0; j--) {
                    var _type = cache[j][0];
                    if (str.trim().indexOf('!') === 0 && _type !== 'space') {
                        break;
                    }
                    str = cache.pop()[1] + str;
                }
                if (str.trim().indexOf('!') === 0) {
                    node.important = true;
                    node.raws.important = str;
                    tokens = cache;
                }
            }

            if (token[0] !== 'space' && token[0] !== 'comment') {
                break;
            }
        }

        this.raw(node, 'value', tokens);

        if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);
    };

    Parser.prototype.atrule = function atrule(token) {
        var node = new _atRule2.default();
        node.name = token[1].slice(1);
        if (node.name === '') {
            this.unnamedAtrule(node, token);
        }
        this.init(node, token[2], token[3]);

        var last = false;
        var open = false;
        var params = [];

        this.pos += 1;
        while (this.pos < this.tokens.length) {
            token = this.tokens[this.pos];

            if (token[0] === ';') {
                node.source.end = { line: token[2], column: token[3] };
                this.semicolon = true;
                break;
            } else if (token[0] === '{') {
                open = true;
                break;
            } else if (token[0] === '}') {
                this.end(token);
                break;
            } else {
                params.push(token);
            }

            this.pos += 1;
        }
        if (this.pos === this.tokens.length) {
            last = true;
        }

        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, 'params', params);
            if (last) {
                token = params[params.length - 1];
                node.source.end = { line: token[4], column: token[5] };
                this.spaces = node.raws.between;
                node.raws.between = '';
            }
        } else {
            node.raws.afterName = '';
            node.params = '';
        }

        if (open) {
            node.nodes = [];
            this.current = node;
        }
    };

    Parser.prototype.end = function end(token) {
        if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;

        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
        this.spaces = '';

        if (this.current.parent) {
            this.current.source.end = { line: token[2], column: token[3] };
            this.current = this.current.parent;
        } else {
            this.unexpectedClose(token);
        }
    };

    Parser.prototype.endFile = function endFile() {
        if (this.current.parent) this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
    };

    // Helpers

    Parser.prototype.init = function init(node, line, column) {
        this.current.push(node);

        node.source = { start: { line: line, column: column }, input: this.input };
        node.raws.before = this.spaces;
        this.spaces = '';
        if (node.type !== 'comment') this.semicolon = false;
    };

    Parser.prototype.raw = function raw(node, prop, tokens) {
        var token = void 0,
            type = void 0;
        var length = tokens.length;
        var value = '';
        var clean = true;
        for (var i = 0; i < length; i += 1) {
            token = tokens[i];
            type = token[0];
            if (type === 'comment' || type === 'space' && i === length - 1) {
                clean = false;
            } else {
                value += token[1];
            }
        }
        if (!clean) {
            var raw = tokens.reduce(function (all, i) {
                return all + i[1];
            }, '');
            node.raws[prop] = { value: value, raw: raw };
        }
        node[prop] = value;
    };

    Parser.prototype.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {
        var lastTokenType = void 0;
        var spaces = '';
        while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
            spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
    };

    Parser.prototype.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {
        var next = void 0;
        var spaces = '';
        while (tokens.length) {
            next = tokens[0][0];
            if (next !== 'space' && next !== 'comment') break;
            spaces += tokens.shift()[1];
        }
        return spaces;
    };

    Parser.prototype.spacesFromEnd = function spacesFromEnd(tokens) {
        var lastTokenType = void 0;
        var spaces = '';
        while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space') break;
            spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
    };

    Parser.prototype.stringFrom = function stringFrom(tokens, from) {
        var result = '';
        for (var i = from; i < tokens.length; i++) {
            result += tokens[i][1];
        }
        tokens.splice(from, tokens.length - from);
        return result;
    };

    Parser.prototype.colon = function colon(tokens) {
        var brackets = 0;
        var token = void 0,
            type = void 0,
            prev = void 0;
        for (var i = 0; i < tokens.length; i++) {
            token = tokens[i];
            type = token[0];

            if (type === '(') {
                brackets += 1;
            } else if (type === ')') {
                brackets -= 1;
            } else if (brackets === 0 && type === ':') {
                if (!prev) {
                    this.doubleColon(token);
                } else if (prev[0] === 'word' && prev[1] === 'progid') {
                    continue;
                } else {
                    return i;
                }
            }

            prev = token;
        }
        return false;
    };

    // Errors

    Parser.prototype.unclosedBracket = function unclosedBracket(bracket) {
        throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);
    };

    Parser.prototype.unknownWord = function unknownWord(start) {
        var token = this.tokens[start];
        throw this.input.error('Unknown word', token[2], token[3]);
    };

    Parser.prototype.unexpectedClose = function unexpectedClose(token) {
        throw this.input.error('Unexpected }', token[2], token[3]);
    };

    Parser.prototype.unclosedBlock = function unclosedBlock() {
        var pos = this.current.source.start;
        throw this.input.error('Unclosed block', pos.line, pos.column);
    };

    Parser.prototype.doubleColon = function doubleColon(token) {
        throw this.input.error('Double colon', token[2], token[3]);
    };

    Parser.prototype.unnamedAtrule = function unnamedAtrule(node, token) {
        throw this.input.error('At-rule without name', token[2], token[3]);
    };

    Parser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {
        // Hook for Safe Parser
        tokens;
    };

    Parser.prototype.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
        var colon = this.colon(tokens);
        if (colon === false) return;

        var founded = 0;
        var token = void 0;
        for (var j = colon - 1; j >= 0; j--) {
            token = tokens[j];
            if (token[0] !== 'space') {
                founded += 1;
                if (founded === 2) break;
            }
        }
        throw this.input.error('Missed semicolon', token[2], token[3]);
    };

    return Parser;
}();

exports.default = Parser;
module.exports = exports['default'];

}, {"1056":1056,"1057":1057,"1062":1062,"1066":1066,"1067":1067,"1068":1068}];
window.modules["1073"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _jsBase = require(610);

var _sourceMap = require(1079);

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _path = require(924);

var _path2 = _interopRequireDefault(_path);

var _fs = require(272);

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Source map information from input CSS.
 * For example, source map after Sass compiler.
 *
 * This class will automatically find source map in input CSS or in file system
 * near input file (according `from` option).
 *
 * @example
 * const root = postcss.parse(css, { from: 'a.sass.css' });
 * root.input.map //=> PreviousMap
 */
var PreviousMap = function () {

    /**
     * @param {string}         css    - input CSS source
     * @param {processOptions} [opts] - {@link Processor#process} options
     */
    function PreviousMap(css, opts) {
        _classCallCheck(this, PreviousMap);

        this.loadAnnotation(css);
        /**
         * @member {boolean} - Was source map inlined by data-uri to input CSS.
         */
        this.inline = this.startWith(this.annotation, 'data:');

        var prev = opts.map ? opts.map.prev : undefined;
        var text = this.loadMap(opts.from, prev);
        if (text) this.text = text;
    }

    /**
     * Create a instance of `SourceMapGenerator` class
     * from the `source-map` library to work with source map information.
     *
     * It is lazy method, so it will create object only on first call
     * and then it will use cache.
     *
     * @return {SourceMapGenerator} object with source map information
     */


    PreviousMap.prototype.consumer = function consumer() {
        if (!this.consumerCache) {
            this.consumerCache = new _sourceMap2.default.SourceMapConsumer(this.text);
        }
        return this.consumerCache;
    };

    /**
     * Does source map contains `sourcesContent` with input source text.
     *
     * @return {boolean} Is `sourcesContent` present
     */


    PreviousMap.prototype.withContent = function withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    };

    PreviousMap.prototype.startWith = function startWith(string, start) {
        if (!string) return false;
        return string.substr(0, start.length) === start;
    };

    PreviousMap.prototype.loadAnnotation = function loadAnnotation(css) {
        var match = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//);
        if (match) this.annotation = match[1].trim();
    };

    PreviousMap.prototype.decodeInline = function decodeInline(text) {
        var utfd64 = 'data:application/json;charset=utf-8;base64,';
        var utf64 = 'data:application/json;charset=utf8;base64,';
        var b64 = 'data:application/json;base64,';
        var uri = 'data:application/json,';

        if (this.startWith(text, uri)) {
            return decodeURIComponent(text.substr(uri.length));
        } else if (this.startWith(text, b64)) {
            return _jsBase.Base64.decode(text.substr(b64.length));
        } else if (this.startWith(text, utf64)) {
            return _jsBase.Base64.decode(text.substr(utf64.length));
        } else if (this.startWith(text, utfd64)) {
            return _jsBase.Base64.decode(text.substr(utfd64.length));
        } else {
            var encoding = text.match(/data:application\/json;([^,]+),/)[1];
            throw new Error('Unsupported source map encoding ' + encoding);
        }
    };

    PreviousMap.prototype.loadMap = function loadMap(file, prev) {
        if (prev === false) return false;

        if (prev) {
            if (typeof prev === 'string') {
                return prev;
            } else if (typeof prev === 'function') {
                var prevPath = prev(file);
                if (prevPath && _fs2.default.existsSync && _fs2.default.existsSync(prevPath)) {
                    return _fs2.default.readFileSync(prevPath, 'utf-8').toString().trim();
                } else {
                    throw new Error('Unable to load previous source map: ' + prevPath.toString());
                }
            } else if (prev instanceof _sourceMap2.default.SourceMapConsumer) {
                return _sourceMap2.default.SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof _sourceMap2.default.SourceMapGenerator) {
                return prev.toString();
            } else if (this.isMap(prev)) {
                return JSON.stringify(prev);
            } else {
                throw new Error('Unsupported previous source map format: ' + prev.toString());
            }
        } else if (this.inline) {
            return this.decodeInline(this.annotation);
        } else if (this.annotation) {
            var map = this.annotation;
            if (file) map = _path2.default.join(_path2.default.dirname(file), map);

            this.root = _path2.default.dirname(map);
            if (_fs2.default.existsSync && _fs2.default.existsSync(map)) {
                return _fs2.default.readFileSync(map, 'utf-8').toString().trim();
            } else {
                return false;
            }
        }
    };

    PreviousMap.prototype.isMap = function isMap(map) {
        if ((typeof map === 'undefined' ? 'undefined' : _typeof(map)) !== 'object') return false;
        return typeof map.mappings === 'string' || typeof map._mappings === 'string';
    };

    return PreviousMap;
}();

exports.default = PreviousMap;
module.exports = exports['default'];

}, {"272":272,"610":610,"924":924,"1079":1079}];
window.modules["1081"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _lazyResult = require(1074);

var _lazyResult2 = _interopRequireDefault(_lazyResult);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * @example
 * const processor = postcss([autoprefixer, precss]);
 * processor.process(css1).then(result => console.log(result.css));
 * processor.process(css2).then(result => console.log(result.css));
 */
var Processor = function () {

  /**
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
   *        plugins. See {@link Processor#use} for plugin format.
   */
  function Processor() {
    var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, Processor);

    /**
     * @member {string} - Current PostCSS version.
     *
     * @example
     * if ( result.processor.version.split('.')[0] !== '5' ) {
     *   throw new Error('This plugin works only with PostCSS 5');
     * }
     */
    this.version = '5.2.18';
    /**
     * @member {pluginFunction[]} - Plugins added to this processor.
     *
     * @example
     * const processor = postcss([autoprefixer, precss]);
     * processor.plugins.length //=> 2
     */
    this.plugins = this.normalize(plugins);
  }

  /**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin created by {@link postcss.plugin} method.
   * * A function. PostCSS will pass the function a @{link Root}
   *   as the first argument and current {@link Result} instance
   *   as the second.
   * * An object with a `postcss` method. PostCSS will use that method
   *   as described in #2.
   * * Another {@link Processor} instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * @param {Plugin|pluginFunction|Processor} plugin - PostCSS plugin
   *                                                   or {@link Processor}
   *                                                   with plugins
   *
   * @example
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(precss);
   *
   * @return {Processes} current processor to make methods chain
   */


  Processor.prototype.use = function use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]));
    return this;
  };

  /**
   * Parses source CSS and returns a {@link LazyResult} Promise proxy.
   * Because some plugins can be asynchronous it doesnt make
   * any transformations. Transformations will be applied
   * in the {@link LazyResult} methods.
   *
   * @param {string|toString|Result} css - String with input CSS or
   *                                       any object with a `toString()`
   *                                       method, like a Buffer.
   *                                       Optionally, send a {@link Result}
   *                                       instance and the processor will
   *                                       take the {@link Root} from it.
   * @param {processOptions} [opts]      - options
   *
   * @return {LazyResult} Promise proxy
   *
   * @example
   * processor.process(css, { from: 'a.css', to: 'a.out.css' })
   *   .then(result => {
   *      console.log(result.css);
   *   });
   */


  Processor.prototype.process = function process(css) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return new _lazyResult2.default(this, css, opts);
  };

  Processor.prototype.normalize = function normalize(plugins) {
    var normalized = [];
    for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var i = _ref;

      if (i.postcss) i = i.postcss;

      if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins);
      } else if (typeof i === 'function') {
        normalized.push(i);
      } else if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && (i.parse || i.stringify)) {
        throw new Error('PostCSS syntaxes cannot be used as plugins. ' + 'Instead, please use one of the ' + 'syntax/parser/stringifier options as ' + 'outlined in your PostCSS ' + 'runner documentation.');
      } else {
        throw new Error(i + ' is not a PostCSS plugin');
      }
    }
    return normalized;
  };

  return Processor;
}();

exports.default = Processor;

/**
 * @callback builder
 * @param {string} part          - part of generated CSS connected to this node
 * @param {Node}   node          - AST node
 * @param {"start"|"end"} [type] - nodes part type
 */

/**
 * @callback parser
 *
 * @param {string|toString} css   - string with input CSS or any object
 *                                  with toString() method, like a Buffer
 * @param {processOptions} [opts] - options with only `from` and `map` keys
 *
 * @return {Root} PostCSS AST
 */

/**
 * @callback stringifier
 *
 * @param {Node} node       - start node for stringifing. Usually {@link Root}.
 * @param {builder} builder - function to concatenate CSS from nodes parts
 *                            or generate string and source map
 *
 * @return {void}
 */

/**
 * @typedef {object} syntax
 * @property {parser} parse          - function to generate AST by string
 * @property {stringifier} stringify - function to generate string by AST
 */

/**
 * @typedef {object} toString
 * @property {function} toString
 */

/**
 * @callback pluginFunction
 * @param {Root} root     - parsed input CSS
 * @param {Result} result - result to set warnings or check other plugins
 */

/**
 * @typedef {object} Plugin
 * @property {function} postcss - PostCSS plugin function
 */

/**
 * @typedef {object} processOptions
 * @property {string} from             - the path of the CSS source file.
 *                                       You should always set `from`,
 *                                       because it is used in source map
 *                                       generation and syntax error messages.
 * @property {string} to               - the path where youll put the output
 *                                       CSS file. You should always set `to`
 *                                       to generate correct source maps.
 * @property {parser} parser           - function to generate AST by string
 * @property {stringifier} stringifier - class to generate string by AST
 * @property {syntax} syntax           - object with `parse` and `stringify`
 * @property {object} map              - source map options
 * @property {boolean} map.inline                    - does source map should
 *                                                     be embedded in the output
 *                                                     CSS as a base64-encoded
 *                                                     comment
 * @property {string|object|false|function} map.prev - source map content
 *                                                     from a previous
 *                                                     processing step
 *                                                     (for example, Sass).
 *                                                     PostCSS will try to find
 *                                                     previous map
 *                                                     automatically, so you
 *                                                     could disable it by
 *                                                     `false` value.
 * @property {boolean} map.sourcesContent            - does PostCSS should set
 *                                                     the origin content to map
 * @property {string|false} map.annotation           - does PostCSS should set
 *                                                     annotation comment to map
 * @property {string} map.from                       - override `from` in maps
 *                                                     `sources`
 */

module.exports = exports['default'];

}, {"1074":1074}];
window.modules["1088"] = [function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require(1084);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;
}, {"1084":1084}];
window.modules["1111"] = [function(require,module,exports){(function (Buffer){
'use strict';

exports.__esModule = true;

var _sourceMap = require(1113);

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _path = require(924);

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MapGenerator = function () {
    function MapGenerator(stringify, root, opts) {
        _classCallCheck(this, MapGenerator);

        this.stringify = stringify;
        this.mapOpts = opts.map || {};
        this.root = root;
        this.opts = opts;
    }

    MapGenerator.prototype.isMap = function isMap() {
        if (typeof this.opts.map !== 'undefined') {
            return !!this.opts.map;
        } else {
            return this.previous().length > 0;
        }
    };

    MapGenerator.prototype.previous = function previous() {
        var _this = this;

        if (!this.previousMaps) {
            this.previousMaps = [];
            this.root.walk(function (node) {
                if (node.source && node.source.input.map) {
                    var map = node.source.input.map;
                    if (_this.previousMaps.indexOf(map) === -1) {
                        _this.previousMaps.push(map);
                    }
                }
            });
        }

        return this.previousMaps;
    };

    MapGenerator.prototype.isInline = function isInline() {
        if (typeof this.mapOpts.inline !== 'undefined') {
            return this.mapOpts.inline;
        }

        var annotation = this.mapOpts.annotation;
        if (typeof annotation !== 'undefined' && annotation !== true) {
            return false;
        }

        if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.inline;
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.isSourcesContent = function isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== 'undefined') {
            return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.withContent();
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.clearAnnotation = function clearAnnotation() {
        if (this.mapOpts.annotation === false) return;

        var node = void 0;
        for (var i = this.root.nodes.length - 1; i >= 0; i--) {
            node = this.root.nodes[i];
            if (node.type !== 'comment') continue;
            if (node.text.indexOf('# sourceMappingURL=') === 0) {
                this.root.removeChild(i);
            }
        }
    };

    MapGenerator.prototype.setSourcesContent = function setSourcesContent() {
        var _this2 = this;

        var already = {};
        this.root.walk(function (node) {
            if (node.source) {
                var from = node.source.input.from;
                if (from && !already[from]) {
                    already[from] = true;
                    var relative = _this2.relative(from);
                    _this2.map.setSourceContent(relative, node.source.input.css);
                }
            }
        });
    };

    MapGenerator.prototype.applyPrevMaps = function applyPrevMaps() {
        for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var prev = _ref;

            var from = this.relative(prev.file);
            var root = prev.root || _path2.default.dirname(prev.file);
            var map = void 0;

            if (this.mapOpts.sourcesContent === false) {
                map = new _sourceMap2.default.SourceMapConsumer(prev.text);
                if (map.sourcesContent) {
                    map.sourcesContent = map.sourcesContent.map(function () {
                        return null;
                    });
                }
            } else {
                map = prev.consumer();
            }

            this.map.applySourceMap(map, from, this.relative(root));
        }
    };

    MapGenerator.prototype.isAnnotation = function isAnnotation() {
        if (this.isInline()) {
            return true;
        } else if (typeof this.mapOpts.annotation !== 'undefined') {
            return this.mapOpts.annotation;
        } else if (this.previous().length) {
            return this.previous().some(function (i) {
                return i.annotation;
            });
        } else {
            return true;
        }
    };

    MapGenerator.prototype.toBase64 = function toBase64(str) {
        if (Buffer) {
            if (Buffer.from && Buffer.from !== Uint8Array.from) {
                return Buffer.from(str).toString('base64');
            } else {
                return new Buffer(str).toString('base64');
            }
        } else {
            return window.btoa(unescape(encodeURIComponent(str)));
        }
    };

    MapGenerator.prototype.addAnnotation = function addAnnotation() {
        var content = void 0;

        if (this.isInline()) {

            content = 'data:application/json;base64,' + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === 'string') {
            content = this.mapOpts.annotation;
        } else {
            content = this.outputFile() + '.map';
        }

        var eol = '\n';
        if (this.css.indexOf('\r\n') !== -1) eol = '\r\n';

        this.css += eol + '/*# sourceMappingURL=' + content + ' */';
    };

    MapGenerator.prototype.outputFile = function outputFile() {
        if (this.opts.to) {
            return this.relative(this.opts.to);
        } else if (this.opts.from) {
            return this.relative(this.opts.from);
        } else {
            return 'to.css';
        }
    };

    MapGenerator.prototype.generateMap = function generateMap() {
        this.generateString();
        if (this.isSourcesContent()) this.setSourcesContent();
        if (this.previous().length > 0) this.applyPrevMaps();
        if (this.isAnnotation()) this.addAnnotation();

        if (this.isInline()) {
            return [this.css];
        } else {
            return [this.css, this.map];
        }
    };

    MapGenerator.prototype.relative = function relative(file) {
        if (file.indexOf('<') === 0) return file;
        if (/^\w+:\/\//.test(file)) return file;

        var from = this.opts.to ? _path2.default.dirname(this.opts.to) : '.';

        if (typeof this.mapOpts.annotation === 'string') {
            from = _path2.default.dirname(_path2.default.resolve(from, this.mapOpts.annotation));
        }

        file = _path2.default.relative(from, file);
        if (_path2.default.sep === '\\') {
            return file.replace(/\\/g, '/');
        } else {
            return file;
        }
    };

    MapGenerator.prototype.sourcePath = function sourcePath(node) {
        if (this.mapOpts.from) {
            return this.mapOpts.from;
        } else {
            return this.relative(node.source.input.from);
        }
    };

    MapGenerator.prototype.generateString = function generateString() {
        var _this3 = this;

        this.css = '';
        this.map = new _sourceMap2.default.SourceMapGenerator({ file: this.outputFile() });

        var line = 1;
        var column = 1;

        var lines = void 0,
            last = void 0;
        this.stringify(this.root, function (str, node, type) {
            _this3.css += str;

            if (node && type !== 'end') {
                if (node.source && node.source.start) {
                    _this3.map.addMapping({
                        source: _this3.sourcePath(node),
                        generated: { line: line, column: column - 1 },
                        original: {
                            line: node.source.start.line,
                            column: node.source.start.column - 1
                        }
                    });
                } else {
                    _this3.map.addMapping({
                        source: '<no source>',
                        original: { line: 1, column: 0 },
                        generated: { line: line, column: column - 1 }
                    });
                }
            }

            lines = str.match(/\n/g);
            if (lines) {
                line += lines.length;
                last = str.lastIndexOf('\n');
                column = str.length - last;
            } else {
                column += str.length;
            }

            if (node && type !== 'start') {
                if (node.source && node.source.end) {
                    _this3.map.addMapping({
                        source: _this3.sourcePath(node),
                        generated: { line: line, column: column - 1 },
                        original: {
                            line: node.source.end.line,
                            column: node.source.end.column
                        }
                    });
                } else {
                    _this3.map.addMapping({
                        source: '<no source>',
                        original: { line: 1, column: 0 },
                        generated: { line: line, column: column - 1 }
                    });
                }
            }
        });
    };

    MapGenerator.prototype.generate = function generate() {
        this.clearAnnotation();

        if (this.isMap()) {
            return this.generateMap();
        } else {
            var result = '';
            this.stringify(this.root, function (i) {
                result += i;
            });
            return [result];
        }
    };

    return MapGenerator;
}();

exports.default = MapGenerator;
module.exports = exports['default'];


}).call(this,require(238).Buffer)}, {"238":238,"924":924,"1113":1113}];
window.modules["1098"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _cssSyntaxError = require(1103);

var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);

var _stringifier = require(1114);

var _stringifier2 = _interopRequireDefault(_stringifier);

var _stringify = require(1108);

var _stringify2 = _interopRequireDefault(_stringify);

var _warnOnce = require(1109);

var _warnOnce2 = _interopRequireDefault(_warnOnce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cloneNode = function cloneNode(obj, parent) {
    var cloned = new obj.constructor();

    for (var i in obj) {
        if (!obj.hasOwnProperty(i)) continue;
        var value = obj[i];
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

        if (i === 'parent' && type === 'object') {
            if (parent) cloned[i] = parent;
        } else if (i === 'source') {
            cloned[i] = value;
        } else if (value instanceof Array) {
            cloned[i] = value.map(function (j) {
                return cloneNode(j, cloned);
            });
        } else {
            if (type === 'object' && value !== null) value = cloneNode(value);
            cloned[i] = value;
        }
    }

    return cloned;
};

/**
 * All node classes inherit the following common methods.
 *
 * @abstract
 */

var Node = function () {

    /**
     * @param {object} [defaults] - value for node properties
     */
    function Node() {
        var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Node);

        this.raws = {};
        if ((typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) !== 'object' && typeof defaults !== 'undefined') {
            throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));
        }
        for (var name in defaults) {
            this[name] = defaults[name];
        }
    }

    /**
     * Returns a CssSyntaxError instance containing the original position
     * of the node in the source, showing line and column numbers and also
     * a small excerpt to facilitate debugging.
     *
     * If present, an input source map will be used to get the original position
     * of the source, even from a previous compilation step
     * (e.g., from Sass compilation).
     *
     * This method produces very useful error messages.
     *
     * @param {string} message     - error description
     * @param {object} [opts]      - options
     * @param {string} opts.plugin - plugin name that created this error.
     *                               PostCSS will set it automatically.
     * @param {string} opts.word   - a word inside a nodes string that should
     *                               be highlighted as the source of the error
     * @param {number} opts.index  - an index inside a nodes string that should
     *                               be highlighted as the source of the error
     *
     * @return {CssSyntaxError} error object to throw it
     *
     * @example
     * if ( !variables[name] ) {
     *   throw decl.error('Unknown variable ' + name, { word: name });
     *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
     *   //   color: $black
     *   // a
     *   //          ^
     *   //   background: white
     * }
     */


    Node.prototype.error = function error(message) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (this.source) {
            var pos = this.positionBy(opts);
            return this.source.input.error(message, pos.line, pos.column, opts);
        } else {
            return new _cssSyntaxError2.default(message);
        }
    };

    /**
     * This method is provided as a convenience wrapper for {@link Result#warn}.
     *
     * @param {Result} result      - the {@link Result} instance
     *                               that will receive the warning
     * @param {string} text        - warning message
     * @param {object} [opts]      - options
     * @param {string} opts.plugin - plugin name that created this warning.
     *                               PostCSS will set it automatically.
     * @param {string} opts.word   - a word inside a nodes string that should
     *                               be highlighted as the source of the warning
     * @param {number} opts.index  - an index inside a nodes string that should
     *                               be highlighted as the source of the warning
     *
     * @return {Warning} created warning object
     *
     * @example
     * const plugin = postcss.plugin('postcss-deprecated', () => {
     *   return (root, result) => {
     *     root.walkDecls('bad', decl => {
     *       decl.warn(result, 'Deprecated property bad');
     *     });
     *   };
     * });
     */


    Node.prototype.warn = function warn(result, text, opts) {
        var data = { node: this };
        for (var i in opts) {
            data[i] = opts[i];
        }return result.warn(text, data);
    };

    /**
     * Removes the node from its parent and cleans the parent properties
     * from the node and its children.
     *
     * @example
     * if ( decl.prop.match(/^-webkit-/) ) {
     *   decl.remove();
     * }
     *
     * @return {Node} node to make calls chain
     */


    Node.prototype.remove = function remove() {
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.parent = undefined;
        return this;
    };

    /**
     * Returns a CSS string representing the node.
     *
     * @param {stringifier|syntax} [stringifier] - a syntax to use
     *                                             in string generation
     *
     * @return {string} CSS string of this node
     *
     * @example
     * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
     */


    Node.prototype.toString = function toString() {
        var stringifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _stringify2.default;

        if (stringifier.stringify) stringifier = stringifier.stringify;
        var result = '';
        stringifier(this, function (i) {
            result += i;
        });
        return result;
    };

    /**
     * Returns a clone of the node.
     *
     * The resulting cloned node and its (cloned) children will have
     * a clean parent and code style properties.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @example
     * const cloned = decl.clone({ prop: '-moz-' + decl.prop });
     * cloned.raws.before  //=> undefined
     * cloned.parent       //=> undefined
     * cloned.toString()   //=> -moz-transform: scale(0)
     *
     * @return {Node} clone of the node
     */


    Node.prototype.clone = function clone() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = cloneNode(this);
        for (var name in overrides) {
            cloned[name] = overrides[name];
        }
        return cloned;
    };

    /**
     * Shortcut to clone the node and insert the resulting cloned node
     * before the current node.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @example
     * decl.cloneBefore({ prop: '-moz-' + decl.prop });
     *
     * @return {Node} - new node
     */


    Node.prototype.cloneBefore = function cloneBefore() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
    };

    /**
     * Shortcut to clone the node and insert the resulting cloned node
     * after the current node.
     *
     * @param {object} [overrides] - new properties to override in the clone.
     *
     * @return {Node} - new node
     */


    Node.prototype.cloneAfter = function cloneAfter() {
        var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
    };

    /**
     * Inserts node(s) before the current node and removes the current node.
     *
     * @param {...Node} nodes - node(s) to replace current one
     *
     * @example
     * if ( atrule.name == 'mixin' ) {
     *   atrule.replaceWith(mixinRules[atrule.params]);
     * }
     *
     * @return {Node} current node to methods chain
     */


    Node.prototype.replaceWith = function replaceWith() {
        if (this.parent) {
            for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
                nodes[_key] = arguments[_key];
            }

            for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var node = _ref;

                this.parent.insertBefore(this, node);
            }

            this.remove();
        }

        return this;
    };

    Node.prototype.moveTo = function moveTo(newParent) {
        (0, _warnOnce2.default)('Node#moveTo was deprecated. Use Container#append.');
        this.cleanRaws(this.root() === newParent.root());
        this.remove();
        newParent.append(this);
        return this;
    };

    Node.prototype.moveBefore = function moveBefore(otherNode) {
        (0, _warnOnce2.default)('Node#moveBefore was deprecated. Use Node#before.');
        this.cleanRaws(this.root() === otherNode.root());
        this.remove();
        otherNode.parent.insertBefore(otherNode, this);
        return this;
    };

    Node.prototype.moveAfter = function moveAfter(otherNode) {
        (0, _warnOnce2.default)('Node#moveAfter was deprecated. Use Node#after.');
        this.cleanRaws(this.root() === otherNode.root());
        this.remove();
        otherNode.parent.insertAfter(otherNode, this);
        return this;
    };

    /**
     * Returns the next child of the nodes parent.
     * Returns `undefined` if the current node is the last child.
     *
     * @return {Node|undefined} next node
     *
     * @example
     * if ( comment.text === 'delete next' ) {
     *   const next = comment.next();
     *   if ( next ) {
     *     next.remove();
     *   }
     * }
     */


    Node.prototype.next = function next() {
        if (!this.parent) return undefined;
        var index = this.parent.index(this);
        return this.parent.nodes[index + 1];
    };

    /**
     * Returns the previous child of the nodes parent.
     * Returns `undefined` if the current node is the first child.
     *
     * @return {Node|undefined} previous node
     *
     * @example
     * const annotation = decl.prev();
     * if ( annotation.type == 'comment' ) {
     *  readAnnotation(annotation.text);
     * }
     */


    Node.prototype.prev = function prev() {
        if (!this.parent) return undefined;
        var index = this.parent.index(this);
        return this.parent.nodes[index - 1];
    };

    /**
     * Insert new node before current node to current nodes parent.
     *
     * Just alias for `node.parent.insertBefore(node, add)`.
     *
     * @param {Node|object|string|Node[]} add - new node
     *
     * @return {Node} this node for methods chain.
     *
     * @example
     * decl.before('content: ""');
     */


    Node.prototype.before = function before(add) {
        this.parent.insertBefore(this, add);
        return this;
    };

    /**
     * Insert new node after current node to current nodes parent.
     *
     * Just alias for `node.parent.insertAfter(node, add)`.
     *
     * @param {Node|object|string|Node[]} add - new node
     *
     * @return {Node} this node for methods chain.
     *
     * @example
     * decl.after('color: black');
     */


    Node.prototype.after = function after(add) {
        this.parent.insertAfter(this, add);
        return this;
    };

    Node.prototype.toJSON = function toJSON() {
        var fixed = {};

        for (var name in this) {
            if (!this.hasOwnProperty(name)) continue;
            if (name === 'parent') continue;
            var value = this[name];

            if (value instanceof Array) {
                fixed[name] = value.map(function (i) {
                    if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && i.toJSON) {
                        return i.toJSON();
                    } else {
                        return i;
                    }
                });
            } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.toJSON) {
                fixed[name] = value.toJSON();
            } else {
                fixed[name] = value;
            }
        }

        return fixed;
    };

    /**
     * Returns a {@link Node#raws} value. If the node is missing
     * the code style property (because the node was manually built or cloned),
     * PostCSS will try to autodetect the code style property by looking
     * at other nodes in the tree.
     *
     * @param {string} prop          - name of code style property
     * @param {string} [defaultType] - name of default value, it can be missed
     *                                 if the value is the same as prop
     *
     * @example
     * const root = postcss.parse('a { background: white }');
     * root.nodes[0].append({ prop: 'color', value: 'black' });
     * root.nodes[0].nodes[1].raws.before   //=> undefined
     * root.nodes[0].nodes[1].raw('before') //=> ' '
     *
     * @return {string} code style value
     */


    Node.prototype.raw = function raw(prop, defaultType) {
        var str = new _stringifier2.default();
        return str.raw(this, prop, defaultType);
    };

    /**
     * Finds the Root instance of the nodes tree.
     *
     * @example
     * root.nodes[0].nodes[0].root() === root
     *
     * @return {Root} root parent
     */


    Node.prototype.root = function root() {
        var result = this;
        while (result.parent) {
            result = result.parent;
        }return result;
    };

    Node.prototype.cleanRaws = function cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween) delete this.raws.between;
    };

    Node.prototype.positionInside = function positionInside(index) {
        var string = this.toString();
        var column = this.source.start.column;
        var line = this.source.start.line;

        for (var i = 0; i < index; i++) {
            if (string[i] === '\n') {
                column = 1;
                line += 1;
            } else {
                column += 1;
            }
        }

        return { line: line, column: column };
    };

    Node.prototype.positionBy = function positionBy(opts) {
        var pos = this.source.start;
        if (opts.index) {
            pos = this.positionInside(opts.index);
        } else if (opts.word) {
            var index = this.toString().indexOf(opts.word);
            if (index !== -1) pos = this.positionInside(index);
        }
        return pos;
    };

    /**
     * @memberof Node#
     * @member {string} type - String representing the nodes type.
     *                         Possible values are `root`, `atrule`, `rule`,
     *                         `decl`, or `comment`.
     *
     * @example
     * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
     */

    /**
     * @memberof Node#
     * @member {Container} parent - the nodes parent node.
     *
     * @example
     * root.nodes[0].parent == root;
     */

    /**
     * @memberof Node#
     * @member {source} source - the input source of the node
     *
     * The property is used in source map generation.
     *
     * If you create a node manually (e.g., with `postcss.decl()`),
     * that node will not have a `source` property and will be absent
     * from the source map. For this reason, the plugin developer should
     * consider cloning nodes to create new ones (in which case the new nodes
     * source will reference the original, cloned node) or setting
     * the `source` property manually.
     *
     * ```js
     * // Bad
     * const prefixed = postcss.decl({
     *   prop: '-moz-' + decl.prop,
     *   value: decl.value
     * });
     *
     * // Good
     * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });
     * ```
     *
     * ```js
     * if ( atrule.name == 'add-link' ) {
     *   const rule = postcss.rule({ selector: 'a', source: atrule.source });
     *   atrule.parent.insertBefore(atrule, rule);
     * }
     * ```
     *
     * @example
     * decl.source.input.from //=> '/home/ai/a.sass'
     * decl.source.start      //=> { line: 10, column: 2 }
     * decl.source.end        //=> { line: 10, column: 12 }
     */

    /**
     * @memberof Node#
     * @member {object} raws - Information to generate byte-to-byte equal
     *                         node string as it was in the origin input.
     *
     * Every parser saves its own properties,
     * but the default CSS parser uses:
     *
     * * `before`: the space symbols before the node. It also stores `*`
     *   and `_` symbols before the declaration (IE hack).
     * * `after`: the space symbols after the last child of the node
     *   to the end of the node.
     * * `between`: the symbols between the property and value
     *   for declarations, selector and `{` for rules, or last parameter
     *   and `{` for at-rules.
     * * `semicolon`: contains true if the last child has
     *   an (optional) semicolon.
     * * `afterName`: the space between the at-rule name and its parameters.
     * * `left`: the space symbols between `/*` and the comments text.
     * * `right`: the space symbols between the comments text
     *   and <code>*&#47;</code>.
     * * `important`: the content of the important statement,
     *   if it is not just `!important`.
     *
     * PostCSS cleans selectors, declaration values and at-rule parameters
     * from comments and extra spaces, but it stores origin content in raws
     * properties. As such, if you dont change a declarations value,
     * PostCSS will use the raw value with comments.
     *
     * @example
     * const root = postcss.parse('a {\n  color:black\n}')
     * root.first.first.raws //=> { before: '\n  ', between: ':' }
     */

    return Node;
}();

exports.default = Node;

/**
 * @typedef {object} position
 * @property {number} line   - source line in file
 * @property {number} column - source column in file
 */

/**
 * @typedef {object} source
 * @property {Input} input    - {@link Input} with input file
 * @property {position} start - The starting position of the nodes source
 * @property {position} end   - The ending position of the nodes source
 */

module.exports = exports['default'];

}, {"1103":1103,"1108":1108,"1109":1109,"1114":1114}];
window.modules["1100"] = [function(require,module,exports){'use strict';

exports.__esModule = true;
exports.default = parse;

var _parser = require(1115);

var _parser2 = _interopRequireDefault(_parser);

var _input = require(1105);

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(css, opts) {
    if (opts && opts.safe) {
        throw new Error('Option safe was removed. ' + 'Use parser: require("postcss-safe-parser")');
    }

    var input = new _input2.default(css, opts);
    var parser = new _parser2.default(input);
    try {
        parser.parse();
    } catch (e) {
        if (e.name === 'CssSyntaxError' && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
                e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';
            } else if (/\.sass/i.test(opts.from)) {
                e.message += '\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';
            } else if (/\.less$/i.test(opts.from)) {
                e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';
            }
        }
        throw e;
    }

    return parser.root;
}
module.exports = exports['default'];

}, {"1105":1105,"1115":1115}];
window.modules["1115"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _declaration = require(1099);

var _declaration2 = _interopRequireDefault(_declaration);

var _tokenize = require(1116);

var _tokenize2 = _interopRequireDefault(_tokenize);

var _comment = require(1097);

var _comment2 = _interopRequireDefault(_comment);

var _atRule = require(1095);

var _atRule2 = _interopRequireDefault(_atRule);

var _root = require(1102);

var _root2 = _interopRequireDefault(_root);

var _rule = require(1101);

var _rule2 = _interopRequireDefault(_rule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Parser = function () {
    function Parser(input) {
        _classCallCheck(this, Parser);

        this.input = input;

        this.root = new _root2.default();
        this.current = this.root;
        this.spaces = '';
        this.semicolon = false;

        this.createTokenizer();
        this.root.source = { input: input, start: { line: 1, column: 1 } };
    }

    Parser.prototype.createTokenizer = function createTokenizer() {
        this.tokenizer = (0, _tokenize2.default)(this.input);
    };

    Parser.prototype.parse = function parse() {
        var token = void 0;
        while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();

            switch (token[0]) {

                case 'space':
                    this.spaces += token[1];
                    break;

                case ';':
                    this.freeSemicolon(token);
                    break;

                case '}':
                    this.end(token);
                    break;

                case 'comment':
                    this.comment(token);
                    break;

                case 'at-word':
                    this.atrule(token);
                    break;

                case '{':
                    this.emptyRule(token);
                    break;

                default:
                    this.other(token);
                    break;
            }
        }
        this.endFile();
    };

    Parser.prototype.comment = function comment(token) {
        var node = new _comment2.default();
        this.init(node, token[2], token[3]);
        node.source.end = { line: token[4], column: token[5] };

        var text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
            node.text = '';
            node.raws.left = text;
            node.raws.right = '';
        } else {
            var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
        }
    };

    Parser.prototype.emptyRule = function emptyRule(token) {
        var node = new _rule2.default();
        this.init(node, token[2], token[3]);
        node.selector = '';
        node.raws.between = '';
        this.current = node;
    };

    Parser.prototype.other = function other(start) {
        var end = false;
        var type = null;
        var colon = false;
        var bracket = null;
        var brackets = [];

        var tokens = [];
        var token = start;
        while (token) {
            type = token[0];
            tokens.push(token);

            if (type === '(' || type === '[') {
                if (!bracket) bracket = token;
                brackets.push(type === '(' ? ')' : ']');
            } else if (brackets.length === 0) {
                if (type === ';') {
                    if (colon) {
                        this.decl(tokens);
                        return;
                    } else {
                        break;
                    }
                } else if (type === '{') {
                    this.rule(tokens);
                    return;
                } else if (type === '}') {
                    this.tokenizer.back(tokens.pop());
                    end = true;
                    break;
                } else if (type === ':') {
                    colon = true;
                }
            } else if (type === brackets[brackets.length - 1]) {
                brackets.pop();
                if (brackets.length === 0) bracket = null;
            }

            token = this.tokenizer.nextToken();
        }

        if (this.tokenizer.endOfFile()) end = true;
        if (brackets.length > 0) this.unclosedBracket(bracket);

        if (end && colon) {
            while (tokens.length) {
                token = tokens[tokens.length - 1][0];
                if (token !== 'space' && token !== 'comment') break;
                this.tokenizer.back(tokens.pop());
            }
            this.decl(tokens);
            return;
        } else {
            this.unknownWord(tokens);
        }
    };

    Parser.prototype.rule = function rule(tokens) {
        tokens.pop();

        var node = new _rule2.default();
        this.init(node, tokens[0][2], tokens[0][3]);

        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, 'selector', tokens);
        this.current = node;
    };

    Parser.prototype.decl = function decl(tokens) {
        var node = new _declaration2.default();
        this.init(node);

        var last = tokens[tokens.length - 1];
        if (last[0] === ';') {
            this.semicolon = true;
            tokens.pop();
        }
        if (last[4]) {
            node.source.end = { line: last[4], column: last[5] };
        } else {
            node.source.end = { line: last[2], column: last[3] };
        }

        while (tokens[0][0] !== 'word') {
            if (tokens.length === 1) this.unknownWord(tokens);
            node.raws.before += tokens.shift()[1];
        }
        node.source.start = { line: tokens[0][2], column: tokens[0][3] };

        node.prop = '';
        while (tokens.length) {
            var type = tokens[0][0];
            if (type === ':' || type === 'space' || type === 'comment') {
                break;
            }
            node.prop += tokens.shift()[1];
        }

        node.raws.between = '';

        var token = void 0;
        while (tokens.length) {
            token = tokens.shift();

            if (token[0] === ':') {
                node.raws.between += token[1];
                break;
            } else {
                node.raws.between += token[1];
            }
        }

        if (node.prop[0] === '_' || node.prop[0] === '*') {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
        }
        node.raws.between += this.spacesAndCommentsFromStart(tokens);
        this.precheckMissedSemicolon(tokens);

        for (var i = tokens.length - 1; i > 0; i--) {
            token = tokens[i];
            if (token[1].toLowerCase() === '!important') {
                node.important = true;
                var string = this.stringFrom(tokens, i);
                string = this.spacesFromEnd(tokens) + string;
                if (string !== ' !important') node.raws.important = string;
                break;
            } else if (token[1].toLowerCase() === 'important') {
                var cache = tokens.slice(0);
                var str = '';
                for (var j = i; j > 0; j--) {
                    var _type = cache[j][0];
                    if (str.trim().indexOf('!') === 0 && _type !== 'space') {
                        break;
                    }
                    str = cache.pop()[1] + str;
                }
                if (str.trim().indexOf('!') === 0) {
                    node.important = true;
                    node.raws.important = str;
                    tokens = cache;
                }
            }

            if (token[0] !== 'space' && token[0] !== 'comment') {
                break;
            }
        }

        this.raw(node, 'value', tokens);

        if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);
    };

    Parser.prototype.atrule = function atrule(token) {
        var node = new _atRule2.default();
        node.name = token[1].slice(1);
        if (node.name === '') {
            this.unnamedAtrule(node, token);
        }
        this.init(node, token[2], token[3]);

        var prev = void 0;
        var shift = void 0;
        var last = false;
        var open = false;
        var params = [];

        while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();

            if (token[0] === ';') {
                node.source.end = { line: token[2], column: token[3] };
                this.semicolon = true;
                break;
            } else if (token[0] === '{') {
                open = true;
                break;
            } else if (token[0] === '}') {
                if (params.length > 0) {
                    shift = params.length - 1;
                    prev = params[shift];
                    while (prev && prev[0] === 'space') {
                        prev = params[--shift];
                    }
                    if (prev) {
                        node.source.end = { line: prev[4], column: prev[5] };
                    }
                }
                this.end(token);
                break;
            } else {
                params.push(token);
            }

            if (this.tokenizer.endOfFile()) {
                last = true;
                break;
            }
        }

        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, 'params', params);
            if (last) {
                token = params[params.length - 1];
                node.source.end = { line: token[4], column: token[5] };
                this.spaces = node.raws.between;
                node.raws.between = '';
            }
        } else {
            node.raws.afterName = '';
            node.params = '';
        }

        if (open) {
            node.nodes = [];
            this.current = node;
        }
    };

    Parser.prototype.end = function end(token) {
        if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;

        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
        this.spaces = '';

        if (this.current.parent) {
            this.current.source.end = { line: token[2], column: token[3] };
            this.current = this.current.parent;
        } else {
            this.unexpectedClose(token);
        }
    };

    Parser.prototype.endFile = function endFile() {
        if (this.current.parent) this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || '') + this.spaces;
    };

    Parser.prototype.freeSemicolon = function freeSemicolon(token) {
        this.spaces += token[1];
        if (this.current.nodes) {
            var prev = this.current.nodes[this.current.nodes.length - 1];
            if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
                prev.raws.ownSemicolon = this.spaces;
                this.spaces = '';
            }
        }
    };

    // Helpers

    Parser.prototype.init = function init(node, line, column) {
        this.current.push(node);

        node.source = { start: { line: line, column: column }, input: this.input };
        node.raws.before = this.spaces;
        this.spaces = '';
        if (node.type !== 'comment') this.semicolon = false;
    };

    Parser.prototype.raw = function raw(node, prop, tokens) {
        var token = void 0,
            type = void 0;
        var length = tokens.length;
        var value = '';
        var clean = true;
        var next = void 0,
            prev = void 0;
        var pattern = /^([.|#])?([\w])+/i;

        for (var i = 0; i < length; i += 1) {
            token = tokens[i];
            type = token[0];

            if (type === 'comment' && node.type === 'rule') {
                prev = tokens[i - 1];
                next = tokens[i + 1];

                if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {
                    value += token[1];
                } else {
                    clean = false;
                }

                continue;
            }

            if (type === 'comment' || type === 'space' && i === length - 1) {
                clean = false;
            } else {
                value += token[1];
            }
        }
        if (!clean) {
            var raw = tokens.reduce(function (all, i) {
                return all + i[1];
            }, '');
            node.raws[prop] = { value: value, raw: raw };
        }
        node[prop] = value;
    };

    Parser.prototype.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {
        var lastTokenType = void 0;
        var spaces = '';
        while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
            spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
    };

    Parser.prototype.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {
        var next = void 0;
        var spaces = '';
        while (tokens.length) {
            next = tokens[0][0];
            if (next !== 'space' && next !== 'comment') break;
            spaces += tokens.shift()[1];
        }
        return spaces;
    };

    Parser.prototype.spacesFromEnd = function spacesFromEnd(tokens) {
        var lastTokenType = void 0;
        var spaces = '';
        while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== 'space') break;
            spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
    };

    Parser.prototype.stringFrom = function stringFrom(tokens, from) {
        var result = '';
        for (var i = from; i < tokens.length; i++) {
            result += tokens[i][1];
        }
        tokens.splice(from, tokens.length - from);
        return result;
    };

    Parser.prototype.colon = function colon(tokens) {
        var brackets = 0;
        var token = void 0,
            type = void 0,
            prev = void 0;
        for (var i = 0; i < tokens.length; i++) {
            token = tokens[i];
            type = token[0];

            if (type === '(') {
                brackets += 1;
            } else if (type === ')') {
                brackets -= 1;
            } else if (brackets === 0 && type === ':') {
                if (!prev) {
                    this.doubleColon(token);
                } else if (prev[0] === 'word' && prev[1] === 'progid') {
                    continue;
                } else {
                    return i;
                }
            }

            prev = token;
        }
        return false;
    };

    // Errors

    Parser.prototype.unclosedBracket = function unclosedBracket(bracket) {
        throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);
    };

    Parser.prototype.unknownWord = function unknownWord(tokens) {
        throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);
    };

    Parser.prototype.unexpectedClose = function unexpectedClose(token) {
        throw this.input.error('Unexpected }', token[2], token[3]);
    };

    Parser.prototype.unclosedBlock = function unclosedBlock() {
        var pos = this.current.source.start;
        throw this.input.error('Unclosed block', pos.line, pos.column);
    };

    Parser.prototype.doubleColon = function doubleColon(token) {
        throw this.input.error('Double colon', token[2], token[3]);
    };

    Parser.prototype.unnamedAtrule = function unnamedAtrule(node, token) {
        throw this.input.error('At-rule without name', token[2], token[3]);
    };

    Parser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {
        // Hook for Safe Parser
        tokens;
    };

    Parser.prototype.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
        var colon = this.colon(tokens);
        if (colon === false) return;

        var founded = 0;
        var token = void 0;
        for (var j = colon - 1; j >= 0; j--) {
            token = tokens[j];
            if (token[0] !== 'space') {
                founded += 1;
                if (founded === 2) break;
            }
        }
        throw this.input.error('Missed semicolon', token[2], token[3]);
    };

    return Parser;
}();

exports.default = Parser;
module.exports = exports['default'];

}, {"1095":1095,"1097":1097,"1099":1099,"1101":1101,"1102":1102,"1116":1116}];
window.modules["1094"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _declaration = require(1099);

var _declaration2 = _interopRequireDefault(_declaration);

var _processor = require(1118);

var _processor2 = _interopRequireDefault(_processor);

var _stringify = require(1108);

var _stringify2 = _interopRequireDefault(_stringify);

var _comment = require(1097);

var _comment2 = _interopRequireDefault(_comment);

var _atRule = require(1095);

var _atRule2 = _interopRequireDefault(_atRule);

var _vendor = require(1117);

var _vendor2 = _interopRequireDefault(_vendor);

var _parse = require(1100);

var _parse2 = _interopRequireDefault(_parse);

var _list = require(1112);

var _list2 = _interopRequireDefault(_list);

var _rule = require(1101);

var _rule2 = _interopRequireDefault(_rule);

var _root = require(1102);

var _root2 = _interopRequireDefault(_root);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create a new {@link Processor} instance that will apply `plugins`
 * as CSS processors.
 *
 * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
 *        plugins. See {@link Processor#use} for plugin format.
 *
 * @return {Processor} Processor to process multiple CSS
 *
 * @example
 * import postcss from 'postcss';
 *
 * postcss(plugins).process(css, { from, to }).then(result => {
 *   console.log(result.css);
 * });
 *
 * @namespace postcss
 */
function postcss() {
  for (var _len = arguments.length, plugins = Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new _processor2.default(plugins);
}

/**
 * Creates a PostCSS plugin with a standard API.
 *
 * The newly-wrapped function will provide both the name and PostCSS
 * version of the plugin.
 *
 * ```js
 *  const processor = postcss([replace]);
 *  processor.plugins[0].postcssPlugin  //=> 'postcss-replace'
 *  processor.plugins[0].postcssVersion //=> '5.1.0'
 * ```
 *
 * The plugin function receives 2 arguments: {@link Root}
 * and {@link Result} instance. The function should mutate the provided
 * `Root` node. Alternatively, you can create a new `Root` node
 * and override the `result.root` property.
 *
 * ```js
 * const cleaner = postcss.plugin('postcss-cleaner', () => {
 *   return (root, result) => {
 *     result.root = postcss.root();
 *   };
 * });
 * ```
 *
 * As a convenience, plugins also expose a `process` method so that you can use
 * them as standalone tools.
 *
 * ```js
 * cleaner.process(css, processOpts, pluginOpts);
 * // This is equivalent to:
 * postcss([ cleaner(pluginOpts) ]).process(css, processOpts);
 * ```
 *
 * Asynchronous plugins should return a `Promise` instance.
 *
 * ```js
 * postcss.plugin('postcss-import', () => {
 *   return (root, result) => {
 *     return new Promise( (resolve, reject) => {
 *       fs.readFile('base.css', (base) => {
 *         root.prepend(base);
 *         resolve();
 *       });
 *     });
 *   };
 * });
 * ```
 *
 * Add warnings using the {@link Node#warn} method.
 * Send data to other plugins using the {@link Result#messages} array.
 *
 * ```js
 * postcss.plugin('postcss-caniuse-test', () => {
 *   return (root, result) => {
 *     root.walkDecls(decl => {
 *       if ( !caniuse.support(decl.prop) ) {
 *         decl.warn(result, 'Some browsers do not support ' + decl.prop);
 *       }
 *     });
 *   };
 * });
 * ```
 *
 * @param {string} name          - PostCSS plugin name. Same as in `name`
 *                                 property in `package.json`. It will be saved
 *                                 in `plugin.postcssPlugin` property.
 * @param {function} initializer - will receive plugin options
 *                                 and should return {@link pluginFunction}
 *
 * @return {Plugin} PostCSS plugin
 */
postcss.plugin = function plugin(name, initializer) {
  var creator = function creator() {
    var transformer = initializer.apply(undefined, arguments);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new _processor2.default().version;
    return transformer;
  };

  var cache = void 0;
  Object.defineProperty(creator, 'postcss', {
    get: function get() {
      if (!cache) cache = creator();
      return cache;
    }
  });

  creator.process = function (css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts);
  };

  return creator;
};

/**
 * Default function to convert a node tree into a CSS string.
 *
 * @param {Node} node       - start node for stringifing. Usually {@link Root}.
 * @param {builder} builder - function to concatenate CSS from nodes parts
 *                            or generate string and source map
 *
 * @return {void}
 *
 * @function
 */
postcss.stringify = _stringify2.default;

/**
 * Parses source css and returns a new {@link Root} node,
 * which contains the source CSS nodes.
 *
 * @param {string|toString} css   - string with input CSS or any object
 *                                  with toString() method, like a Buffer
 * @param {processOptions} [opts] - options with only `from` and `map` keys
 *
 * @return {Root} PostCSS AST
 *
 * @example
 * // Simple CSS concatenation with source map support
 * const root1 = postcss.parse(css1, { from: file1 });
 * const root2 = postcss.parse(css2, { from: file2 });
 * root1.append(root2).toResult().css;
 *
 * @function
 */
postcss.parse = _parse2.default;

/**
 * @member {vendor} - Contains the {@link vendor} module.
 *
 * @example
 * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']
 */
postcss.vendor = _vendor2.default;

/**
 * @member {list} - Contains the {@link list} module.
 *
 * @example
 * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']
 */
postcss.list = _list2.default;

/**
 * Creates a new {@link Comment} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Comment} new Comment node
 *
 * @example
 * postcss.comment({ text: 'test' })
 */
postcss.comment = function (defaults) {
  return new _comment2.default(defaults);
};

/**
 * Creates a new {@link AtRule} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {AtRule} new AtRule node
 *
 * @example
 * postcss.atRule({ name: 'charset' }).toString() //=> "@charset"
 */
postcss.atRule = function (defaults) {
  return new _atRule2.default(defaults);
};

/**
 * Creates a new {@link Declaration} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Declaration} new Declaration node
 *
 * @example
 * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> "color: red"
 */
postcss.decl = function (defaults) {
  return new _declaration2.default(defaults);
};

/**
 * Creates a new {@link Rule} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Rule} new Rule node
 *
 * @example
 * postcss.rule({ selector: 'a' }).toString() //=> "a {\n}"
 */
postcss.rule = function (defaults) {
  return new _rule2.default(defaults);
};

/**
 * Creates a new {@link Root} node.
 *
 * @param {object} [defaults] - properties for the new node.
 *
 * @return {Root} new Root node
 *
 * @example
 * postcss.root({ after: '\n' }).toString() //=> "\n"
 */
postcss.root = function (defaults) {
  return new _root2.default(defaults);
};

exports.default = postcss;
module.exports = exports['default'];

}, {"1095":1095,"1097":1097,"1099":1099,"1100":1100,"1101":1101,"1102":1102,"1108":1108,"1112":1112,"1117":1117,"1118":1118}];
window.modules["1106"] = [function(require,module,exports){(function (Buffer){
'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _sourceMap = require(1113);

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _path = require(924);

var _path2 = _interopRequireDefault(_path);

var _fs = require(272);

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function fromBase64(str) {
    if (Buffer) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
            return Buffer.from(str, 'base64').toString();
        } else {
            return new Buffer(str, 'base64').toString();
        }
    } else {
        return window.atob(str);
    }
}

/**
 * Source map information from input CSS.
 * For example, source map after Sass compiler.
 *
 * This class will automatically find source map in input CSS or in file system
 * near input file (according `from` option).
 *
 * @example
 * const root = postcss.parse(css, { from: 'a.sass.css' });
 * root.input.map //=> PreviousMap
 */

var PreviousMap = function () {

    /**
     * @param {string}         css    - input CSS source
     * @param {processOptions} [opts] - {@link Processor#process} options
     */
    function PreviousMap(css, opts) {
        _classCallCheck(this, PreviousMap);

        this.loadAnnotation(css);
        /**
         * @member {boolean} - Was source map inlined by data-uri to input CSS.
         */
        this.inline = this.startWith(this.annotation, 'data:');

        var prev = opts.map ? opts.map.prev : undefined;
        var text = this.loadMap(opts.from, prev);
        if (text) this.text = text;
    }

    /**
     * Create a instance of `SourceMapGenerator` class
     * from the `source-map` library to work with source map information.
     *
     * It is lazy method, so it will create object only on first call
     * and then it will use cache.
     *
     * @return {SourceMapGenerator} object with source map information
     */


    PreviousMap.prototype.consumer = function consumer() {
        if (!this.consumerCache) {
            this.consumerCache = new _sourceMap2.default.SourceMapConsumer(this.text);
        }
        return this.consumerCache;
    };

    /**
     * Does source map contains `sourcesContent` with input source text.
     *
     * @return {boolean} Is `sourcesContent` present
     */


    PreviousMap.prototype.withContent = function withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    };

    PreviousMap.prototype.startWith = function startWith(string, start) {
        if (!string) return false;
        return string.substr(0, start.length) === start;
    };

    PreviousMap.prototype.loadAnnotation = function loadAnnotation(css) {
        var match = css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//);
        if (match) this.annotation = match[1].trim();
    };

    PreviousMap.prototype.decodeInline = function decodeInline(text) {
        // data:application/json;charset=utf-8;base64,
        // data:application/json;charset=utf8;base64,
        // data:application/json;base64,
        var baseUri = /^data:application\/json;(?:charset=utf-?8;)?base64,/;
        var uri = 'data:application/json,';

        if (this.startWith(text, uri)) {
            return decodeURIComponent(text.substr(uri.length));
        } else if (baseUri.test(text)) {
            return fromBase64(text.substr(RegExp.lastMatch.length));
        } else {
            var encoding = text.match(/data:application\/json;([^,]+),/)[1];
            throw new Error('Unsupported source map encoding ' + encoding);
        }
    };

    PreviousMap.prototype.loadMap = function loadMap(file, prev) {
        if (prev === false) return false;

        if (prev) {
            if (typeof prev === 'string') {
                return prev;
            } else if (typeof prev === 'function') {
                var prevPath = prev(file);
                if (prevPath && _fs2.default.existsSync && _fs2.default.existsSync(prevPath)) {
                    return _fs2.default.readFileSync(prevPath, 'utf-8').toString().trim();
                } else {
                    throw new Error('Unable to load previous source map: ' + prevPath.toString());
                }
            } else if (prev instanceof _sourceMap2.default.SourceMapConsumer) {
                return _sourceMap2.default.SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof _sourceMap2.default.SourceMapGenerator) {
                return prev.toString();
            } else if (this.isMap(prev)) {
                return JSON.stringify(prev);
            } else {
                throw new Error('Unsupported previous source map format: ' + prev.toString());
            }
        } else if (this.inline) {
            return this.decodeInline(this.annotation);
        } else if (this.annotation) {
            var map = this.annotation;
            if (file) map = _path2.default.join(_path2.default.dirname(file), map);

            this.root = _path2.default.dirname(map);
            if (_fs2.default.existsSync && _fs2.default.existsSync(map)) {
                return _fs2.default.readFileSync(map, 'utf-8').toString().trim();
            } else {
                return false;
            }
        }
    };

    PreviousMap.prototype.isMap = function isMap(map) {
        if ((typeof map === 'undefined' ? 'undefined' : _typeof(map)) !== 'object') return false;
        return typeof map.mappings === 'string' || typeof map._mappings === 'string';
    };

    return PreviousMap;
}();

exports.default = PreviousMap;
module.exports = exports['default'];


}).call(this,require(238).Buffer)}, {"238":238,"272":272,"924":924,"1113":1113}];
window.modules["1118"] = [function(require,module,exports){'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _lazyResult = require(1107);

var _lazyResult2 = _interopRequireDefault(_lazyResult);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * @example
 * const processor = postcss([autoprefixer, precss]);
 * processor.process(css1).then(result => console.log(result.css));
 * processor.process(css2).then(result => console.log(result.css));
 */
var Processor = function () {

  /**
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
   *        plugins. See {@link Processor#use} for plugin format.
   */
  function Processor() {
    var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck(this, Processor);

    /**
     * @member {string} - Current PostCSS version.
     *
     * @example
     * if ( result.processor.version.split('.')[0] !== '6' ) {
     *   throw new Error('This plugin works only with PostCSS 6');
     * }
     */
    this.version = '6.0.23';
    /**
     * @member {pluginFunction[]} - Plugins added to this processor.
     *
     * @example
     * const processor = postcss([autoprefixer, precss]);
     * processor.plugins.length //=> 2
     */
    this.plugins = this.normalize(plugins);
  }

  /**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin created by {@link postcss.plugin} method.
   * * A function. PostCSS will pass the function a @{link Root}
   *   as the first argument and current {@link Result} instance
   *   as the second.
   * * An object with a `postcss` method. PostCSS will use that method
   *   as described in #2.
   * * Another {@link Processor} instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * @param {Plugin|pluginFunction|Processor} plugin - PostCSS plugin
   *                                                   or {@link Processor}
   *                                                   with plugins
   *
   * @example
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(precss);
   *
   * @return {Processes} current processor to make methods chain
   */


  Processor.prototype.use = function use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]));
    return this;
  };

  /**
   * Parses source CSS and returns a {@link LazyResult} Promise proxy.
   * Because some plugins can be asynchronous it doesnt make
   * any transformations. Transformations will be applied
   * in the {@link LazyResult} methods.
   *
   * @param {string|toString|Result} css - String with input CSS or
   *                                       any object with a `toString()`
   *                                       method, like a Buffer.
   *                                       Optionally, send a {@link Result}
   *                                       instance and the processor will
   *                                       take the {@link Root} from it.
   * @param {processOptions} [opts]      - options
   *
   * @return {LazyResult} Promise proxy
   *
   * @example
   * processor.process(css, { from: 'a.css', to: 'a.out.css' })
   *   .then(result => {
   *      console.log(result.css);
   *   });
   */


  Processor.prototype.process = function process(css) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return new _lazyResult2.default(this, css, opts);
  };

  Processor.prototype.normalize = function normalize(plugins) {
    var normalized = [];
    for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var i = _ref;

      if (i.postcss) i = i.postcss;

      if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins);
      } else if (typeof i === 'function') {
        normalized.push(i);
      } else if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && (i.parse || i.stringify)) {
        throw new Error('PostCSS syntaxes cannot be used as plugins. ' + 'Instead, please use one of the ' + 'syntax/parser/stringifier options as ' + 'outlined in your PostCSS ' + 'runner documentation.');
      } else {
        throw new Error(i + ' is not a PostCSS plugin');
      }
    }
    return normalized;
  };

  return Processor;
}();

exports.default = Processor;

/**
 * @callback builder
 * @param {string} part          - part of generated CSS connected to this node
 * @param {Node}   node          - AST node
 * @param {"start"|"end"} [type] - nodes part type
 */

/**
 * @callback parser
 *
 * @param {string|toString} css   - string with input CSS or any object
 *                                  with toString() method, like a Buffer
 * @param {processOptions} [opts] - options with only `from` and `map` keys
 *
 * @return {Root} PostCSS AST
 */

/**
 * @callback stringifier
 *
 * @param {Node} node       - start node for stringifing. Usually {@link Root}.
 * @param {builder} builder - function to concatenate CSS from nodes parts
 *                            or generate string and source map
 *
 * @return {void}
 */

/**
 * @typedef {object} syntax
 * @property {parser} parse          - function to generate AST by string
 * @property {stringifier} stringify - function to generate string by AST
 */

/**
 * @typedef {object} toString
 * @property {function} toString
 */

/**
 * @callback pluginFunction
 * @param {Root} root     - parsed input CSS
 * @param {Result} result - result to set warnings or check other plugins
 */

/**
 * @typedef {object} Plugin
 * @property {function} postcss - PostCSS plugin function
 */

/**
 * @typedef {object} processOptions
 * @property {string} from             - the path of the CSS source file.
 *                                       You should always set `from`,
 *                                       because it is used in source map
 *                                       generation and syntax error messages.
 * @property {string} to               - the path where youll put the output
 *                                       CSS file. You should always set `to`
 *                                       to generate correct source maps.
 * @property {parser} parser           - function to generate AST by string
 * @property {stringifier} stringifier - class to generate string by AST
 * @property {syntax} syntax           - object with `parse` and `stringify`
 * @property {object} map              - source map options
 * @property {boolean} map.inline                    - does source map should
 *                                                     be embedded in the output
 *                                                     CSS as a base64-encoded
 *                                                     comment
 * @property {string|object|false|function} map.prev - source map content
 *                                                     from a previous
 *                                                     processing step
 *                                                     (for example, Sass).
 *                                                     PostCSS will try to find
 *                                                     previous map
 *                                                     automatically, so you
 *                                                     could disable it by
 *                                                     `false` value.
 * @property {boolean} map.sourcesContent            - does PostCSS should set
 *                                                     the origin content to map
 * @property {string|false} map.annotation           - does PostCSS should set
 *                                                     annotation comment to map
 * @property {string} map.from                       - override `from` in maps
 *                                                     `sources`
 */

module.exports = exports['default'];

}, {"1107":1107}];
window.modules["1122"] = [function(require,module,exports){module.exports=[
{"short":"AL","name":"Alabama","country":"US"},
{"short":"AK","name":"Alaska","country":"US"},
{"short":"AZ","name":"Arizona","country":"US"},
{"short":"AR","name":"Arkansas","country":"US"},
{"short":"CA","name":"California","country":"US"},
{"short":"CO","name":"Colorado","country":"US"},
{"short":"CT","name":"Connecticut","country":"US"},
{"short":"DC","name":"District of Columbia","alt":["Washington DC","Washington D.C."],"country":"US"},
{"short":"DE","name":"Delaware","country":"US"},
{"short":"FL","name":"Florida","country":"US"},
{"short":"GA","name":"Georgia","country":"US"},
{"short":"HI","name":"Hawaii","country":"US"},
{"short":"ID","name":"Idaho","country":"US"},
{"short":"IL","name":"Illinois","country":"US"},
{"short":"IN","name":"Indiana","country":"US"},
{"short":"IA","name":"Iowa","country":"US"},
{"short":"KS","name":"Kansas","country":"US"},
{"short":"KY","name":"Kentucky","country":"US"},
{"short":"LA","name":"Louisiana","country":"US"},
{"short":"ME","name":"Maine","country":"US"},
{"short":"MD","name":"Maryland","country":"US"},
{"short":"MA","name":"Massachusetts","country":"US"},
{"short":"MI","name":"Michigan","country":"US"},
{"short":"MN","name":"Minnesota","country":"US"},
{"short":"MS","name":"Mississippi","country":"US"},
{"short":"MO","name":"Missouri","country":"US"},
{"short":"MT","name":"Montana","country":"US"},
{"short":"NE","name":"Nebraska","country":"US"},
{"short":"NV","name":"Nevada","country":"US"},
{"short":"NH","name":"New Hampshire","country":"US"},
{"short":"NJ","name":"New Jersey","country":"US"},
{"short":"NM","name":"New Mexico","country":"US"},
{"short":"NY","name":"New York","country":"US"},
{"short":"NC","name":"North Carolina","country":"US"},
{"short":"ND","name":"North Dakota","country":"US"},
{"short":"OH","name":"Ohio","country":"US"},
{"short":"OK","name":"Oklahoma","country":"US"},
{"short":"OR","name":"Oregon","country":"US"},
{"short":"PA","name":"Pennsylvania","country":"US"},
{"short":"RI","name":"Rhode Island","country":"US"},
{"short":"SC","name":"South Carolina","country":"US"},
{"short":"SD","name":"South Dakota","country":"US"},
{"short":"TN","name":"Tennessee","country":"US"},
{"short":"TX","name":"Texas","country":"US"},
{"short":"UT","name":"Utah","country":"US"},
{"short":"VT","name":"Vermont","country":"US"},
{"short":"VA","name":"Virginia","country":"US"},
{"short":"WA","name":"Washington","country":"US"},
{"short":"WV","name":"West Virginia","country":"US"},
{"short":"WI","name":"Wisconsin","country":"US"},
{"short":"WY","name":"Wyoming","country":"US"},
{"short":"AS","name":"American Samoa","country":"US"},
{"short":"GU","name":"Guam","country":"US"},
{"short":"MP","name":"Northern Mariana Islands","country":"US"},
{"short":"PR","name":"Puerto Rico","country":"US"},
{"short":"UM","name":"United States Minor Outlying Islands","country":"US"},
{"short":"VI","name":"Virgin Islands","country":"US"},

{"short":"AB","name":"Alberta","country":"CA"},
{"short":"BC","name":"British Columbia","country":"CA"},
{"short":"MB","name":"Manitoba","country":"CA"},
{"short":"NB","name":"New Brunswick","country":"CA"},
{"short":"NL","name":"Newfoundland and Labrador","country":"CA","alt":["Newfoundland","Labrador"]},
{"short":"NS","name":"Nova Scotia","country":"CA"},
{"short":"NU","name":"Nunavut","country":"CA"},
{"short":"NT","name":"Northwest Territories","country":"CA"},
{"short":"ON","name":"Ontario","country":"CA"},
{"short":"PE","name":"Prince Edward Island","country":"CA"},
{"short":"QC","name":"Quebec","country":"CA"},
{"short":"SK","name":"Saskatchewan","country":"CA"},
{"short":"YT","name":"Yukon","country":"CA"},

{"name":"Ashmore and Cartier Islands","country":"AU"},
{"name":"Australian Antarctic Territory","country":"AU"},
{"short":"ACT","name":"Australian Capital Territory","country":"AU"},
{"short":"CX","name":"Christmas Island","country":"AU"},
{"short":"CC","name":"Cocos Islands","alt":["Keeling Islands"],"country":"AU"},
{"name":"Coral Sea Islands","country":"AU"},
{"short":"HM","name":"Heard Island and McDonald Islands","country":"AU"},
{"short":"JBT","name":"Jervis Bay Territory","country":"AU"},
{"short":"NSW","name":"New South Wales","country":"AU"},
{"short":"NF","name":"Norfolk Island","country":"AU"},

{"short":"NT","name":"Northern Territory","country":"AU"},
{"short":"QLD","name":"Queensland","country":"AU"},
{"short":"SA","name":"South Australia","country":"AU"},
{"short":"TAS","name":"Tasmania","country":"AU"},
{"short":"VIC","name":"Victoria","country":"AU"},
{"short":"WA","name":"Western Australia","country":"AU"},

{"name":"Aguascalientes","short":"AG","alt":["AGS"],"country":"MX"},
{"name":"Baja California","short":"BC","alt":["BCN"],"country":"MX"},
{"name":"Baja California Sur","short":"BS","alt":["BCS"],"country":"MX"},
{"name":"Campeche","short":"CM","alt":["Camp","CAM"],"country":"MX"},
{"name":"Chiapas","short":"CS","alt":["Chis","CHP"],"country":"MX"},
{"name":"Chihuahua","short":"CH","alt":["Chih","CHH"],"country":"MX"},
{"name":"Coahuila","short":"MX","alt":["Coah","COA"],"country":"MX"},
{"name":"Colima","short":"CL","alt":["COL"],"country":"MX"},
{"name":"Federal District","short":"DF","alt":["DIF"],"country":"MX"},
{"name":"Durango","short":"DG","alt":["Dgo","DUR"],"country":"MX"},
{"name":"Guanajuato","short":"GT","alt":["Gto","GUA"],"country":"MX"},
{"name":"Guerrero","short":"GR","alt":["Gro","GRO"],"country":"MX"},
{"name":"Hidalgo","short":"HG","alt":["Hgo","HID"],"country":"MX"},
{"name":"Jalisco","short":"JA","alt":["Jal","JAL"],"country":"MX"},
{"name":"Mexico","short":"ME","alt":["Edomex","MEX"],"country":"MX"},
{"name":"Michoacn","short":"MI","alt":["Mich","MIC"],"country":"MX"},
{"name":"Morelos","short":"MO","alt":["Mor","MOR"],"country":"MX"},
{"name":"Nayarit","short":"NA","alt":["Nay","NAY"],"country":"MX"},
{"name":"Nuevo Len","short":"NL","alt":["NLE"],"country":"MX"},
{"name":"Oaxaca","short":"OA","alt":["Oax","OAX"],"country":"MX"},
{"name":"Puebla","short":"PU","alt":["Pue","PUE"],"country":"MX"},
{"name":"Quertaro","short":"QE","alt":["Qro","QUE"],"country":"MX"},
{"name":"Quintana Roo","short":"QR","alt":["Q Roo","ROO"],"country":"MX"},
{"name":"San Luis Potos","short":"SL","alt":["SLP"],"country":"MX"},
{"name":"Sinaloa","short":"SI","alt":["SIN"],"country":"MX"},
{"name":"Sonora","short":"SO","alt":["SON"],"country":"MX"},
{"name":"Tabasco","short":"TB","alt":["TAB"],"country":"MX"},
{"name":"Tamaulipas","short":"TM","alt":["Tamps","TAM"],"country":"MX"},
{"name":"Tlaxcala","short":"TL","alt":["Tlax","TLA"],"country":"MX"},
{"name":"Veracruz","short":"VE","alt":["VER"],"country":"MX"},
{"name":"Yucatn","short":"YU","alt":["YUC"],"country":"MX"},
{"name":"Zacatecas","short":"ZA","alt":["ZAC"],"country":"MX"},

{ "name": "", "short": "", "english": "Chongqing", "country": "CN" },
{ "name": "", "short": "","english": "Heilongjiang", "country": "CN" },
{ "name": "", "short": "", "english": "Jilin", "country": "CN" },
{ "name": "", "short": "", "english": "Hainan", "country": "CN" },
{ "name": "", "short": "","english": "Beijing",  "country": "CN" },
{ "name": "", "short": "", "english": "Liaoning", "country": "CN" },
{ "name": "", "short": "", "english": "Inner Mongolia","alt":["Nei Menggu"], "country": "CN" },
{ "name": "", "short": "", "english": "Xizang", "alt":["Tibet"], "country": "CN" },
{ "name": "", "short": "", "english": "Qinghai", "country": "CN" },
{ "name": "", "short": "", "english": "Ningxia", "country": "CN" },
{ "name": "", "short": "", "english": "Xinjiang","alt":["Uygur"], "country": "CN" },
{ "name": "", "short": "", "english": "Gansu", "country": "CN" },
{ "name": "", "short": "", "english": "Hebei", "country": "CN" },
{ "name": "", "short": "", "english": "Henan", "country": "CN" },
{ "name": "", "short": "", "english": "Hubei", "country": "CN" },
{ "name": "", "short": "", "english": "Hunan", "country": "CN" },
{ "name": "", "short": "", "english": "Shandong", "country": "CN" },
{ "name": "", "short": "", "english": "Jiangsu", "country": "CN" },
{ "name": "", "short": "", "english": "Anhui", "country": "CN" },
{ "name": "", "short": "", "english": "Shanxi", "country": "CN" },
{ "name": "", "short": "", "english": "Shaanxi", "country": "CN" },
{ "name": "", "short": "", "english": "sichuan", "country": "CN" },
{ "name": "", "short": "", "english": "Yunnan", "country": "CN" },
{ "name": "", "short": "", "english": "Guizhou", "country": "CN" },
{ "name": "", "short": "", "english": "Zhejiang", "country": "CN" },
{ "name": "", "short": "", "english": "Fujian", "country": "CN" },
{ "name": "", "short": "", "english": "Guangxi", "country": "CN" },
{ "name": "", "short": "", "english": "Shanghai", "country": "CN" },
{ "name": "", "short": "", "english": "Tianjin", "country": "CN" },
{ "name": "", "short": "", "english": "Hongkong", "alt":["Hong Kong"] ,"country": "CN" },
{ "name": "", "short": "", "english": "Macau","alt":["Macao"] , "country": "CN" },
{ "name": "", "short": "", "english": "Taiwan", "country": "CN" },
{ "name": "", "short": "", "english": "Jiangxi", "country": "CN" },
{ "name": "", "short": "", "english": "Guangdong", "country": "CN" },

{ "name": "Avon", "country": "GB", "region": "England" },
{ "name": "Bedfordshire", "country": "GB", "region": "England" },
{ "name": "Berkshire", "country": "GB", "region": "England" },
{ "name": "Borders", "country": "GB", "region": "England" },
{ "name": "Bristol", "country": "GB", "region": "England" },
{ "name": "Buckinghamshire", "country": "GB", "region": "England" },
{ "name": "Cambridgeshire", "country": "GB", "region": "England" },
{ "name": "Channel Islands", "country": "GB", "region": "England" },
{ "name": "Cheshire", "country": "GB", "region": "England" },
{ "name": "Cleveland", "country": "GB", "region": "England" },
{ "name": "Cornwall", "country": "GB", "region": "England" },
{ "name": "Cumbria", "country": "GB", "region": "England" },
{ "name": "Derbyshire", "country": "GB", "region": "England" },
{ "name": "Devon", "country": "GB", "region": "England" },
{ "name": "Dorset", "country": "GB", "region": "England" },
{ "name": "Durham", "country": "GB", "region": "England" },
{ "name": "East Riding of Yorkshire", "country": "GB", "region": "England" },
{ "name": "East Sussex", "country": "GB", "region": "England" },
{ "name": "Essex", "country": "GB", "region": "England" },
{ "name": "Gloucestershire", "country": "GB", "region": "England" },
{ "name": "Greater Manchester", "country": "GB", "region": "England" },
{ "name": "Hampshire", "country": "GB", "region": "England" },
{ "name": "Herefordshire", "country": "GB", "region": "England" },
{ "name": "Hertfordshire", "country": "GB", "region": "England" },
{ "name": "Humberside", "country": "GB", "region": "England" },
{ "name": "Isle of Man", "country": "GB", "region": "England" },
{ "name": "Isle of Wight", "country": "GB", "region": "England" },
{ "name": "Isles of Scilly", "country": "GB", "region": "England" },
{ "name": "Kent", "country": "GB", "region": "England" },
{ "name": "Lancashire", "country": "GB", "region": "England" },
{ "name": "Leicestershire", "country": "GB", "region": "England" },
{ "name": "Lincolnshire", "country": "GB", "region": "England" },
{ "name": "London", "country": "GB", "region": "England" },
{ "name": "Merseyside", "country": "GB", "region": "England" },
{ "name": "Middlesex", "country": "GB", "region": "England" },
{ "name": "Norfolk", "country": "GB", "region": "England" },
{ "name": "North Yorkshire", "country": "GB", "region": "England" },
{ "name": "Northamptonshire", "country": "GB", "region": "England" },
{ "name": "Northumberland", "country": "GB", "region": "England" },
{ "name": "Nottinghamshire", "country": "GB", "region": "England" },
{ "name": "Oxfordshire", "country": "GB", "region": "England" },
{ "name": "Rutland", "country": "GB", "region": "England" },
{ "name": "Shropshire", "country": "GB", "region": "England" },
{ "name": "Somerset", "country": "GB", "region": "England" },
{ "name": "South Yorkshire", "country": "GB", "region": "England" },
{ "name": "Staffordshire", "country": "GB", "region": "England" },
{ "name": "Suffolk", "country": "GB", "region": "England" },
{ "name": "Surrey", "country": "GB", "region": "England" },
{ "name": "Tyne and Wear", "country": "GB", "region": "England" },
{ "name": "Warwickshire", "country": "GB", "region": "England" },
{ "name": "West Midlands", "country": "GB", "region": "England" },
{ "name": "West Sussex", "country": "GB", "region": "England" },
{ "name": "West Yorkshire", "country": "GB", "region": "England" },
{ "name": "Wiltshire", "country": "GB", "region": "England" },
{ "name": "Worcestershire", "country": "GB", "region": "England" },

{ "name": "Antrim", "country": "GB", "region": "Northern Ireland" },
{ "name": "Down", "country": "GB", "region": "Northern Ireland" },
{ "name": "Fermanagh", "country": "GB", "region": "Northern Ireland" },
{ "name": "Londonderry", "country": "GB", "region": "Northern Ireland" },
{ "name": "Tyrone", "country": "GB", "region": "Northern Ireland" },

{ "name": "Aberdeen City", "country": "GB", "region": "Scotland" },
{ "name": "Aberdeenshire", "country": "GB", "region": "Scotland" },
{ "name": "Angus", "country": "GB", "region": "Scotland" },
{ "name": "Argyll and Bute", "country": "GB", "region": "Scotland" },
{ "name": "Armagh", "country": "GB", "region": "Scotland" },
{ "name": "Carmarthenshire", "country": "GB", "region": "Scotland" },
{ "name": "Clackmannan", "country": "GB", "region": "Scotland" },
{ "name": "Dumfries and Galloway", "country": "GB", "region": "Scotland" },
{ "name": "East Ayrshire", "country": "GB", "region": "Scotland" },
{ "name": "East Dunbartonshire", "country": "GB", "region": "Scotland" },
{ "name": "East Lothian", "country": "GB", "region": "Scotland" },
{ "name": "East Renfrewshire", "country": "GB", "region": "Scotland" },
{ "name": "Edinburgh City", "country": "GB", "region": "Scotland" },
{ "name": "Falkirk", "country": "GB", "region": "Scotland" },
{ "name": "Fife", "country": "GB", "region": "Scotland" },
{ "name": "Glasgow", "country": "GB", "region": "Scotland" },
{ "name": "Highland", "country": "GB", "region": "Scotland" },
{ "name": "Inverclyde", "country": "GB", "region": "Scotland" },
{ "name": "Midlothian", "country": "GB", "region": "Scotland" },
{ "name": "Moray", "country": "GB", "region": "Scotland" },
{ "name": "North Ayrshire", "country": "GB", "region": "Scotland" },
{ "name": "North Lanarkshire", "country": "GB", "region": "Scotland" },
{ "name": "Orkney", "country": "GB", "region": "Scotland" },
{ "name": "Perthshire and Kinross", "country": "GB", "region": "Scotland" },
{ "name": "Renfrewshire", "country": "GB", "region": "Scotland" },
{ "name": "Roxburghshire", "country": "GB", "region": "Scotland" },
{ "name": "Shetland", "country": "GB", "region": "Scotland" },
{ "name": "South Ayrshire", "country": "GB", "region": "Scotland" },
{ "name": "South Lanarkshire", "country": "GB", "region": "Scotland" },
{ "name": "Stirling", "country": "GB", "region": "Scotland" },
{ "name": "West Dunbartonshire", "country": "GB", "region": "Scotland" },
{ "name": "West Lothian", "country": "GB", "region": "Scotland" },
{ "name": "Western Isles", "country": "GB", "region": "Scotland" },

{ "name": "Blaenau Gwent", "country": "GB", "region": "Wales" },
{ "name": "Bridgend", "country": "GB", "region": "Wales" },
{ "name": "Caerphilly", "country": "GB", "region": "Wales" },
{ "name": "Cardiff", "country": "GB", "region": "Wales" },
{ "name": "Ceredigion", "country": "GB", "region": "Wales" },
{ "name": "Conwy", "country": "GB", "region": "Wales" },
{ "name": "Denbighshire", "country": "GB", "region": "Wales" },
{ "name": "Flintshire", "country": "GB", "region": "Wales" },
{ "name": "Gwynedd", "country": "GB", "region": "Wales" },
{ "name": "Isle of Anglesey", "country": "GB", "region": "Wales" },
{ "name": "Merthyr Tydfil", "country": "GB", "region": "Wales" },
{ "name": "Monmouthshire", "country": "GB", "region": "Wales" },
{ "name": "Neath Port Talbot", "country": "GB", "region": "Wales" },
{ "name": "Newport", "country": "GB", "region": "Wales" },
{ "name": "Pembrokeshire", "country": "GB", "region": "Wales" },
{ "name": "Powys", "country": "GB", "region": "Wales" },
{ "name": "Rhondda Cynon Taff", "country": "GB", "region": "Wales" },
{ "name": "Swansea", "country": "GB", "region": "Wales" },
{ "name": "The Vale of Glamorgan", "country": "GB", "region": "Wales" },
{ "name": "Torfaen", "country": "GB", "region": "Wales" },
{ "name": "Wrexham", "country": "GB", "region": "Wales" },

{"short":"BW","name":"Baden-Wrttemberg","country":"DE"},
{"short":"BY","name":"Bayern","country":"DE"},
{"short":"BE","name":"Berlin","country":"DE"},
{"short":"BB","name":"Brandenburg","country":"DE"},
{"short":"HB","name":"Bremen","country":"DE"},
{"short":"HH","name":"Hamburg","country":"DE"},
{"short":"HE","name":"Hessen","country":"DE"},
{"short":"MV","name":"Mecklenburg-Vorpommern","country":"DE"},
{"short":"NI","name":"Niedersachsen","country":"DE"},
{"short":"NW","name":"Nordrhein-Westfalen","country":"DE"},
{"short":"RP","name":"Rheinland-Pfalz","country":"DE"},
{"short":"SL","name":"Saarland","country":"DE"},
{"short":"SN","name":"Sachsen","country":"DE"},
{"short":"ST","name":"Sachsen-Anhalt","country":"DE"},
{"short":"SH","name":"Schleswig-Holstein","country":"DE"},
{"short":"TH","name":"Thringen","country":"DE"},

{"short":"DR","name":"Drenthe","country":"NL"},
{"short":"FL","name":"Flevoland","country":"NL"},
{"short":"FR","name":"Friesland","country":"NL","alt":["Frysln"]},
{"short":"GD","name":"Gelderland","country":"NL"},
{"short":"GR","name":"Groningen","country":"NL"},
{"short":"LB","name":"Limburg","country":"NL"},
{"short":"NB","name":"Noord-Brabant","country":"NL"},
{"short":"NH","name":"Noord-Holland","country":"NL"},
{"short":"OV","name":"Overijssel","country":"NL"},
{"short":"UT","name":"Utrecht","country":"NL"},
{"short":"ZH","name":"Zuid-Holland","country":"NL"},
{"short":"ZL","name":"Zeeland","country":"NL"},

{"short":"ANT","name":"Antwerpen","country":"BE"},
{"short":"HAI","name":"Henegouwen","country":"BE", "alt": ["Hainaut"]},
{"short":"LIE","name":"Luik","country":"BE", "alt": ["Lige"]},
{"short":"LIM","name":"Limburg","country":"BE"},
{"short":"LUX","name":"Luxemburg","country":"BE"},
{"short":"NAM","name":"Namen","country":"BE"},
{"short":"OVL","name":"Oost-Vlaanderen","country":"BE"},
{"short":"VBR","name":"Vlaams-Brabant","country":"BE"},
{"short":"WBR","name":"Waals-Brabant","country":"BE"},
{"short":"WVL","name":"West-Vlaanderen","country":"BE"},

{"name":"Hovedstaden","country":"DK"},
{"name":"Midtjylland","country":"DK"},
{"name":"Nordjylland","country":"DK"},
{"name":"Sjlland","country":"DK"},
{"name":"Syddanmark","country":"DK"},

{ "name": "Adana", "country": "TR" },
{ "name": "Adyaman", "country": "TR" },
{ "name": "Afyonkarahisar", "country": "TR" },
{ "name": "Ar", "country": "TR" },
{ "name": "Amasya", "country": "TR" },
{ "name": "Ankara", "country": "TR" },
{ "name": "Antalya", "country": "TR" },
{ "name": "Artvin", "country": "TR" },
{ "name": "Aydn", "country": "TR" },
{ "name": "Balkesir", "country": "TR" },
{ "name": "Bilecik", "country": "TR" },
{ "name": "Bingl", "country": "TR" },
{ "name": "Bitlis", "country": "TR" },
{ "name": "Bolu", "country": "TR" },
{ "name": "Burdur", "country": "TR" },
{ "name": "Bursa", "country": "TR" },
{ "name": "anakkale", "country": "TR" },
{ "name": "ankr", "country": "TR" },
{ "name": "orum", "country": "TR" },
{ "name": "Denizli", "country": "TR" },
{ "name": "Diyarbakr", "country": "TR" },
{ "name": "Edirne", "country": "TR" },
{ "name": "Elaz", "country": "TR" },
{ "name": "Erzincan", "country": "TR" },
{ "name": "Erzurum", "country": "TR" },
{ "name": "Eskiehir", "country": "TR" },
{ "name": "Gaziantep", "country": "TR" },
{ "name": "Giresun", "country": "TR" },
{ "name": "Gmhane", "country": "TR" },
{ "name": "Hakkri", "country": "TR" },
{ "name": "Hatay", "country": "TR" },
{ "name": "Isparta", "country": "TR" },
{ "name": "Mersin", "country": "TR" },
{ "name": "Istanbul", "country": "TR" },
{ "name": "zmir", "country": "TR" },
{ "name": "Kars", "country": "TR" },
{ "name": "Kastamonu", "country": "TR" },
{ "name": "Kayseri", "country": "TR" },
{ "name": "Krklareli", "country": "TR" },
{ "name": "Krehir", "country": "TR" },
{ "name": "Kocaeli", "country": "TR" },
{ "name": "Konya", "country": "TR" },
{ "name": "Ktahya", "country": "TR" },
{ "name": "Malatya", "country": "TR" },
{ "name": "Manisa", "country": "TR" },
{ "name": "Kahramanmara", "country": "TR" },
{ "name": "Mardin", "country": "TR" },
{ "name": "Mula", "country": "TR" },
{ "name": "Mu", "country": "TR" },
{ "name": "Nevehir", "country": "TR" },
{ "name": "Nide", "country": "TR" },
{ "name": "Ordu", "country": "TR" },
{ "name": "Rize", "country": "TR" },
{ "name": "Sakarya", "country": "TR" },
{ "name": "Samsun", "country": "TR" },
{ "name": "Siirt", "country": "TR" },
{ "name": "Sinop", "country": "TR" },
{ "name": "Sivas", "country": "TR" },
{ "name": "Tekirda", "country": "TR" },
{ "name": "Tokat", "country": "TR" },
{ "name": "Trabzon", "country": "TR" },
{ "name": "Tunceli", "country": "TR" },
{ "name": "anlurfa", "country": "TR" },
{ "name": "Uak", "country": "TR" },
{ "name": "Van", "country": "TR" },
{ "name": "Yozgat", "country": "TR" },
{ "name": "Zonguldak", "country": "TR" },
{ "name": "Aksaray", "country": "TR" },
{ "name": "Bayburt", "country": "TR" },
{ "name": "Karaman", "country": "TR" },
{ "name": "Krkkale", "country": "TR" },
{ "name": "Batman", "country": "TR" },
{ "name": "rnak", "country": "TR" },
{ "name": "Bartn", "country": "TR" },
{ "name": "Ardahan", "country": "TR" },
{ "name": "Idr", "country": "TR" },
{ "name": "Yalova", "country": "TR" },
{ "name": "Karabk", "country": "TR" },
{ "name": "Kilis", "country": "TR" },
{ "name": "Osmaniye", "country": "TR" },
{ "name": "Dzce", "country": "TR" },

{ "short": "ID-AC", "name": "Special Region of Aceh", "country": "ID" },
{ "short": "ID-BA", "name": "Bali", "country": "ID" },
{ "short": "ID-BB", "name": "BangkaBelitung Islands", "country": "ID" },
{ "short": "ID-BT", "name": "Banten", "country": "ID" },
{ "short": "ID-BE", "name": "Bengkulu", "country": "ID" },
{ "short": "ID-JT", "name": "Central Java", "country": "ID" },
{ "short": "ID-KT", "name": "Central Kalimantan", "country": "ID" },
{ "short": "ID-ST", "name": "Central Sulawesi", "country": "ID" },
{ "short": "ID-JI", "name": "East Java", "country": "ID" },
{ "short": "ID-KI", "name": "East Kalimantan", "country": "ID" },
{ "short": "ID-NT", "name": "East Nusa Tenggara", "country": "ID" },
{ "short": "ID-GO", "name": "Gorontalo", "country": "ID" },
{ "short": "ID-JK", "name": "Jakarta Special Capital Region", "country": "ID" },
{ "short": "ID-JA", "name": "Jambi", "country": "ID" },
{ "short": "ID-LA", "name": "Lampung", "country": "ID" },
{ "short": "ID-MA", "name": "Maluku", "country": "ID" },
{ "short": "ID-KU", "name": "North Kalimantan", "country": "ID" },
{ "short": "ID-MU", "name": "North Maluku", "country": "ID" },
{ "short": "ID-SA", "name": "North Sulawesi", "country": "ID" },
{ "short": "ID-SU", "name": "North Sumatra", "country": "ID" },
{ "short": "ID-PA", "name": "Special Region of Papua", "country": "ID" },
{ "short": "ID-RI", "name": "Riau", "country": "ID" },
{ "short": "ID-KR", "name": "Riau Islands", "country": "ID" },
{ "short": "ID-SG", "name": "Southeast Sulawesi", "country": "ID" },
{ "short": "ID-KS", "name": "South Kalimantan", "country": "ID" },
{ "short": "ID-SN", "name": "South Sulawesi", "country": "ID" },
{ "short": "ID-SS", "name": "South Sumatra", "country": "ID" },
{ "short": "ID-JB", "name": "West Java", "country": "ID" },
{ "short": "ID-KB", "name": "West Kalimantan", "country": "ID" },
{ "short": "ID-NB", "name": "West Nusa Tenggara", "country": "ID" },
{ "short": "ID-PB", "name": "Special Region of West Papua", "country": "ID" },
{ "short": "ID-SR", "name": "West Sulawesi", "country": "ID" },
{ "short": "ID-SB", "name": "West Sumatra", "country": "ID" },
{ "short": "ID-YO", "name": "Special Region of Yogyakarta", "country": "ID" },

{ "name": "Irbid", "country": "JO" },
{ "name": "Ajloun", "country": "JO" },
{ "name": "Jerash", "country": "JO" },
{ "name": "Mafraq", "country": "JO" },
{ "name": "Balqa", "country": "JO" },
{ "name": "Amman", "country": "JO" },
{ "name": "Zarqa", "country": "JO" },
{ "name": "Madaba", "country": "JO" },
{ "name": "Karak", "country": "JO" },
{ "name": "Tafilah", "country": "JO" },
{ "name": "Ma'an", "country": "JO" },
{ "name": "Aqaba", "country": "JO" },

{ "short": "AP", "name": "Andhra Pradesh", "country": "IN" },
{ "short": "AR", "name": "Arunachal Pradesh", "country": "IN" },
{ "short": "AS", "name": "Assam", "country": "IN" },
{ "short": "BR", "name": "Bihar", "country": "IN" },
{ "short": "CT", "name": "Chhattisgarh", "country": "IN" },
{ "short": "GA", "name": "Goa", "country": "IN" },
{ "short": "GJ", "name": "Gujarat", "country": "IN" },
{ "short": "HR", "name": "Haryana", "country": "IN" },
{ "short": "HP", "name": "Himachal Pradesh", "country": "IN" },
{ "short": "JK", "name": "Jammu and Kashmir", "country": "IN" },
{ "short": "JH", "name": "Jharkhand", "country": "IN" },
{ "short": "KA", "name": "Karnataka", "country": "IN" },
{ "short": "KL", "name": "Kerala", "country": "IN" },
{ "short": "MP", "name": "Madhya Pradesh", "country": "IN" },
{ "short": "MH", "name": "Maharashtra", "country": "IN" },
{ "short": "MN", "name": "Manipur", "country": "IN" },
{ "short": "ML", "name": "Meghalaya", "country": "IN" },
{ "short": "MZ", "name": "Mizoram", "country": "IN" },
{ "short": "NL", "name": "Nagaland", "country": "IN" },
{ "short": "OR", "name": "Odisha", "country": "IN" },
{ "short": "PB", "name": "Punjab", "country": "IN" },
{ "short": "RJ", "name": "Rajasthan", "country": "IN" },
{ "short": "SK", "name": "Sikkim", "country": "IN" },
{ "short": "TN", "name": "Tamil Nadu", "country": "IN" },
{ "short": "TG", "name": "Telangana", "country": "IN" },
{ "short": "TR", "name": "Tripura", "country": "IN" },
{ "short": "UP", "name": "Uttar Pradesh", "country": "IN" },
{ "short": "UT", "name": "Uttarakhand", "country": "IN" },
{ "short": "WB", "name": "West Bengal", "country": "IN" },
{ "short": "AN", "name": "Andaman and Nicobar Islands", "country": "IN" },
{ "short": "CH", "name": "Chandigarh", "country": "IN" },
{ "short": "DN", "name": "Dadra and Nagar Haveli", "country": "IN" },
{ "short": "DD", "name": "Daman and Diu", "country": "IN" },
{ "short": "LD", "name": "Lakshadweep", "country": "IN" },
{ "short": "DL", "name": "National Capital Territory of Delhi", "country": "IN" },
{ "short": "PY", "name": "Puducherry", "country": "IN" },


{ "name": "", "english": "Phnom Penh Municipality", "country": "KH" },
{ "name": "", "english": "Banteay Meanchey", "country": "KH" },
{ "name": "", "english": "Battambang", "country": "KH" },
{ "name": "", "english": "Kampong Cham", "country": "KH" },
{ "name": "", "english": "Kampong Chhnang", "country": "KH" },
{ "name": "", "english": "Kampong Speu", "country": "KH" },
{ "name": "", "english": "Kampong Thom", "country": "KH" },
{ "name": "", "english": "Kampot", "country": "KH" },
{ "name": "", "english": "Kandal", "country": "KH" },
{ "name": "", "english": "Koh Kong", "country": "KH" },
{ "name": "", "english": "Kep", "country": "KH" },
{ "name": "", "english": "Krati", "country": "KH" },
{ "name": "", "english": "Mondulkiri", "country": "KH" },
{ "name": "", "english": "Oddar Meanchey", "country": "KH" },
{ "name": "", "english": "Pailin", "country": "KH" },
{ "name": "", "english": "Preah Sihanouk", "country": "KH" },
{ "name": "", "english": "Preah Vihear", "country": "KH" },
{ "name": "", "english": "Pursat", "country": "KH" },
{ "name": "", "english": "Prey Veng", "country": "KH" },
{ "name": "", "english": "Ratanakiri", "country": "KH" },
{ "name": "", "english": "Siem Reap", "country": "KH" },
{ "name": "", "english": "Stung Treng", "country": "KH" },
{ "name": "", "english": "Svay Rieng", "country": "KH" },
{ "name": "", "english": "Tako", "country": "KH" },
{ "name": "", "english": "Tbong Khmum", "country": "KH" },

{ "name": "Addis Ababa", "country": "ET" },
{ "name": "Afar Region", "country": "ET" },
{ "name": "Amhara Region", "country": "ET" },
{ "name": "Benishangul-Gumuz", "country": "ET" },
{ "name": "Dire Dawa", "country": "ET" },
{ "name": "Gambela", "country": "ET" },
{ "name": "Harari", "country": "ET" },
{ "name": "Oromia", "country": "ET" },
{ "name": "Somali", "country": "ET" },
{ "name": "Southern Nations, Nationalities, and Peoples' Region", "country": "ET" },
{ "name": "Tigray Region", "country": "ET" },

{ "name": "Chachapoyas", "region": "Amazonas", "country": "PE" },
{ "name": "Bagua", "region": "Amazonas", "country": "PE" },
{ "name": "Bongar", "region": "Amazonas", "country": "PE" },
{ "name": "Condorcanqui", "region": "Amazonas", "country": "PE" },
{ "name": "Luya", "region": "Amazonas", "country": "PE" },
{ "name": "Rodrguez de Mendoza", "region": "Amazonas", "country": "PE" },
{ "name": "Utcubamba", "region": "Amazonas", "country": "PE" },
{ "name": "Huaraz", "region": "Ancash", "country": "PE" },
{ "name": "Aija", "region": "Ancash", "country": "PE" },
{ "name": "Antonio Raymondi", "region": "Ancash", "country": "PE" },
{ "name": "Asuncin", "region": "Ancash", "country": "PE" },
{ "name": "Bolognesi", "region": "Ancash", "country": "PE" },
{ "name": "Carhuaz", "region": "Ancash", "country": "PE" },
{ "name": "Carlos Fermn Fitzcarrald", "region": "Ancash", "country": "PE" },
{ "name": "Casma", "region": "Ancash", "country": "PE" },
{ "name": "Corongo", "region": "Ancash", "country": "PE" },
{ "name": "Huari", "region": "Ancash", "country": "PE" },
{ "name": "Huarmey", "region": "Ancash", "country": "PE" },
{ "name": "Huaylas", "region": "Ancash", "country": "PE" },
{ "name": "Mariscal Luzuriaga", "region": "Ancash", "country": "PE" },
{ "name": "Ocros", "region": "Ancash", "country": "PE" },
{ "name": "Pallasca", "region": "Ancash", "country": "PE" },
{ "name": "Pomabamba", "region": "Ancash", "country": "PE" },
{ "name": "Recuay", "region": "Ancash", "country": "PE" },
{ "name": "Santa", "region": "Ancash", "country": "PE" },
{ "name": "Sihuas", "region": "Ancash", "country": "PE" },
{ "name": "Yungay", "region": "Ancash", "country": "PE" },
{ "name": "Abancay", "region": "Apurmac", "country": "PE" },
{ "name": "Andahuaylas", "region": "Apurmac", "country": "PE" },
{ "name": "Antabamba", "region": "Apurmac", "country": "PE" },
{ "name": "Aymaraes", "region": "Apurmac", "country": "PE" },
{ "name": "Cotabambas", "region": "Apurmac", "country": "PE" },
{ "name": "Chincheros", "region": "Apurmac", "country": "PE" },
{ "name": "Grau", "region": "Apurmac", "country": "PE" },
{ "name": "Arequipa", "region": "Arequipa", "country": "PE" },
{ "name": "Caman", "region": "Arequipa", "country": "PE" },
{ "name": "Caravel", "region": "Arequipa", "country": "PE" },
{ "name": "Castilla", "region": "Arequipa", "country": "PE" },
{ "name": "Caylloma", "region": "Arequipa", "country": "PE" },
{ "name": "Condesuyos", "region": "Arequipa", "country": "PE" },
{ "name": "Islay", "region": "Arequipa", "country": "PE" },
{ "name": "La Unin", "region": "Arequipa", "country": "PE" },
{ "name": "Huamanga", "region": "Ayacucho", "country": "PE" },
{ "name": "Cangallo", "region": "Ayacucho", "country": "PE" },
{ "name": "Huanca Sancos", "region": "Ayacucho", "country": "PE" },
{ "name": "Huanta", "region": "Ayacucho", "country": "PE" },
{ "name": "La Mar", "region": "Ayacucho", "country": "PE" },
{ "name": "Lucanas", "region": "Ayacucho", "country": "PE" },
{ "name": "Parinacochas", "region": "Ayacucho", "country": "PE" },
{ "name": "Pucar del Sara Sara", "region": "Ayacucho", "country": "PE" },
{ "name": "Sucre", "region": "Ayacucho", "country": "PE" },
{ "name": "Vctor Fajardo", "region": "Ayacucho", "country": "PE" },
{ "name": "Vilcas Huamn", "region": "Ayacucho", "country": "PE" },
{ "name": "Cajamarca", "region": "Cajamarca", "country": "PE" },
{ "name": "Cajabamba", "region": "Cajamarca", "country": "PE" },
{ "name": "Celendn", "region": "Cajamarca", "country": "PE" },
{ "name": "Chota", "region": "Cajamarca", "country": "PE" },
{ "name": "Contumaz", "region": "Cajamarca", "country": "PE" },
{ "name": "Cutervo", "region": "Cajamarca", "country": "PE" },
{ "name": "Hualgayoc", "region": "Cajamarca", "country": "PE" },
{ "name": "Jan", "region": "Cajamarca", "country": "PE" },
{ "name": "San Ignacio", "region": "Cajamarca", "country": "PE" },
{ "name": "San Marcos", "region": "Cajamarca", "country": "PE" },
{ "name": "San Miguel", "region": "Cajamarca", "country": "PE" },
{ "name": "San Pablo", "region": "Cajamarca", "country": "PE" },
{ "name": "Santa Cruz", "region": "Cajamarca", "country": "PE" },
{ "name": "Callao", "region": "Callao", "country": "PE" },
{ "name": "Cusco", "region": "Cusco", "country": "PE" },
{ "name": "Acomayo", "region": "Cusco", "country": "PE" },
{ "name": "Anta", "region": "Cusco", "country": "PE" },
{ "name": "Calca", "region": "Cusco", "country": "PE" },
{ "name": "Canas", "region": "Cusco", "country": "PE" },
{ "name": "Canchis", "region": "Cusco", "country": "PE" },
{ "name": "Chumbivilcas", "region": "Cusco", "country": "PE" },
{ "name": "Espinar", "region": "Cusco", "country": "PE" },
{ "name": "La Convencin", "region": "Cusco", "country": "PE" },
{ "name": "Paruro", "region": "Cusco", "country": "PE" },
{ "name": "Paucartambo", "region": "Cusco", "country": "PE" },
{ "name": "Quispicanchi", "region": "Cusco", "country": "PE" },
{ "name": "Urubamba", "region": "Cusco", "country": "PE" },
{ "name": "Huancavelica", "region": "Huancavelica", "country": "PE" },
{ "name": "Acobamba", "region": "Huancavelica", "country": "PE" },
{ "name": "Angaraes", "region": "Huancavelica", "country": "PE" },
{ "name": "Castrovirreyna", "region": "Huancavelica", "country": "PE" },
{ "name": "Churcampa", "region": "Huancavelica", "country": "PE" },
{ "name": "Huaytar", "region": "Huancavelica", "country": "PE" },
{ "name": "Tayacaja", "region": "Huancavelica", "country": "PE" },
{ "name": "Hunuco", "region": "Hunuco", "country": "PE" },
{ "name": "Ambo", "region": "Hunuco", "country": "PE" },
{ "name": "Dos de Mayo", "region": "Hunuco", "country": "PE" },
{ "name": "Huacaybamba", "region": "Hunuco", "country": "PE" },
{ "name": "Huamales", "region": "Hunuco", "country": "PE" },
{ "name": "Leoncio Prado", "region": "Hunuco", "country": "PE" },
{ "name": "Maran", "region": "Hunuco", "country": "PE" },
{ "name": "Pachitea", "region": "Hunuco", "country": "PE" },
{ "name": "Puerto Inca", "region": "Hunuco", "country": "PE" },
{ "name": "Lauricocha", "region": "Hunuco", "country": "PE" },
{ "name": "Yarowilca", "region": "Hunuco", "country": "PE" },
{ "name": "Ica", "region": "Ica", "country": "PE" },
{ "name": "Chincha", "region": "Ica", "country": "PE" },
{ "name": "Nazca", "region": "Ica", "country": "PE" },
{ "name": "Palpa", "region": "Ica", "country": "PE" },
{ "name": "Pisco", "region": "Ica", "country": "PE" },
{ "name": "Huancayo", "region": "Junn", "country": "PE" },
{ "name": "Concepcin", "region": "Junn", "country": "PE" },
{ "name": "Chanchamayo", "region": "Junn", "country": "PE" },
{ "name": "Jauja", "region": "Junn", "country": "PE" },
{ "name": "Junn", "region": "Junn", "country": "PE" },
{ "name": "Satipo", "region": "Junn", "country": "PE" },
{ "name": "Tarma", "region": "Junn", "country": "PE" },
{ "name": "Yauli", "region": "Junn", "country": "PE" },
{ "name": "Chupaca", "region": "Junn", "country": "PE" },
{ "name": "Trujillo", "region": "La Libertad", "country": "PE" },
{ "name": "Ascope", "region": "La Libertad", "country": "PE" },
{ "name": "Bolvar", "region": "La Libertad", "country": "PE" },
{ "name": "Chepn", "region": "La Libertad", "country": "PE" },
{ "name": "Julcn", "region": "La Libertad", "country": "PE" },
{ "name": "Otuzco", "region": "La Libertad", "country": "PE" },
{ "name": "Pacasmayo", "region": "La Libertad", "country": "PE" },
{ "name": "Pataz", "region": "La Libertad", "country": "PE" },
{ "name": "Snchez Carrin", "region": "La Libertad", "country": "PE" },
{ "name": "Santiago de Chuco", "region": "La Libertad", "country": "PE" },
{ "name": "Gran Chim", "region": "La Libertad", "country": "PE" },
{ "name": "Vir", "region": "La Libertad", "country": "PE" },
{ "name": "Chiclayo", "region": "Lambayeque", "country": "PE" },
{ "name": "Ferreafe", "region": "Lambayeque", "country": "PE" },
{ "name": "Lambayeque", "region": "Lambayeque", "country": "PE" },
{ "name": "Lima", "region": "autonomous", "country": "PE" },
{ "name": "Huaura", "region": "Lima", "country": "PE" },
{ "name": "Barranca", "region": "Lima", "country": "PE" },
{ "name": "Cajatambo", "region": "Lima", "country": "PE" },
{ "name": "Canta", "region": "Lima", "country": "PE" },
{ "name": "Caete", "region": "Lima", "country": "PE" },
{ "name": "Huaral", "region": "Lima", "country": "PE" },
{ "name": "Huarochir", "region": "Lima", "country": "PE" },
{ "name": "Oyn", "region": "Lima", "country": "PE" },
{ "name": "Yauyos", "region": "Lima", "country": "PE" },
{ "name": "Maynas", "region": "Loreto", "country": "PE" },
{ "name": "Alto Amazonas", "region": "Loreto", "country": "PE" },
{ "name": "Loreto", "region": "Loreto", "country": "PE" },
{ "name": "Mariscal Ramn Castilla", "region": "Loreto", "country": "PE" },
{ "name": "Putumayo", "region": "Loreto", "country": "PE" },
{ "name": "Requena", "region": "Loreto", "country": "PE" },
{ "name": "Ucayali", "region": "Loreto", "country": "PE" },
{ "name": "Datem del Maran", "region": "Loreto", "country": "PE" },
{ "name": "Tambopata", "region": "Madre de Dios", "country": "PE" },
{ "name": "Man", "region": "Madre de Dios", "country": "PE" },
{ "name": "Tahuamanu", "region": "Madre de Dios", "country": "PE" },
{ "name": "Mariscal Nieto", "region": "Moquegua", "country": "PE" },
{ "name": "General Snchez Cerro", "region": "Moquegua", "country": "PE" },
{ "name": "Ilo", "region": "Moquegua", "country": "PE" },
{ "name": "Pasco", "region": "Pasco", "country": "PE" },
{ "name": "Daniel Alcdes Carrin", "region": "Pasco", "country": "PE" },
{ "name": "Oxapampa", "region": "Pasco", "country": "PE" },
{ "name": "Piura", "region": "Piura", "country": "PE" },
{ "name": "Ayabaca", "region": "Piura", "country": "PE" },
{ "name": "Huancabamba", "region": "Piura", "country": "PE" },
{ "name": "Morropn", "region": "Piura", "country": "PE" },
{ "name": "Paita", "region": "Piura", "country": "PE" },
{ "name": "Sullana", "region": "Piura", "country": "PE" },
{ "name": "Talara", "region": "Piura", "country": "PE" },
{ "name": "Sechura", "region": "Piura", "country": "PE" },
{ "name": "Puno", "region": "Puno", "country": "PE" },
{ "name": "Azngaro", "region": "Puno", "country": "PE" },
{ "name": "Carabaya", "region": "Puno", "country": "PE" },
{ "name": "Chucuito", "region": "Puno", "country": "PE" },
{ "name": "El Collao", "region": "Puno", "country": "PE" },
{ "name": "Huancan", "region": "Puno", "country": "PE" },
{ "name": "Lampa", "region": "Puno", "country": "PE" },
{ "name": "Melgar", "region": "Puno", "country": "PE" },
{ "name": "Moho", "region": "Puno", "country": "PE" },
{ "name": "San Antonio de Putina", "region": "Puno", "country": "PE" },
{ "name": "San Romn", "region": "Puno", "country": "PE" },
{ "name": "Sandia", "region": "Puno", "country": "PE" },
{ "name": "Yunguyo", "region": "Puno", "country": "PE" },
{ "name": "Moyobamba", "region": "San Martn", "country": "PE" },
{ "name": "Bellavista", "region": "San Martn", "country": "PE" },
{ "name": "El Dorado", "region": "San Martn", "country": "PE" },
{ "name": "Huallaga", "region": "San Martn", "country": "PE" },
{ "name": "Lamas", "region": "San Martn", "country": "PE" },
{ "name": "Mariscal Cceres", "region": "San Martn", "country": "PE" },
{ "name": "Picota", "region": "San Martn", "country": "PE" },
{ "name": "Rioja", "region": "San Martn", "country": "PE" },
{ "name": "San Martn", "region": "San Martn", "country": "PE" },
{ "name": "Tocache", "region": "San Martn", "country": "PE" },
{ "name": "Tacna", "region": "Tacna", "country": "PE" },
{ "name": "Candarave", "region": "Tacna", "country": "PE" },
{ "name": "Jorge Basadre", "region": "Tacna", "country": "PE" },
{ "name": "Tarata", "region": "Tacna", "country": "PE" },
{ "name": "Tumbes", "region": "Tumbes", "country": "PE" },
{ "name": "Contralmirante Villar", "region": "Tumbes", "country": "PE" },
{ "name": "Zarumilla", "region": "Tumbes", "country": "PE" },
{ "name": "Coronel Portillo", "region": "Ucayali", "country": "PE" },
{ "name": "Atalaya", "region": "Ucayali", "country": "PE" },
{ "name": "Padre Abad", "region": "Ucayali", "country": "PE" },
{ "name": "Purs", "region": "Ucayali", "country": "PE" },

{ "name": "Camagey", "country": "CU" },
{ "name": "Ciego de vila", "country": "CU" },
{ "name": "Cienfuegos", "country": "CU" },
{ "name": "Havana", "country": "CU" },
{ "name": "Bayamo", "country": "CU" },
{ "name": "Guantnamo", "country": "CU" },
{ "name": "Holgun", "country": "CU" },
{ "name": "Nueva Gerona", "country": "CU" },
{ "name": "Artemisa", "country": "CU" },
{ "name": "Las Tunas", "country": "CU" },
{ "name": "Matanzas", "country": "CU" },
{ "name": "San Jos de las Lajas", "country": "CU" },
{ "name": "Pinar del Ro", "country": "CU" },
{ "name": "Sancti Spritus", "country": "CU" },
{ "name": "Santiago de Cuba", "country": "CU" },
{ "name": "Santa Clara", "country": "CU" },

{ "name": "Ciudad Autnoma de Buenos Aires", "country": "AR" },
{ "name": "Buenos Aires", "country": "AR" },
{ "name": "Catamarca", "country": "AR" },
{ "name": "Chaco", "country": "AR" },
{ "name": "Chubut", "country": "AR" },
{ "name": "Crdoba", "country": "AR" },
{ "name": "Corrientes", "country": "AR" },
{ "name": "Entre Ros", "country": "AR" },
{ "name": "Formosa", "country": "AR" },
{ "name": "Jujuy", "country": "AR" },
{ "name": "La Pampa", "country": "AR" },
{ "name": "La Rioja", "country": "AR" },
{ "name": "Mendoza", "country": "AR" },
{ "name": "Misiones", "country": "AR" },
{ "name": "Neuqun", "country": "AR" },
{ "name": "Ro Negro", "country": "AR" },
{ "name": "Salta", "country": "AR" },
{ "name": "San Juan", "country": "AR" },
{ "name": "San Luis", "country": "AR" },
{ "name": "Santa Cruz", "country": "AR" },
{ "name": "Santa Fe", "country": "AR" },
{ "name": "Santiago del Estero", "country": "AR" },
{ "name": "Tierra del Fuego, Antrtida e Islas del Atlntico Sur", "country": "AR" },
{ "name": "Tucumn", "country": "AR" },

{ "name": "Arica", "region": "XV Arica and Parinacota", "country": "CL" },
{ "name": "Parinacota", "region": "XV Arica and Parinacota", "country": "CL" },
{ "name": "Iquique", "region": "I Tarapac", "country": "CL" },
{ "name": "Tamarugal", "region": "I Tarapac", "country": "CL" },
{ "name": "Antofagasta", "region": "II Antofagasta", "country": "CL" },
{ "name": "El Loa", "region": "II Antofagasta", "country": "CL" },
{ "name": "Tocopilla", "region": "II Antofagasta", "country": "CL" },
{ "name": "Copiap", "region": "III Atacama", "country": "CL" },
{ "name": "Huasco", "region": "III Atacama", "country": "CL" },
{ "name": "Chaaral", "region": "III Atacama", "country": "CL" },
{ "name": "Elqui", "region": "IV Coquimbo", "country": "CL" },
{ "name": "Limar", "region": "IV Coquimbo", "country": "CL" },
{ "name": "Choapa", "region": "IV Coquimbo", "country": "CL" },
{ "name": "Isla de Pascua", "region": "V Valparaso", "country": "CL" },
{ "name": "Los Andes", "region": "V Valparaso", "country": "CL" },
{ "name": "Marga Marga", "region": "V Valparaso", "country": "CL" },
{ "name": "Petorca", "region": "V Valparaso", "country": "CL" },
{ "name": "Quillota", "region": "V Valparaso", "country": "CL" },
{ "name": "San Antonio", "region": "V Valparaso", "country": "CL" },
{ "name": "San Felipe de Aconcagua", "region": "V Valparaso", "country": "CL" },
{ "name": "Valparaso", "region": "V Valparaso", "country": "CL" },
{ "name": "Cachapoal", "region": "VI O'Higgins", "country": "CL" },
{ "name": "Colchagua", "region": "VI O'Higgins", "country": "CL" },
{ "name": "Cardenal Caro", "region": "VI O'Higgins", "country": "CL" },
{ "name": "Talca", "region": "VII Maule", "country": "CL" },
{ "name": "Linares", "region": "VII Maule", "country": "CL" },
{ "name": "Curic", "region": "VII Maule", "country": "CL" },
{ "name": "Cauquenes", "region": "VII Maule", "country": "CL" },
{ "name": "Concepcin", "region": "VIII Biobo", "country": "CL" },
{ "name": "uble", "region": "VIII Biobo", "country": "CL" },
{ "name": "Biobo", "region": "VIII Biobo", "country": "CL" },
{ "name": "Arauco", "region": "VIII Biobo", "country": "CL" },
{ "name": "Cautin", "region": "IX Araucana", "country": "CL" },
{ "name": "Malleco", "region": "IX Araucana", "country": "CL" },
{ "name": "Valdivia", "region": "XIV Los Ros", "country": "CL" },
{ "name": "Ranco", "region": "XIV Los Ros", "country": "CL" },
{ "name": "Llanquihue", "region": "X Los Lagos", "country": "CL" },
{ "name": "Osorno", "region": "X Los Lagos", "country": "CL" },
{ "name": "Chiloe", "region": "X Los Lagos", "country": "CL" },
{ "name": "Palena", "region": "X Los Lagos", "country": "CL" },
{ "name": "Coihaique", "region": "XI Aisn", "country": "CL" },
{ "name": "Aisn", "region": "XI Aisn", "country": "CL" },
{ "name": "General Carrera", "region": "XI Aisn", "country": "CL" },
{ "name": "Capitan Prat", "region": "XI Aisn", "country": "CL" },
{ "name": "Magallanes", "region": "XII Magallanes", "country": "CL" },
{ "name": "Ultima Esperanza", "region": "XII Magallanes", "country": "CL" },
{ "name": "Tierra del Fuego", "region": "XII Magallanes", "country": "CL" },
{ "name": "Antrtica Chilena", "region": "XII Magallanes", "country": "CL" },
{ "name": "Santiago", "region": "RM Santiago Metropolitan", "country": "CL" },
{ "name": "Cordillera", "region": "RM Santiago Metropolitan", "country": "CL" },
{ "name": "Maipo", "region": "RM Santiago Metropolitan", "country": "CL" },
{ "name": "Talagante", "region": "RM Santiago Metropolitan", "country": "CL" },
{ "name": "Melipilla", "region": "RM Santiago Metropolitan", "country": "CL" },
{ "name": "Chacabuco", "region": "RM Santiago Metropolitan", "country": "CL" },

{ "name": "Cercado", "region": "Beni", "country": "BO" },
{ "name": "Itnez", "region": "Beni", "country": "BO" },
{ "name": "Jos Ballivin", "region": "Beni", "country": "BO" },
{ "name": "Mamor", "region": "Beni", "country": "BO" },
{ "name": "Marbn", "region": "Beni", "country": "BO" },
{ "name": "Moxos", "region": "Beni", "country": "BO" },
{ "name": "Vaca Dez", "region": "Beni", "country": "BO" },
{ "name": "Yacuma", "region": "Beni", "country": "BO" },
{ "name": "Azurduy", "region": "Chuquisaca", "country": "BO" },
{ "name": "Belisario Boeto", "region": "Chuquisaca", "country": "BO" },
{ "name": "Hernando Siles", "region": "Chuquisaca", "country": "BO" },
{ "name": "Jaime Zudez", "region": "Chuquisaca", "country": "BO" },
{ "name": "Luis Calvo", "region": "Chuquisaca", "country": "BO" },
{ "name": "Nor Cinti", "region": "Chuquisaca", "country": "BO" },
{ "name": "Oropeza", "region": "Chuquisaca", "country": "BO" },
{ "name": "Sud Cinti", "region": "Chuquisaca", "country": "BO" },
{ "name": "Tomina", "region": "Chuquisaca", "country": "BO" },
{ "name": "Yamparez", "region": "Chuquisaca", "country": "BO" },
{ "name": "Arani", "region": "Cochabamba", "country": "BO" },
{ "name": "Arque", "region": "Cochabamba", "country": "BO" },
{ "name": "Ayopaya", "region": "Cochabamba", "country": "BO" },
{ "name": "Capinota", "region": "Cochabamba", "country": "BO" },
{ "name": "Carrasco", "region": "Cochabamba", "country": "BO" },
{ "name": "Cercado", "region": "Cochabamba", "country": "BO" },
{ "name": "Chapare", "region": "Cochabamba", "country": "BO" },
{ "name": "Esteban Arce", "region": "Cochabamba", "country": "BO" },
{ "name": "Germn Jordn", "region": "Cochabamba", "country": "BO" },
{ "name": "Mizque", "region": "Cochabamba", "country": "BO" },
{ "name": "Campero", "region": "Cochabamba", "country": "BO" },
{ "name": "Punata", "region": "Cochabamba", "country": "BO" },
{ "name": "Quillacollo", "region": "Cochabamba", "country": "BO" },
{ "name": "Bolvar", "region": "Cochabamba", "country": "BO" },
{ "name": "Tapacar", "region": "Cochabamba", "country": "BO" },
{ "name": "Tiraque", "region": "Cochabamba", "country": "BO" },
{ "name": "Abel Iturralde", "region": "La Paz", "country": "BO" },
{ "name": "Aroma", "region": "La Paz", "country": "BO" },
{ "name": "Bautista Saavedra", "region": "La Paz", "country": "BO" },
{ "name": "Caranavi", "region": "La Paz", "country": "BO" },
{ "name": "Eliodoro Camacho", "region": "La Paz", "country": "BO" },
{ "name": "Franz Tamayo", "region": "La Paz", "country": "BO" },
{ "name": "Gualberto Villarroel", "region": "La Paz", "country": "BO" },
{ "name": "Ingavi", "region": "La Paz", "country": "BO" },
{ "name": "Inquisivi", "region": "La Paz", "country": "BO" },
{ "name": "Jos Manuel Pando", "region": "La Paz", "country": "BO" },
{ "name": "Larecaja", "region": "La Paz", "country": "BO" },
{ "name": "Loayza", "region": "La Paz", "country": "BO" },
{ "name": "Los Andes", "region": "La Paz", "country": "BO" },
{ "name": "Manco Kapac", "region": "La Paz", "country": "BO" },
{ "name": "Muecas", "region": "La Paz", "country": "BO" },
{ "name": "Nor Yungas", "region": "La Paz", "country": "BO" },
{ "name": "Omasuyos", "region": "La Paz", "country": "BO" },
{ "name": "Pacajes", "region": "La Paz", "country": "BO" },
{ "name": "Murillo", "region": "La Paz", "country": "BO" },
{ "name": "Sud Yungas", "region": "La Paz", "country": "BO" },
{ "name": "Atahuallpa", "region": "Oruro", "country": "BO" },
{ "name": "Carangas", "region": "Oruro", "country": "BO" },
{ "name": "Cercado", "region": "Oruro", "country": "BO" },
{ "name": "Eduardo Avaroa", "region": "Oruro", "country": "BO" },
{ "name": "Ladislao Cabrera", "region": "Oruro", "country": "BO" },
{ "name": "Litoral", "region": "Oruro", "country": "BO" },
{ "name": "Nor Carangas", "region": "Oruro", "country": "BO" },
{ "name": "Pantalon Dalence", "region": "Oruro", "country": "BO" },
{ "name": "Poop", "region": "Oruro", "country": "BO" },
{ "name": "Puerto de Mejillones", "region": "Oruro", "country": "BO" },
{ "name": "Sajama", "region": "Oruro", "country": "BO" },
{ "name": "San Pedro de Totora", "region": "Oruro", "country": "BO" },
{ "name": "Saucar", "region": "Oruro", "country": "BO" },
{ "name": "Sebastin Pagador", "region": "Oruro", "country": "BO" },
{ "name": "Sud Carangas", "region": "Oruro", "country": "BO" },
{ "name": "Tomas Barrn", "region": "Oruro", "country": "BO" },
{ "name": "Abun", "region": "Pando", "country": "BO" },
{ "name": "Federico Romn", "region": "Pando", "country": "BO" },
{ "name": "Madre de Dios", "region": "Pando", "country": "BO" },
{ "name": "Manuripi", "region": "Pando", "country": "BO" },
{ "name": "Nicols Surez", "region": "Pando", "country": "BO" },
{ "name": "Alonso de Ibez", "region": "Potos", "country": "BO" },
{ "name": "Antonio Quijarro", "region": "Potos", "country": "BO" },
{ "name": "Bernardino Bilbao", "region": "Potos", "country": "BO" },
{ "name": "Charcas", "region": "Potos", "country": "BO" },
{ "name": "Chayanta", "region": "Potos", "country": "BO" },
{ "name": "Cornelio Saavedra", "region": "Potos", "country": "BO" },
{ "name": "Daniel Campos", "region": "Potos", "country": "BO" },
{ "name": "Enrique Baldivieso", "region": "Potos", "country": "BO" },
{ "name": "Jos Mara Linares", "region": "Potos", "country": "BO" },
{ "name": "Modesto Omiste", "region": "Potos", "country": "BO" },
{ "name": "Nor Chichas", "region": "Potos", "country": "BO" },
{ "name": "Nor Lpez", "region": "Potos", "country": "BO" },
{ "name": "Rafael Bustillo", "region": "Potos", "country": "BO" },
{ "name": "Sur Chichas", "region": "Potos", "country": "BO" },
{ "name": "Sur Lpez", "region": "Potos", "country": "BO" },
{ "name": "Toms Fras", "region": "Potos", "country": "BO" },
{ "name": "Andrs Ibez", "region": "Santa Cruz", "country": "BO" },
{ "name": "ngel Sandoval", "region": "Santa Cruz", "country": "BO" },
{ "name": "Chiquitos", "region": "Santa Cruz", "country": "BO" },
{ "name": "Cordillera", "region": "Santa Cruz", "country": "BO" },
{ "name": "Florida", "region": "Santa Cruz", "country": "BO" },
{ "name": "Germn Busch", "region": "Santa Cruz", "country": "BO" },
{ "name": "Guarayos", "region": "Santa Cruz", "country": "BO" },
{ "name": "Ichilo", "region": "Santa Cruz", "country": "BO" },
{ "name": "Ignacio Warnes", "region": "Santa Cruz", "country": "BO" },
{ "name": "Jos Miguel de Velasco", "region": "Santa Cruz", "country": "BO" },
{ "name": "Manuel Mara Caballero", "region": "Santa Cruz", "country": "BO" },
{ "name": "uflo de Chvez", "region": "Santa Cruz", "country": "BO" },
{ "name": "Obispo Santistevan", "region": "Santa Cruz", "country": "BO" },
{ "name": "Sara", "region": "Santa Cruz", "country": "BO" },
{ "name": "Vallegrande", "region": "Santa Cruz", "country": "BO" },
{ "name": "Aniceto Arce", "region": "Tarija", "country": "BO" },
{ "name": "Burnet O'Connor", "region": "Tarija", "country": "BO" },
{ "name": "Cercado", "region": "Tarija", "country": "BO" },
{ "name": "Eustaquio Mndez", "region": "Tarija", "country": "BO" },
{ "name": "Gran Chaco", "region": "Tarija", "country": "BO" },
{ "name": "Jos Mara Avils", "region": "Tarija", "country": "BO" },

{ "name": "La Corua", "short": "C", "country": "ES" },
{ "name": "Lugo", "short": "LU", "country": "ES" },
{ "name": "Vizcaya", "short": "BI", "country": "ES" },
{ "name": "Guipzcoa", "short": "SS", "country": "ES" },
{ "name": "Huesca", "short": "HU", "country": "ES" },
{ "name": "Lrida", "short": "L", "country": "ES" },
{ "name": "Gerona", "short": "GI", "country": "ES" },
{ "name": "Barcelona", "short": "B", "country": "ES" },
{ "name": "Tarragona", "short": "T", "country": "ES" },
{ "name": "Castelln", "short": "CS", "country": "ES" },
{ "name": "Valencia", "short": "V", "country": "ES" },
{ "name": "Alicante", "short": "A", "country": "ES" },
{ "name": "Murcia", "short": "MU", "country": "ES" },
{ "name": "Zaragoza", "short": "Z", "country": "ES" },
{ "name": "Teruel", "short": "TE", "country": "ES" },
{ "name": "Cuenca", "short": "CU", "country": "ES" },
{ "name": "Albacete", "short": "AB", "country": "ES" },
{ "name": "Almeria", "short": "AL", "country": "ES" },
{ "name": "Granada", "short": "GR", "country": "ES" },
{ "name": "Mlaga", "short": "MA", "country": "ES" },
{ "name": "Tenerife", "short": "TF", "country": "ES" },
{ "name": "Cdiz", "short": "CA", "country": "ES" },
{ "name": "Sevilla", "short": "SE", "country": "ES" },
{ "name": "Huelva", "short": "H", "country": "ES" },
{ "name": "Las Palmas", "short": "GC", "country": "ES" },
{ "name": "Madrid", "short": "M", "country": "ES" },
{ "name": "Badajoz", "short": "BA", "country": "ES" },
{ "name": "Cceres", "short": "CC", "country": "ES" },
{ "name": "Toledo", "short": "TO", "country": "ES" },
{ "name": "Ciudad Real", "short": "CR", "country": "ES" },
{ "name": "Salamanca", "short": "SA", "country": "ES" },
{ "name": "Crdoba", "short": "CO", "country": "ES" },
{ "name": "Jan", "short": "J", "country": "ES" },
{ "name": "vila", "short": "AV", "country": "ES" },
{ "name": "Valladolid", "short": "VA", "country": "ES" },
{ "name": "Zamora", "short": "ZA", "country": "ES" },
{ "name": "lava", "short": "VI", "country": "ES" },
{ "name": "Segovia", "short": "SG", "country": "ES" },
{ "name": "Burgos", "short": "BU", "country": "ES" },
{ "name": "Pontevedra", "short": "PO", "country": "ES" },
{ "name": "Len", "short": "LE", "country": "ES" },
{ "name": "Orense", "short": "OU", "country": "ES" },
{ "name": "Palencia", "short": "P", "country": "ES" },
{ "name": "La Rioja", "short": "LO", "country": "ES" },
{ "name": "Soria", "short": "SO", "country": "ES" },
{ "name": "Guadalajara", "short": "GU", "country": "ES" },

{ "name": "", "english": "Barguna", "region": "Barisal", "country": "BD" },
{ "name": "", "english": "Barisal", "region": "Barisal", "country": "BD" },
{ "name": "", "english": "Bhola", "region": "Barisal", "country": "BD" },
{ "name": "", "english": "Jhalokati", "region": "Barisal", "country": "BD" },
{ "name": "", "english": "Patuakhali", "region": "Barisal", "country": "BD" },
{ "name": "", "english": "Pirojpur", "region": "Barisal", "country": "BD" },
{ "name": "", "english": "Bandarban", "region": "Chittagong", "country": "BD" },
{ "name": "", "english": "Brahmanbaria", "region": "Chittagong", "country": "BD" },
{ "name": "", "english": "Chandpur", "region": "Chittagong", "country": "BD" },
{ "name": "", "english": "Chittagong", "region": "Chittagong", "country": "BD" },
{ "name": "", "english": "Comilla", "region": "Chittagong", "country": "BD" },
{ "name": "", "english": "Cox's Bazar", "region": "Chittagong", "country": "BD" },
{ "name": "", "english": "Feni", "region": "Chittagong", "country": "BD" },
{ "name": "", "english": "Khagrachhari", "region": "Chittagong", "country": "BD" },
{ "name": "", "english": "Lakshmipur", "region": "Chittagong", "country": "BD" },
{ "name": "", "english": "Noakhali", "region": "Chittagong", "country": "BD" },
{ "name": "", "english": "Rangamati", "region": "Chittagong", "country": "BD" },
{ "name": "", "english": "Dhaka", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Faridpur", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Gazipur", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Gopalganj", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Jamalpur", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Kishoreganj", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Madaripur", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Manikganj", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Munshiganj", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Mymensingh", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Narayanganj", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Narsingdi", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Netrakona", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Rajbari", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Shariatpur", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Sherpur", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Tangail", "region": "Dhaka", "country": "BD" },
{ "name": "", "english": "Bagerhat", "region": "Khulna", "country": "BD" },
{ "name": "", "english": "Chuadanga", "region": "Khulna", "country": "BD" },
{ "name": "", "english": "Jessore", "region": "Khulna", "country": "BD" },
{ "name": "", "english": "Jhenaidah", "region": "Khulna", "country": "BD" },
{ "name": "", "english": "Khulna", "region": "Khulna", "country": "BD" },
{ "name": "", "english": "Kushtia", "region": "Khulna", "country": "BD" },
{ "name": "", "english": "Magura", "region": "Khulna", "country": "BD" },
{ "name": "", "english": "Meherpur", "region": "Khulna", "country": "BD" },
{ "name": "", "english": "Narail", "region": "Khulna", "country": "BD" },
{ "name": "", "english": "Satkhira", "region": "Khulna", "country": "BD" },
{ "name": "", "english": "Bogra", "region": "Rajshahi", "country": "BD" },
{ "name": "", "english": "Joypurhat", "region": "Rajshahi", "country": "BD" },
{ "name": "", "english": "Naogaon", "region": "Rajshahi", "country": "BD" },
{ "name": "", "english": "Natore", "region": "Rajshahi", "country": "BD" },
{ "name": "", "english": "Chapainawabganj", "region": "Rajshahi", "country": "BD" },
{ "name": "", "english": "Pabna", "region": "Rajshahi", "country": "BD" },
{ "name": "", "english": "Rajshahi", "region": "Rajshahi", "country": "BD" },
{ "name": "", "english": "Sirajganj", "region": "Rajshahi", "country": "BD" },
{ "name": "", "english": "Dinajpur", "region": "Rangpur", "country": "BD" },
{ "name": "", "english": "Gaibandha", "region": "Rangpur", "country": "BD" },
{ "name": "", "english": "Kurigram", "region": "Rangpur", "country": "BD" },
{ "name": "", "english": "Lalmonirhat", "region": "Rangpur", "country": "BD" },
{ "name": "", "english": "Nilphamari", "region": "Rangpur", "country": "BD" },
{ "name": "", "english": "Panchagarh", "region": "Rangpur", "country": "BD" },
{ "name": "", "english": "Rangpur", "region": "Rangpur", "country": "BD" },
{ "name": "", "english": "Thakurgaon", "region": "Rangpur", "country": "BD" },
{ "name": "", "english": "Habiganj", "region": "Sylhet", "country": "BD" },
{ "name": "", "english": "Moulvibazar", "region": "Sylhet", "country": "BD" },
{ "name": "", "english": "Sunamganj", "region": "Sylhet", "country": "BD" },
{ "name": "", "english": "Sylhet", "region": "Sylhet", "country": "BD" },

{ "name": "Azad Kashmir", "country": "PK" },
{ "name": "Bahawalpur", "country": "PK" },
{ "name": "Bannu", "country": "PK" },
{ "name": "Dera Ghazi Khan", "country": "PK" },
{ "name": "Dera Ismail Khan", "country": "PK" },
{ "name": "Faisalabad", "country": "PK" },
{ "name": "F.A.T.A.", "country": "PK" },
{ "name": "Gujranwala", "country": "PK" },
{ "name": "Hazara", "country": "PK" },
{ "name": "Hyderabad", "country": "PK" },
{ "name": "Islamabad", "country": "PK" },
{ "name": "Kalat", "country": "PK" },
{ "name": "Karachi", "country": "PK" },
{ "name": "Kohat", "country": "PK" },
{ "name": "Lahore", "country": "PK" },
{ "name": "Larkana", "country": "PK" },
{ "name": "Makran", "country": "PK" },
{ "name": "Malakand", "country": "PK" },
{ "name": "Mardan", "country": "PK" },
{ "name": "Mirpur Khas", "country": "PK" },
{ "name": "Multan", "country": "PK" },
{ "name": "Nasirabad", "country": "PK" },
{ "name": "Northern Areas", "country": "PK" },
{ "name": "Peshawar", "country": "PK" },
{ "name": "Quetta", "country": "PK" },
{ "name": "Rawalpindi", "country": "PK" },
{ "name": "Sargodha", "country": "PK" },
{ "name": "Sahiwal", "country": "PK" },
{ "name": "Sibi", "country": "PK" },
{ "name": "Sukkur", "country": "PK" },
{ "name": "Zhob", "country": "PK" },

{ "short": "AB", "name": "Abia", "country": "NG" },
{ "short": "FC", "name": "Abuja", "country": "NG" },
{ "short": "AD", "name": "Adamawa", "country": "NG" },
{ "short": "AK", "name": "Akwa Ibom", "country": "NG" },
{ "short": "AN", "name": "Anambra", "country": "NG" },
{ "short": "BA", "name": "Bauchi", "country": "NG" },
{ "short": "BY", "name": "Bayelsa", "country": "NG" },
{ "short": "BE", "name": "Benue", "country": "NG" },
{ "short": "BO", "name": "Borno", "country": "NG" },
{ "short": "CR", "name": "Cross River", "country": "NG" },
{ "short": "DE", "name": "Delta", "country": "NG" },
{ "short": "EB", "name": "Ebonyi", "country": "NG" },
{ "short": "ED", "name": "Edo", "country": "NG" },
{ "short": "EK", "name": "Ekiti", "country": "NG" },
{ "short": "EN", "name": "Enugu", "country": "NG" },
{ "short": "GO", "name": "Gombe", "country": "NG" },
{ "short": "IM", "name": "Imo", "country": "NG" },
{ "short": "JI", "name": "Jigawa", "country": "NG" },
{ "short": "KD", "name": "Kaduna", "country": "NG" },
{ "short": "KN", "name": "Kano", "country": "NG" },
{ "short": "KT", "name": "Katsina", "country": "NG" },
{ "short": "KE", "name": "Kebbi", "country": "NG" },
{ "short": "KO", "name": "Kogi", "country": "NG" },
{ "short": "KW", "name": "Kwara", "country": "NG" },
{ "short": "LA", "name": "Lagos", "country": "NG" },
{ "short": "NA", "name": "Nasarawa", "country": "NG" },
{ "short": "NI", "name": "Niger", "country": "NG" },
{ "short": "OG", "name": "Ogun", "country": "NG" },
{ "short": "ON", "name": "Ondo", "country": "NG" },
{ "short": "OS", "name": "Osun", "country": "NG" },
{ "short": "OY", "name": "Oyo", "country": "NG" },
{ "short": "PL", "name": "Plateau", "country": "NG" },
{ "short": "RI", "name": "Rivers", "country": "NG" },
{ "short": "SO", "name": "Sokoto", "country": "NG" },
{ "short": "TA", "name": "Taraba", "country": "NG" },
{ "short": "YO", "name": "Yobe", "country": "NG" },
{ "short": "ZA", "name": "Zamfara", "country": "NG" },

{ "name": "", "english": "Aichi", "country": "JP" },
{ "name": "", "english": "Akita", "country": "JP" },
{ "name": "", "english": "Aomori", "country": "JP" },
{ "name": "", "english": "Chiba", "country": "JP" },
{ "name": "", "english": "Ehime", "country": "JP" },
{ "name": "", "english": "Fukui", "country": "JP" },
{ "name": "", "english": "Fukuoka", "country": "JP" },
{ "name": "", "english": "Fukushima", "country": "JP" },
{ "name": "", "english": "Gifu", "country": "JP" },
{ "name": "", "english": "Gunma", "country": "JP" },
{ "name": "", "english": "Hiroshima", "country": "JP" },
{ "name": "", "english": "Hokkaid", "country": "JP" },
{ "name": "", "english": "Hygo", "country": "JP" },
{ "name": "", "english": "Ibaraki", "country": "JP" },
{ "name": "", "english": "Ishikawa", "country": "JP" },
{ "name": "", "english": "Iwate", "country": "JP" },
{ "name": "", "english": "Kagawa", "country": "JP" },
{ "name": "", "english": "Kagoshima", "country": "JP" },
{ "name": "", "english": "Kanagawa", "country": "JP" },
{ "name": "", "english": "Kchi", "country": "JP" },
{ "name": "", "english": "Kumamoto", "country": "JP" },
{ "name": "", "english": "Kyto", "country": "JP" },
{ "name": "", "english": "Mie", "country": "JP" },
{ "name": "", "english": "Miyagi", "country": "JP" },
{ "name": "", "english": "Miyazaki", "country": "JP" },
{ "name": "", "english": "Nagano", "country": "JP" },
{ "name": "", "english": "Nagasaki", "country": "JP" },
{ "name": "", "english": "Nara", "country": "JP" },
{ "name": "", "english": "Niigata", "country": "JP" },
{ "name": "", "english": "ita", "country": "JP" },
{ "name": "", "english": "Okayama", "country": "JP" },
{ "name": "", "english": "Okinawa", "country": "JP" },
{ "name": "", "english": "saka", "country": "JP" },
{ "name": "", "english": "Saga", "country": "JP" },
{ "name": "", "english": "Saitama", "country": "JP" },
{ "name": "", "english": "Shiga", "country": "JP" },
{ "name": "", "english": "Shimane", "country": "JP" },
{ "name": "", "english": "Shizuoka", "country": "JP" },
{ "name": "", "english": "Tochigi", "country": "JP" },
{ "name": "", "english": "Tokushima", "country": "JP" },
{ "name": "", "english": "Tky", "country": "JP" },
{ "name": "", "english": "Tottori", "country": "JP" },
{ "name": "", "english": "Toyama", "country": "JP" },
{ "name": "", "english": "Wakayama", "country": "JP" },
{ "name": "", "english": "Yamagata", "country": "JP" },
{ "name": "", "english": "Yamaguchi", "country": "JP" },
{ "name": "", "english": "Yamanashi", "country": "JP" },

{"short":"B","name":"Burgenland","country":"AT"},
{"short":"K","name":"Krnten","country":"AT"},
{"short":"N","name":"Niedersterreich","country":"AT"},
{"short":"O","name":"Obersterreich","country":"AT"},
{"short":"S","name":"Salzburg","country":"AT"},
{"short":"ST","name":"Steiermark","country":"AT"},
{"short":"T","name":"Tirol","country":"AT"},
{"short":"V","name":"Vorarlberg","country":"AT"},
{"short":"W","name":"Wien","country":"AT"},

{"short":"AC","name":"Acre","country":"BR"},
{"short":"AL","name":"Alagoas","country":"BR"},
{"short":"AP","name":"Amap","country":"BR"},
{"short":"AM","name":"Amazonas","country":"BR"},
{"short":"BA","name":"Bahia","country":"BR"},
{"short":"CE","name":"Cear","country":"BR"},
{"short":"DF","name":"Distrito Federal","country":"BR"},
{"short":"ES","name":"Esprito Santo","country":"BR"},
{"short":"GO","name":"Gois","country":"BR"},
{"short":"MA","name":"Maranho","country":"BR"},
{"short":"MT","name":"Mato Grosso","country":"BR"},
{"short":"MS","name":"Mato Grosso do Sul","country":"BR"},
{"short":"MG","name":"Minas Gerais","country":"BR"},
{"short":"PA","name":"Par","country":"BR"},
{"short":"PB","name":"Paraba","country":"BR"},
{"short":"PR","name":"Paran","country":"BR"},
{"short":"PE","name":"Pernambuco","country":"BR"},
{"short":"PI","name":"Piau","country":"BR"},
{"short":"RJ","name":"Rio de Janeiro","country":"BR"},
{"short":"RN","name":"Rio Grande do Norte","country":"BR"},
{"short":"RS","name":"Rio Grande do Sul","country":"BR"},
{"short":"RO","name":"Rondnia","country":"BR"},
{"short":"RR","name":"Roraima","country":"BR"},
{"short":"SC","name":"Santa Catarina","country":"BR"},
{"short":"SP","name":"So Paulo","country":"BR"},
{"short":"SE","name":"Sergipe","country":"BR"},
{"short":"TO","name":"Tocantins","country":"BR"},

{ "name": "Abra", "country": "PH" },
{ "name": "Agusan del Norte", "country": "PH" },
{ "name": "Agusan del Sur", "country": "PH" },
{ "name": "Aklan", "country": "PH" },
{ "name": "Albay", "country": "PH" },
{ "name": "Antique", "country": "PH" },
{ "name": "Apayao", "country": "PH" },
{ "name": "Aurora", "country": "PH" },
{ "name": "Basilan", "country": "PH" },
{ "name": "Bataan", "country": "PH" },
{ "name": "Batanes", "country": "PH" },
{ "name": "Batangas", "country": "PH" },
{ "name": "Benguet", "country": "PH" },
{ "name": "Biliran", "country": "PH" },
{ "name": "Bohol", "country": "PH" },
{ "name": "Bukidnon", "country": "PH" },
{ "name": "Bulacan", "country": "PH" },
{ "name": "Cagayan", "country": "PH" },
{ "name": "Camarines Norte", "country": "PH" },
{ "name": "Camarines Sur", "country": "PH" },
{ "name": "Camiguin", "country": "PH" },
{ "name": "Capiz", "country": "PH" },
{ "name": "Catanduanes", "country": "PH" },
{ "name": "Cavite", "country": "PH" },
{ "name": "Cebu", "country": "PH" },
{ "name": "Compostela Valley", "country": "PH" },
{ "name": "Cotabato", "country": "PH" },
{ "name": "Davao del Norte", "country": "PH" },
{ "name": "Davao del Sur", "country": "PH" },
{ "name": "Davao Occidental", "country": "PH" },
{ "name": "Davao Oriental", "country": "PH" },
{ "name": "Dinagat Islands", "country": "PH" },
{ "name": "Eastern Samar", "country": "PH" },
{ "name": "Guimaras", "country": "PH" },
{ "name": "Ifugao", "country": "PH" },
{ "name": "Ilocos Norte", "country": "PH" },
{ "name": "Ilocos Sur", "country": "PH" },
{ "name": "Iloilo", "country": "PH" },
{ "name": "Isabela", "country": "PH" },
{ "name": "Kalinga", "country": "PH" },
{ "name": "La Union", "country": "PH" },
{ "name": "Laguna", "country": "PH" },
{ "name": "Lanao del Norte", "country": "PH" },
{ "name": "Lanao del Sur", "country": "PH" },
{ "name": "Leyte", "country": "PH" },
{ "name": "Maguindanao", "country": "PH" },
{ "name": "Marinduque", "country": "PH" },
{ "name": "Masbate", "country": "PH" },
{ "name": "Misamis Occidental", "country": "PH" },
{ "name": "Misamis Oriental", "country": "PH" },
{ "name": "Mountain Province", "country": "PH" },
{ "name": "Negros Occidental", "country": "PH" },
{ "name": "Negros Oriental", "country": "PH" },
{ "name": "Northern Samar", "country": "PH" },
{ "name": "Nueva Ecija", "country": "PH" },
{ "name": "Nueva Vizcaya", "country": "PH" },
{ "name": "Occidental Mindoro", "country": "PH" },
{ "name": "Oriental Mindoro", "country": "PH" },
{ "name": "Palawan", "country": "PH" },
{ "name": "Pampanga", "country": "PH" },
{ "name": "Pangasinan", "country": "PH" },
{ "name": "Quezon", "country": "PH" },
{ "name": "Quirino", "country": "PH" },
{ "name": "Rizal", "country": "PH" },
{ "name": "Romblon", "country": "PH" },
{ "name": "Samar", "country": "PH" },
{ "name": "Sarangani", "country": "PH" },
{ "name": "Siquijor", "country": "PH" },
{ "name": "Sorsogon", "country": "PH" },
{ "name": "South Cotabato", "country": "PH" },
{ "name": "Southern Leyte", "country": "PH" },
{ "name": "Sultan Kudarat", "country": "PH" },
{ "name": "Sulu", "country": "PH" },
{ "name": "Surigao del Norte", "country": "PH" },
{ "name": "Surigao del Sur", "country": "PH" },
{ "name": "Tarlac", "country": "PH" },
{ "name": "Tawi-Tawi", "country": "PH" },
{ "name": "Zambales", "country": "PH" },
{ "name": "Zamboanga del Norte", "country": "PH" },
{ "name": "Zamboanga del Sur", "country": "PH" },
{ "name": "Zamboanga Sibugay", "country": "PH" },
{ "name": "Metro Manila", "country": "PH" },

{ "name": "H Ni", "country": "VN" },
{ "name": "H Giang", "country": "VN" },
{ "name": "Cao Bng", "country": "VN" },
{ "name": "Bc Kn", "country": "VN" },
{ "name": "Tuyn Quang", "country": "VN" },
{ "name": "Lo Cai", "country": "VN" },
{ "name": "in Bin", "country": "VN" },
{ "name": "Lai Chu", "country": "VN" },
{ "name": "Sn La", "country": "VN" },
{ "name": "Yn Bi", "country": "VN" },
{ "name": "Ha Bnh", "country": "VN" },
{ "name": "Thi Nguyn", "country": "VN" },
{ "name": "Lng Sn", "country": "VN" },
{ "name": "Qung Ninh", "country": "VN" },
{ "name": "Bc Giang", "country": "VN" },
{ "name": "Ph Th", "country": "VN" },
{ "name": "Vnh Phc", "country": "VN" },
{ "name": "Bc Ninh", "country": "VN" },
{ "name": "Hi Dng", "country": "VN" },
{ "name": "Hi Phng", "country": "VN" },
{ "name": "Hng Yn", "country": "VN" },
{ "name": "Thi Bnh", "country": "VN" },
{ "name": "H Nam", "country": "VN" },
{ "name": "Nam nh", "country": "VN" },
{ "name": "Ninh Bnh", "country": "VN" },
{ "name": "Thanh Ha", "country": "VN" },
{ "name": "Ngh An", "country": "VN" },
{ "name": "H Tnh", "country": "VN" },
{ "name": "Qung Bnh", "country": "VN" },
{ "name": "Qung Tr", "country": "VN" },
{ "name": "Tha ThinHu", "country": "VN" },
{ "name": " Nng", "country": "VN" },
{ "name": "Qung Nam", "country": "VN" },
{ "name": "Qung Ngi", "country": "VN" },
{ "name": "Bnh nh", "country": "VN" },
{ "name": "Ph Yn", "country": "VN" },
{ "name": "Khnh Ha", "country": "VN" },
{ "name": "Ninh Thun", "country": "VN" },
{ "name": "Bnh Thun", "country": "VN" },
{ "name": "Kon Tum", "country": "VN" },
{ "name": "Gia Lai", "country": "VN" },
{ "name": "k Lk", "country": "VN" },
{ "name": "k Nng", "country": "VN" },
{ "name": "Lm ng", "country": "VN" },
{ "name": "Bnh Phc", "country": "VN" },
{ "name": "Ty Ninh", "country": "VN" },
{ "name": "Bnh Dng", "country": "VN" },
{ "name": "ng Nai", "country": "VN" },
{ "name": "B RaVng Tu", "country": "VN" },
{ "name": "Thnh ph H Ch Minh", "country": "VN" },
{ "name": "Long An", "country": "VN" },
{ "name": "Tin Giang", "country": "VN" },
{ "name": "Bn Tre", "country": "VN" },
{ "name": "Tr Vinh", "country": "VN" },
{ "name": "Vnh Long", "country": "VN" },
{ "name": "ng Thp", "country": "VN" },
{ "name": "An Giang", "country": "VN" },
{ "name": "Kin Giang", "country": "VN" },
{ "name": "Cn Th", "country": "VN" },
{ "name": "Hu Giang", "country": "VN" },
{ "name": "Sc Trng", "country": "VN" },
{ "name": "Bc Liu", "country": "VN" },
{ "name": "C Mau", "country": "VN" },

{ "name": "San Jos", "country": "CR" },
{ "name": "Alajuela", "country": "CR" },
{ "name": "Cartago", "country": "CR" },
{ "name": "Heredia", "country": "CR" },
{ "name": "Guanacaste", "country": "CR" },
{ "name": "Puntarenas", "country": "CR" },
{ "name": "Limn", "country": "CR" },

{ "name": "Auckland", "country": "NZ" },
{ "name": "New Plymouth", "country": "NZ" },
{ "name": "Hawke's Bay", "country": "NZ" },
{ "name": "Wellington", "country": "NZ" },
{ "name": "Nelson", "country": "NZ" },
{ "name": "Marlborough", "country": "NZ" },
{ "name": "Westland", "country": "NZ" },
{ "name": "Canterbury", "country": "NZ" },
{ "name": "Otago", "country": "NZ" },
{ "name": "Southland", "country": "NZ" }
]}, {}];
window.modules["1125"] = [function(require,module,exports){var createHash = require(306)
var Buffer = require(275).Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}
}, {"275":275,"306":306}];
window.modules["1123"] = [function(require,module,exports){var parseKeys = require(311)
var mgf = require(1125)
var xor = require(1126)
var BN = require(252)
var crt = require(299)
var createHash = require(306)
var withPublic = require(1127)
var Buffer = require(275).Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}
}, {"252":252,"275":275,"299":299,"306":306,"311":311,"1125":1125,"1126":1126,"1127":1127}];
window.modules["1124"] = [function(require,module,exports){var parseKeys = require(311)
var randomBytes = require(300)
var createHash = require(306)
var mgf = require(1125)
var xor = require(1126)
var BN = require(252)
var withPublic = require(1127)
var crt = require(299)
var Buffer = require(275).Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}
}, {"252":252,"275":275,"299":299,"300":300,"306":306,"311":311,"1125":1125,"1126":1126,"1127":1127}];
window.modules["1143"] = [function(require,module,exports){module.exports = require(1144).PassThrough
}, {"1144":1144}];
window.modules["1161"] = [function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require(1157);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;
}, {"1157":1157}];
window.modules["1173"] = [function(require,module,exports){// memoryStorage is a useful last fallback to ensure that the store
// is functions (meaning store.get(), store.set(), etc will all function).
// However, stored values will not persist when the browser navigates to
// a new page or reloads the current page.

module.exports = {
	name: 'memoryStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var memoryStorage = {}

function read(key) {
	return memoryStorage[key]
}

function write(key, data) {
	memoryStorage[key] = data
}

function each(callback) {
	for (var key in memoryStorage) {
		if (memoryStorage.hasOwnProperty(key)) {
			callback(memoryStorage[key], key)
		}
	}
}

function remove(key) {
	delete memoryStorage[key]
}

function clearAll(key) {
	memoryStorage = {}
}
}, {}];
window.modules["271"] = [function(require,module,exports){(function (setImmediate,clearImmediate){
var nextTick = require(22).nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require(271).setImmediate,require(271).clearImmediate)}, {"22":22,"271":271}];
window.modules["1185"] = [function(require,module,exports){/**
 * Ensure some object is a coerced to a string
 **/
module.exports = function makeString(object) {
  if (object == null) return '';
  return '' + object;
};
}, {}];
window.modules["1239"] = [function(require,module,exports){var makeString = require(1185);

module.exports = function(str, callback) {
  str = makeString(str);

  if (str.length === 0 || typeof callback !== 'function') return str;

  return str.replace(/./g, callback);
};
}, {"1185":1185}];
window.modules["1212"] = [function(require,module,exports){module.exports = function naturalCmp(str1, str2) {
  if (str1 == str2) return 0;
  if (!str1) return -1;
  if (!str2) return 1;

  var cmpRegex = /(\.\d+|\d+|\D+)/g,
    tokens1 = String(str1).match(cmpRegex),
    tokens2 = String(str2).match(cmpRegex),
    count = Math.min(tokens1.length, tokens2.length);

  for (var i = 0; i < count; i++) {
    var a = tokens1[i],
      b = tokens2[i];

    if (a !== b) {
      var num1 = +a;
      var num2 = +b;
      if (num1 === num1 && num2 === num2) {
        return num1 > num2 ? 1 : -1;
      }
      return a < b ? -1 : 1;
    }
  }

  if (tokens1.length != tokens2.length)
    return tokens1.length - tokens2.length;

  return str1 < str2 ? -1 : 1;
};
}, {}];
window.modules["1209"] = [function(require,module,exports){module.exports = function numberFormat(number, dec, dsep, tsep) {
  if (isNaN(number) || number == null) return '';

  number = number.toFixed(~~dec);
  tsep = typeof tsep == 'string' ? tsep : ',';

  var parts = number.split('.'),
    fnums = parts[0],
    decimals = parts[1] ? (dsep || '.') + parts[1] : '';

  return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + tsep) + decimals;
};
}, {}];
window.modules["1243"] = [function(require,module,exports){var makeString = require(1185);
var strRepeat = require(1203);

module.exports = function pad(str, length, padStr, type) {
  str = makeString(str);
  length = ~~length;

  var padlen = 0;

  if (!padStr)
    padStr = ' ';
  else if (padStr.length > 1)
    padStr = padStr.charAt(0);

  switch (type) {
  case 'right':
    padlen = length - str.length;
    return str + strRepeat(padStr, padlen);
  case 'both':
    padlen = length - str.length;
    return strRepeat(padStr, Math.ceil(padlen / 2)) + str + strRepeat(padStr, Math.floor(padlen / 2));
  default: // 'left'
    padlen = length - str.length;
    return strRepeat(padStr, padlen) + str;
  }
};
}, {"1185":1185,"1203":1203}];
window.modules["1247"] = [function(require,module,exports){var adjacent = require(1199);

module.exports = function succ(str) {
  return adjacent(str, -1);
};
}, {"1199":1199}];
window.modules["1232"] = [function(require,module,exports){/**
 * _s.prune: a more elegant version of truncate
 * prune extra chars, never leaving a half-chopped word.
 * @author github.com/rwz
 */
var makeString = require(1185);
var rtrim = require(1246);

module.exports = function prune(str, length, pruneStr) {
  str = makeString(str);
  length = ~~length;
  pruneStr = pruneStr != null ? String(pruneStr) : '...';

  if (str.length <= length) return str;

  var tmpl = function(c) {
      return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' ';
    },
    template = str.slice(0, length + 1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

  if (template.slice(template.length - 2).match(/\w\w/))
    template = template.replace(/\s*\S+$/, '');
  else
    template = rtrim(template.slice(0, template.length - 1));

  return (template + pruneStr).length > str.length ? str : str.slice(0, template.length) + pruneStr;
};
}, {"1185":1185,"1246":1246}];
window.modules["1255"] = [function(require,module,exports){'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

/*!
 * XRegExp.matchRecursive 4.0.0
 * <xregexp.com>
 * Steven Levithan (c) 2009-2017 MIT License
 */

exports.default = function (XRegExp) {

    /**
     * Returns a match detail object composed of the provided values.
     *
     * @private
     */
    function row(name, value, start, end) {
        return {
            name: name,
            value: value,
            start: start,
            end: end
        };
    }

    /**
     * Returns an array of match strings between outermost left and right delimiters, or an array of
     * objects with detailed match parts and position data. An error is thrown if delimiters are
     * unbalanced within the data.
     *
     * @memberOf XRegExp
     * @param {String} str String to search.
     * @param {String} left Left delimiter as an XRegExp pattern.
     * @param {String} right Right delimiter as an XRegExp pattern.
     * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.
     * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.
     * @returns {Array} Array of matches, or an empty array.
     * @example
     *
     * // Basic usage
     * let str = '(t((e))s)t()(ing)';
     * XRegExp.matchRecursive(str, '\\(', '\\)', 'g');
     * // -> ['t((e))s', '', 'ing']
     *
     * // Extended information mode with valueNames
     * str = 'Here is <div> <div>an</div></div> example';
     * XRegExp.matchRecursive(str, '<div\\s*>', '</div>', 'gi', {
     *   valueNames: ['between', 'left', 'match', 'right']
     * });
     * // -> [
     * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},
     * // {name: 'left',    value: '<div>',          start: 8,  end: 13},
     * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},
     * // {name: 'right',   value: '</div>',         start: 27, end: 33},
     * // {name: 'between', value: ' example',       start: 33, end: 41}
     * // ]
     *
     * // Omitting unneeded parts with null valueNames, and using escapeChar
     * str = '...{1}.\\{{function(x,y){return {y:x}}}';
     * XRegExp.matchRecursive(str, '{', '}', 'g', {
     *   valueNames: ['literal', null, 'value', null],
     *   escapeChar: '\\'
     * });
     * // -> [
     * // {name: 'literal', value: '...',  start: 0, end: 3},
     * // {name: 'value',   value: '1',    start: 4, end: 5},
     * // {name: 'literal', value: '.\\{', start: 6, end: 9},
     * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}
     * // ]
     *
     * // Sticky mode via flag y
     * str = '<1><<<2>>><3>4<5>';
     * XRegExp.matchRecursive(str, '<', '>', 'gy');
     * // -> ['1', '<<2>>', '3']
     */
    XRegExp.matchRecursive = function (str, left, right, flags, options) {
        flags = flags || '';
        options = options || {};
        var global = flags.indexOf('g') !== -1;
        var sticky = flags.indexOf('y') !== -1;
        // Flag `y` is controlled internally
        var basicFlags = flags.replace(/y/g, '');
        var escapeChar = options.escapeChar;
        var vN = options.valueNames;
        var output = [];
        var openTokens = 0;
        var delimStart = 0;
        var delimEnd = 0;
        var lastOuterEnd = 0;
        var outerStart = void 0;
        var innerStart = void 0;
        var leftMatch = void 0;
        var rightMatch = void 0;
        var esc = void 0;
        left = XRegExp(left, basicFlags);
        right = XRegExp(right, basicFlags);

        if (escapeChar) {
            if (escapeChar.length > 1) {
                throw new Error('Cannot use more than one escape character');
            }
            escapeChar = XRegExp.escape(escapeChar);
            // Example of concatenated `esc` regex:
            // `escapeChar`: '%'
            // `left`: '<'
            // `right`: '>'
            // Regex is: /(?:%[\S\s]|(?:(?!<|>)[^%])+)+/
            esc = new RegExp('(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
            // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
            // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
            // transformation resulting from those flags was already applied to `left` and
            // `right` when they were passed through the XRegExp constructor above.
            XRegExp.union([left, right], '', { conjunction: 'or' }).source + ')[^' + escapeChar + '])+)+',
            // Flags `gy` not needed here
            flags.replace(/[^imu]+/g, ''));
        }

        while (true) {
            // If using an escape character, advance to the delimiter's next starting position,
            // skipping any escaped characters in between
            if (escapeChar) {
                delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
            }
            leftMatch = XRegExp.exec(str, left, delimEnd);
            rightMatch = XRegExp.exec(str, right, delimEnd);
            // Keep the leftmost match only
            if (leftMatch && rightMatch) {
                if (leftMatch.index <= rightMatch.index) {
                    rightMatch = null;
                } else {
                    leftMatch = null;
                }
            }
            // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
            // LM | RM | OT | Result
            // 1  | 0  | 1  | loop
            // 1  | 0  | 0  | loop
            // 0  | 1  | 1  | loop
            // 0  | 1  | 0  | throw
            // 0  | 0  | 1  | throw
            // 0  | 0  | 0  | break
            // The paths above don't include the sticky mode special case. The loop ends after the
            // first completed match if not `global`.
            if (leftMatch || rightMatch) {
                delimStart = (leftMatch || rightMatch).index;
                delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
            } else if (!openTokens) {
                break;
            }
            if (sticky && !openTokens && delimStart > lastOuterEnd) {
                break;
            }
            if (leftMatch) {
                if (!openTokens) {
                    outerStart = delimStart;
                    innerStart = delimEnd;
                }
                ++openTokens;
            } else if (rightMatch && openTokens) {
                if (! --openTokens) {
                    if (vN) {
                        if (vN[0] && outerStart > lastOuterEnd) {
                            output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                        }
                        if (vN[1]) {
                            output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                        }
                        if (vN[2]) {
                            output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                        }
                        if (vN[3]) {
                            output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
                        }
                    } else {
                        output.push(str.slice(innerStart, delimStart));
                    }
                    lastOuterEnd = delimEnd;
                    if (!global) {
                        break;
                    }
                }
            } else {
                throw new Error('Unbalanced delimiter found in string');
            }
            // If the delimiter matched an empty string, avoid an infinite loop
            if (delimStart === delimEnd) {
                ++delimEnd;
            }
        }

        if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
            output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
        }

        return output;
    };
};

module.exports = exports['default'];}, {}];
window.modules["169"] = [function(require,module,exports){'use strict';

var dom = require(1),
    _set = require(32),
    _kebabCase = require(70);
/* eslint-disable max-params */


var Newsletter = function Newsletter(form, onSuccess, onError, onReset, cmptName) {
  this.cmptName = cmptName;
  this.form = form;
  this.onSuccess = onSuccess;
  this.onError = onError;
  this.onReset = onReset;
  this.submitBtn = dom.find(this.form, '.submit');
  this.newsletterId = dom.find(this.form, '.newsletter-id').value;
  this.emailField = dom.find(this.form, '.email');
  this.form.addEventListener('submit', this.submit.bind(this));
};
/* eslint-enable */


Newsletter.prototype = {
  submit: function submit(e) {
    var request = new XMLHttpRequest();
    dom.preventDefault(e);
    request.open('POST', this.getRequestUrl(), true);
    request.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
    request.addEventListener('load', this.onRequest.bind(this));
    request.addEventListener('error', this.onError.bind(this));
    request.send(JSON.stringify(this.getPayloadObject()));
    e.preventDefault();
  },
  getRequestUrl: function getRequestUrl() {
    return this.form.getAttribute('action');
  },
  getPageType: function getPageType() {
    var pageMetaElement = dom.find('meta[name="type"]'),
        pageMetaType = pageMetaElement ? pageMetaElement.getAttribute('content') : '';
    return _kebabCase(pageMetaType);
  },
  getPayloadObject: function getPayloadObject() {
    var payloadObject = {}; // Payload object should match:
    // {
    //   "email":  email of user,
    //   "vars": {
    //      "source_<newsletterId>": <component-name>_<page-type>
    //   },
    //   "lists": {
    //     <LIST ID>: true
    //   }
    // }

    payloadObject.email = this.emailField.value;

    _set(payloadObject, "vars.source_".concat(this.newsletterId), "".concat(this.cmptName, "_").concat(this.getPageType()));

    payloadObject.lists = {};
    payloadObject.lists[this.newsletterId] = true;
    return payloadObject;
  },
  reset: function reset() {
    this.form.reset();

    if (this.onReset) {
      this.onReset();
    }
  },
  onRequest: function onRequest(e) {
    var status = (e.currentTarget || e.target).status;
    this.reset();

    if (status >= 200 && status < 300) {
      this.onSuccess();
    } else {
      this.onError(e);
    }
  }
};
module.exports.Newsletter = Newsletter;
}, {"1":1,"32":32,"70":70}];
window.modules["116"] = [function(require,module,exports){'use strict';

var _get = require(32),
    _memoize = require(35);
/**
 * we store some page-level data in a "primary page" component
 * most often this is the article component
 * @returns {Element|null}
 */


function getPrimaryPageComponent() {
  return document.querySelector('.article') || document.querySelector('.lede-video');
}
/**
 * Get content channel
 * @returns {string}
 */


function getPrimaryPageComponentChannel() {
  var el = getPrimaryPageComponent();
  return el && el.getAttribute('data-content-channel') || 'Undefined Channel';
}
/**
 * @returns {string|null} e.g. `nymag.com/scienceofus/_pages/some-id@published`
 */


function getPageUri() {
  return document.documentElement.getAttribute('data-uri');
}
/**
 * @returns {string} e.g. `ciu7g35p10004fvy6m7188nan`
 */


function getPageId() {
  return getPageUri().split('/_pages/')[1];
}
/**
 * @returns {string} e.g. `nymag.com/scienceofus`
 */


function getSiteBase() {
  return (getPageUri() || '').split('/_pages/')[0];
}
/**
 * @param {string} key - meta key to query
 * @returns {string} the content of the tag
 */


function getMetaContent(key) {
  var meta = document.querySelector('meta[name="' + key + '"]') || document.querySelector('meta[property="' + key + '"]');
  return _get(meta, 'content', '');
} // assumes values do not change after page load


module.exports.getMeta = _memoize(getMetaContent);
module.exports.getVertical = module.exports.getMeta.bind(void 0, 'vertical');
module.exports.getPageType = module.exports.getMeta.bind(void 0, 'type');
module.exports.getAuthor = module.exports.getMeta.bind(void 0, 'author');
module.exports.getSiteName = module.exports.getMeta.bind(void 0, 'og:site_name');
module.exports.getSiteBase = _memoize(getSiteBase);
module.exports.getPageUri = _memoize(getPageUri);
module.exports.getPageId = _memoize(getPageId);
module.exports.getChannel = _memoize(getPrimaryPageComponentChannel);
module.exports.getPrimaryPageComponent = getPrimaryPageComponent;
}, {"32":32,"35":35}];
window.modules["40"] = [function(require,module,exports){'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _find = require(71),
    _includes = require(33),
    _get = require(32);

var $window = typeof window !== 'undefined' ? window : undefined;

var service =
/*#__PURE__*/
function () {
  function service() {
    _classCallCheck(this, service);

    var popupService = this;
    this.popupClasses = [// classes we should open the popup for
    // don't open popups for email and print
    // careful of changes b/c these values go into analytics, e.g. $gtm
    'facebook', 'twitter', 'linkedin', 'gplus', 'pinterest', 'tumblr']; // dimensions of our various social media popups

    this.popupDimensions = {
      default: {
        w: 520,
        h: 304
      },
      facebook: {
        w: 520,
        h: 304
      },
      gplus: {
        w: 520,
        h: 485
      },
      linkedin: {
        w: 520,
        h: 450
      },
      pinterest: {
        w: 1015,
        h: 630
      },
      tumblr: {
        w: 520,
        h: 312
      },
      twitter: {
        w: 550,
        h: 572
      }
    };
    /**
     * get supported popup class
     * @param {array} classList
     * @returns {string|undefined}
     */

    this.getPopupClass = function (classList) {
      return _find(popupService.popupClasses, function (supportedClass) {
        return _includes(classList, supportedClass);
      });
    };
    /**
     * returns an object of new window options
     * @param {{ url: String, name: String }} opts - Object containing
     * @param {Object} dimensions - An object of new window options, including dimensions & position
     * @returns {Object}
     */


    this.params = function (opts, dimensions) {
      if (opts.url) {
        this.address = opts.url;
      }

      if (opts.name) {
        this.name = opts.name;
      }

      this.features = 'width=' + (dimensions.w || 0) + ',height=' + (dimensions.h || 0) + ',top=' + (dimensions.top || 0) + ',left=' + (dimensions.left || 0);
      return this;
    };
    /**
      * returns an object of screen dimensions
      * @returns {{ dualScreenLeft: Number, dualScreenTop: Number, width: Number, height: Number }}
    */


    this.getScreenDimensions = function () {
      var usesScreenForDimensions = $window.hasOwnProperty('screen') && $window.screen.hasOwnProperty('screenTop'),
          dualScreenLeft,
          dualScreenTop;

      if (usesScreenForDimensions) {
        dualScreenLeft = $window.screen.left;
        dualScreenTop = $window.screen.top;
      } else {
        dualScreenLeft = $window.screenLeft;
        dualScreenTop = $window.screenTop;
      }

      return {
        dualScreenLeft: dualScreenLeft || 0,
        dualScreenTop: dualScreenTop || 0,
        width: $window.innerWidth || $window.screen.width,
        height: $window.innerHeight || $window.screen.height
      };
    };
    /**
     * returns an object of numbers used for positioning a new window
     * @param {Number} newWidth - the current window's width
     * @param {Number} newHeight - the current window's height
     * @returns {Object}
     */


    this.position = function (newWidth, newHeight) {
      var dimensions = popupService.getScreenDimensions();
      this.left = Math.floor(Math.max(dimensions.width / 2 - newWidth / 2 + dimensions.dualScreenLeft, 0));
      this.top = Math.floor(Math.max(dimensions.height / 2 - newHeight / 2 + dimensions.dualScreenTop, 0));
      return this;
    };
    /**
     * create a social media popup!
     * @param {string} popupClass
     * @param {string} handle
     * @param {string} url
     */


    this.popWindow = function (popupClass, handle, url) {
      var Position = popupService.position,
          Params = popupService.params,
          opts = {},
          dims = {},
          networkLabelMap = {
        facebook: 'Facebook',
        twitter: 'Twitter',
        pinterest: 'Pinterest',
        gplus: 'Google+'
      },
          args,
          features;
      opts.url = url;
      opts.name = 'Follow ' + handle + ' on ' + networkLabelMap[popupClass];
      dims.w = _get(popupService.popupDimensions, popupClass + '.w');
      dims.h = _get(popupService.popupDimensions, popupClass + '.h');
      features = new Position(dims.w, dims.h);
      dims.left = features.left;
      dims.top = features.top;
      args = new Params(opts, dims);
      window.open(args.address, args.name, args.features);
    };
  }

  _createClass(service, [{
    key: "stubFakeWindow",
    value: function stubFakeWindow(fakeWindow) {
      $window = typeof window !== 'undefined' ? window : fakeWindow;
    }
  }]);

  return service;
}();

module.exports = new service();
}, {"32":32,"33":33,"71":71}];
window.modules["191"] = [function(require,module,exports){'use strict';

var productSubtags = require(36),
    _includes = require(33),
    thirdParty = require(78),
    bamxDomain = 'shop-links.co/';
/**
 * Handle product url clicks
 * @param {string} productUrl
 * @param {string} eventType
 * @returns {function}
 */


function handleBuyClick(productUrl, eventType) {
  return function () {
    if (window.fbq) {
      window.fbq('trackCustom', eventType, {
        domain: productUrl
      });
    }
  };
}
/**
 * Append third-party ecomm scripts to the page
 * @param {string} productUrl
 * @param {boolean} includeNarrativ
 */


function attachThirdPartyScripts(productUrl) {
  var includeNarrativ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var isAmazon = _includes(productUrl, 'amazon.com/'),
      amazonOnetagId = '74e5d3e9-e5c4-4fa2-85e4-0e43ae3f0f84',
      amazonOnetagSrc = "z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=".concat(amazonOnetagId),
      bamxSrc = 'static.bam-x.com/tags/nymag.js';

  if (isAmazon) {
    thirdParty.includeScript(amazonOnetagSrc, 2500);
  }

  if (_includes(productUrl, bamxDomain) || includeNarrativ) {
    thirdParty.includeScript(bamxSrc);
  }
}
/**
 * Handle behavior universal to all product links
 * @param {Element} buyLink
 * @param {object} visitState
 */


function initLink(buyLink, visitState) {
  var productUrl = buyLink && buyLink.href,
      // not `getAttribute`, because want resolved url
  // dynamic narrativ links have the class 'narrativ-link'
  isNarrativeSecondBuyButton = buyLink.classList.contains('narrativ-link');

  if (productUrl) {
    if (_includes(productUrl, bamxDomain)) {
      // indicate that affiliate id's should not be added by `components/affiliate-links/client.js`
      buyLink.setAttribute('data-affiliate-links-ignore', 'true');
    } // add click handler


    buyLink.addEventListener('click', handleBuyClick(productUrl, 'Click-Out')); // handle right clicks event

    buyLink.addEventListener('contextmenu', handleBuyClick(productUrl, 'Click-Out-Right')); // add/extend amazon subtag with client-side params

    productSubtags.ensureSubtag(buyLink, visitState);
    attachThirdPartyScripts(productUrl, isNarrativeSecondBuyButton);
  }
}

module.exports.initLink = initLink;
}, {"33":33,"36":36,"78":78}];
window.modules["36"] = [function(require,module,exports){'use strict';
/**
 * ========
 * Overview
 * ========
 *
 * This service creates subtag query params for product links, for affiliates such as
 * Amazon, Rakuten, and Shareasale
 *
 * At the time of its creation, this service is used by the product components and by the gtm service for inline links
 *
 */

var dom = require(1),
    querystring = require(171),
    _memoize = require(35),
    _includes = require(33),
    _map = require(37),
    _mapValues = require(178),
    _reduce = require(124),
    _assign = require(57),
    _get = require(32),
    _pickBy = require(59),
    _find = require(71),
    page = require(116),
    affiliateSettings = {
  amazon: {
    domains: ['amazon.com'],
    subtagKey: 'ascsubtag',
    fields: ['siteShortKey', 'pageUri', 'productId', 'deviceAbbreviation', 'utmSource', 'utmMedium', 'utmCampaign', 'referrer', 'zone'],
    maxLength: 99
  },
  rakuten: {
    domains: ['click.linksynergy.com/deeplink'],
    subtagKey: 'u1',
    fields: ['siteShortKey', 'pageUri', 'productId', 'deviceAbbreviation', 'zone'],
    maxLength: 72
  },
  shareasale: {
    domains: ['shareasale.com'],
    subtagKey: 'afftrack',
    fields: ['siteShortKey', 'pageUri', 'productId', 'deviceAbbreviation', 'utmSource', 'utmMedium', 'utmCampaign', 'referrer', 'zone'],
    maxLength: 99
  }
},
    // really wish we did not need to hard-code this here
internalHosts = ['nymag.com', 'vulture.com', 'grubstreet.com', 'thecut.com'],
    gtm = dom.find('.gtm'),
    _siteShortKey = gtm && gtm.getAttribute('data-site-short-key'),
    shortenedPageUri = shortenUri(page.getPageUri()),
    getters = {
  siteShortKey: function siteShortKey() {
    return _siteShortKey;
  },
  pageUri: function pageUri() {
    return shortenedPageUri;
  },
  productId: function productId(_ref) {
    var productLink = _ref.productLink;
    return productLink && productLink.getAttribute('data-track-id');
  },
  deviceAbbreviation: _memoize(function (_ref2) {
    var visitState = _ref2.visitState;
    return guessDeviceAbbreviation(visitState.os, visitState.screenWidth);
  }),
  utmSource: _memoize(function (_ref3) {
    var visitState = _ref3.visitState;
    return (visitState.utm_source || '').substr(0, 3);
  }),
  utmMedium: _memoize(function (_ref4) {
    var visitState = _ref4.visitState;
    return (visitState.utm_medium || '').substr(0, 2);
  }),
  utmCampaign: _memoize(function (_ref5) {
    var visitState = _ref5.visitState;
    return (visitState.utm_campaign || '').substr(0, 17);
  }),
  referrer: _memoize(function (_ref6) {
    var visitState = _ref6.visitState;
    return shortenReferrer(visitState.referrer);
  }),
  zone: function zone(_ref7) {
    var productLink = _ref7.productLink;
    return getPageZone(productLink);
  }
},
    zoneAttr = 'data-track-zone',
    generateSubtagParser = _memoize(function (value) {
  var escapeValue = value.replace(/\[/, '\\[').replace(/\]/, '\\]'),
      exp = new RegExp(escapeValue + '[^\[]+');
  return function (subtag) {
    var match = subtag.match(exp); // remove delimiter (e.g. '[p]') from match

    return match && match[0].replace(new RegExp(escapeValue), '');
  };
}),
    // Mapping between subtag property and subtag key
// NOTE: order of properties here dictates order in the subtag string itself
// Any changes here should be documented in /_components/product/schema.yml description
subtagDictionary = {
  siteShortKey: '[]',
  pageUri: '[p]',
  productId: '[i]',
  zone: '[z]',
  deviceAbbreviation: '[d]',
  utmSource: '[s]',
  utmMedium: '[m]',
  utmCampaign: '[c]',
  referrer: '[r]' // referrer at the end in case need to truncate

};
/**
 *
 * @param {string} os
 * @param {number} width
 * @returns {string} one letter string to indicate device
 */


function guessDeviceAbbreviation(os, width) {
  /* eslint complexity: [2, 20] */
  // yes, this is "complex", but is best effort.
  switch (os) {
    case 'Windows Phone':
    case 'iOS':
    case 'Android':
    case 'BlackBerry':
      return width < 728 ? 'M' : 'T';

    case 'Linux':
    case 'Windows':
    case 'Mac OS X':
      return 'D';

    default:
      if (width < 728) {
        return 'M';
      }

      return width > 1024 ? 'D' : 'T';
  }
}
/**
 * retrieve page zone containing the product-link
 * @param {string} el
 * @returns {string} one letter string to indicate device
 */


function getPageZone(el) {
  var zone = dom.closest(el, '[' + zoneAttr + ']'),
      zoneStr = zone && zone.getAttribute(zoneAttr) || '';
  return zoneStr.substr(0, 1);
}
/**
 * removes the `www.` from host
 * @param {string} host - lowercase string
 * @returns {string}
 */


function shortenHost(host) {
  return host.substr(0, 4) === 'www.' ? host.substr(4) : host;
}
/**
 * shortens referrer to shortest usable string:
 *  removes www.
 *  keeps rest of host
 *  keeps first directory in path
 *  removes query and hash
 *  host and path are separated by `/`
 * @param {string} [referrer]
 * @returns {string} defaults to empty string if no referrer found
 */


function shortenReferrer(referrer) {
  var parts = referrer && referrer.match(/\/\/([^\/]+)(\/[^\/#?]+)?/),
      shortenedReferrer = '',
      formattedHost,
      firstDirectory;

  if (parts) {
    formattedHost = shortenHost(parts[1] || '').toLowerCase();
    firstDirectory = parts[2] || '';
    shortenedReferrer = formattedHost + (_includes(internalHosts, formattedHost) ? firstDirectory : '');
  }

  return shortenedReferrer;
}
/**
 * shortens uri to shortest usable string:
 *  reduce to instance key
 *  replace `ambrose-` with `a-`
 *  removes `@published` version
 * @param {string} [uri]
 * @returns {string}
 */


function shortenUri(uri) {
  return (uri || '').split('/').pop().replace('ambrose-', 'a-').replace('@published', '');
}
/**
 * parses a product link subtag and returns data as an object
 * @param {string} [subtag]
 * @returns {object}
 */


function parseSubtag(subtag) {
  return _mapValues(subtagDictionary, function (value) {
    var parseValueFromSubtag = generateSubtagParser(value);
    return parseValueFromSubtag(subtag);
  });
}
/**
 * generate subtag string based on fixed property names
 * @param {object} subtagData
 * @param {object} subTagDictionary
 * @returns {string}
 */


function generateSubtag(subtagData, subTagDictionary) {
  return _reduce(subtagData, function (result, value, key) {
    return result += value ? subTagDictionary[key] + value : '';
  }, '');
}
/**
 * return subtag string, truncated to 99 characters as needed
 * @param {string} subtag
 * @param {number} length
 * @returns {string}
 */


function applySubtagMaxlength(subtag, length) {
  var maxLength = length - 3 * (subtag.split(',').length - 1 + subtag.split('|').length - 1);
  return subtag.substr(0, maxLength);
}
/**
 * generate subtag data
 * @param {array} fields
 * @param {Object} obj
 * @param {Object} obj.visitState
 * @param {Element} obj.productLink
 * @returns {Object}
 */


function getSubtagData(_ref8) {
  var _ref8$fields = _ref8.fields,
      fields = _ref8$fields === void 0 ? [] : _ref8$fields,
      visitState = _ref8.visitState,
      productLink = _ref8.productLink;
  var obj = {};
  fields.forEach(function (field) {
    obj[field] = getters[field] && getters[field]({
      visitState: visitState,
      productLink: productLink
    });
  });
  return obj;
}
/**
 * append or extend product tracking subtag
 * @param {Object} obj
 * @param {string} obj.affiliate
 * @param {Element} obj.productLink
 * @param {Object} obj.visitState
 */


function processSubtag(_ref9) {
  var affiliate = _ref9.affiliate,
      productLink = _ref9.productLink,
      _ref9$visitState = _ref9.visitState,
      visitState = _ref9$visitState === void 0 ? {} : _ref9$visitState;

  var url = productLink.href || '',
      fields = _get(affiliateSettings[affiliate], 'fields'),
      subtagKey = _get(affiliateSettings[affiliate], 'subtagKey'),
      maxLength = _get(affiliateSettings[affiliate], 'maxLength');

  var query = url.indexOf('?') >= 0 ? url.split('?').pop() : '',
      queryData = querystring.parse(query),
      subtagData = getSubtagData({
    fields: fields,
    visitState: visitState,
    productLink: productLink
  }),
      subtagString;

  if (subtagKey) {
    subtagString = queryData[subtagKey] || '';
    subtagData = _assign(parseSubtag(subtagString), _pickBy(subtagData));
    subtagString = generateSubtag(subtagData, subtagDictionary);
    queryData[subtagKey] = applySubtagMaxlength(subtagString, maxLength);
    query = _map(queryData, function (value, key) {
      return "".concat(key, "=").concat(value);
    }).join('&');
    productLink.search = query ? "?".concat(query) : '';
  }
}
/**
 * Return affiliate matching product link
 * @param {Element} productLink
 * @returns {string}
 */


function getAffiliate(productLink) {
  var href = _get(productLink, 'href', '').toLowerCase(),
      affiliates = Object.keys(affiliateSettings);

  return _find(affiliates, function (affiliate) {
    return _find(affiliateSettings[affiliate].domains, function (domain) {
      return href.includes(domain);
    });
  }) || '';
}
/**
 * add or extend subtag on amazon and narrativ links
 * server-side subtag params will be augmented by client-side params
 * @param {Element} [productLink]
 * @param {object} [visitState]
 */


function ensureSubtag(productLink, visitState) {
  var affiliate = getAffiliate(productLink);

  if (affiliate) {
    processSubtag({
      productLink: productLink,
      visitState: visitState,
      affiliate: affiliate
    });
  }
}

module.exports.guessDeviceAbbreviation = guessDeviceAbbreviation;
module.exports.shortenUri = shortenUri;
module.exports.getPageZone = getPageZone;
module.exports.generateSubtag = generateSubtag;
module.exports.ensureSubtag = ensureSubtag; // exports for testing

module.exports.processSubtag = processSubtag;
module.exports.getAffiliate = getAffiliate;
}, {"1":1,"32":32,"33":33,"35":35,"37":37,"57":57,"59":59,"71":71,"116":116,"124":124,"171":171,"178":178}];
window.modules["90"] = [function(require,module,exports){'use strict';

var createDOMPurify = require(525); // Sanitizes HTML to prevent XSS attacks; see https://github.com/cure53/DOMPurify


module.exports = createDOMPurify(window).sanitize;
}, {"525":525}];
window.modules["53"] = [function(require,module,exports){(function (process,__filename){
'use strict';
/* A NOTE ON VARIABLE HEIGHT RENDITIONS
 * Mediaplay will use the smallest dimension to resize images when you specify `nocrop`,
 * so we can set the variable dimension to the Int32 maximum and it will always work.
 * Ideally, mediaplay would be able to resize an image without us specifying
 * both width and height, but that's currently unsupported.
 */

var _initial = require(898),
    _includes = require(33),
    _isString = require(164),
    _isNumber = require(159),
    _get = require(32),
    rest = require(5),
    log = require(81).setup({
  file: __filename
}),
    x2 = '2x',
    x1 = '1x',
    MAX_HEADROOM = 2147483647,
    renditions = {
  square: {
    w: 536,
    h: 536,
    r: x2
  },
  'square-1x': {
    w: 536,
    h: 536,
    r: x1
  },
  'square-medium': {
    w: 190,
    h: 190,
    r: x2
  },
  'square-medium-newsletter': {
    w: 600,
    h: 600,
    r: x1
  },
  'square-medium-zoom-small': {
    w: 768,
    h: 768,
    r: x2
  },
  'square-medium-zoom-medium': {
    w: 1180,
    h: 1180,
    r: x2
  },
  'square-medium-zoom-large': {
    w: 1280,
    h: 1280,
    r: x2
  },
  'square-small': {
    w: 168,
    h: 168,
    r: x2
  },
  'square-small-newsletter': {
    w: 100,
    h: 100,
    r: x1
  },
  'square-xsmall': {
    w: 63,
    h: 63,
    r: x2
  },
  'square-twitter-logo': {
    w: 125,
    h: 125,
    r: x2
  },
  // used to brand logos twitter:image meta tags
  thumb: {
    w: 215,
    h: 143,
    r: x2
  },
  'thumb-small': {
    w: 168,
    h: 115,
    r: x2
  },
  'thumb-zoom-small': {
    w: 768,
    h: 511,
    r: x2
  },
  'thumb-zoom-medium': {
    w: 1180,
    h: 785,
    r: x2
  },
  'thumb-zoom-large': {
    w: 1280,
    h: 851,
    r: x2
  },
  horizontal: {
    w: 710,
    h: 473,
    r: x2
  },
  'horizontal-zoom-small': {
    w: 768,
    h: 512,
    r: x2
  },
  'horizontal-zoom-medium': {
    w: 1180,
    h: 786,
    r: x2
  },
  'horizontal-zoom-large': {
    w: 1280,
    h: 853,
    r: x2
  },
  'horizontal-small': {
    w: 146,
    h: 97,
    r: x2
  },
  'horizontal-less-medium': {
    w: 235,
    h: 156,
    r: x2
  },
  'horizontal-medium': {
    w: 280,
    h: 157,
    r: x2
  },
  'horizontal-largeish': {
    w: 560,
    h: 314,
    r: x2
  },
  'horizontal-large': {
    w: 610,
    h: 410,
    r: x2
  },
  'horizontal-tags': {
    w: 190,
    h: 126,
    r: x2
  },
  'feature-lede': {
    w: 512,
    h: 600,
    r: x2
  },
  'og:image': {
    w: 1200,
    h: 630,
    r: x1
  },
  // special rendition for og:images, explicitly 1x
  'twitter:image': {
    w: 600,
    h: 315,
    r: x2
  },
  // special rendition for twitter:image meta data
  vertical: {
    w: 536,
    h: 804,
    r: x2
  },
  // deprecated: photo wants to only use 'flex' for large vertical images
  'vertical-small': {
    w: 245,
    h: 368,
    r: x2
  },
  'vertical-small-zoom-small': {
    w: 768,
    h: 1154,
    r: x2
  },
  'vertical-small-zoom-medium': {
    w: 1180,
    h: 1772,
    r: x2
  },
  'vertical-small-zoom-large': {
    w: 1280,
    h: 1923,
    r: x2
  },
  'vertical-subscription': {
    w: 47,
    h: 61,
    r: x2
  },
  // image-newfeed-lede and image-newsfeed-secondary component renditions:
  'newsfeed-lede-large': {
    w: 670,
    h: 670,
    r: x2
  },
  'travel-large-newsfeed-lede': {
    w: 670,
    h: 670,
    r: x2
  },
  'newsfeed-lede-small': {
    w: 300,
    h: 200,
    r: x2
  },
  'newsfeed-square-small': {
    w: 320,
    h: 320,
    r: x2
  },
  'newsfeed-horizontal-large': {
    w: 670,
    h: 450,
    r: x2
  },
  'travel-small-newsfeed-lede': {
    w: 300,
    h: 200,
    r: x2
  },
  // special renditions:
  flex: {
    w: 710,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-zoom-small': {
    w: 768,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-zoom-medium': {
    w: 1180,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-zoom-large': {
    w: 1280,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-large': {
    w: 1024,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-large-zoom-small': {
    w: 768,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-large-zoom-medium': {
    w: 1180,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-large-zoom-large': {
    w: 1280,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-xxsmall': {
    w: 335,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-xxsmall-zoom-small': {
    w: 768,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-xxsmall-zoom-medium': {
    w: 1180,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-xxsmall-zoom-large': {
    w: 1280,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-small': {
    w: 426,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-small-zoom-small': {
    w: 768,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-small-zoom-medium': {
    w: 1180,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-small-zoom-large': {
    w: 1280,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium-small': {
    w: 512,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium-small-zoom-small': {
    w: 768,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium-small-zoom-medium': {
    w: 1180,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium-small-zoom-large': {
    w: 1280,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium': {
    w: 670,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium-zoom-small': {
    w: 768,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium-zoom-medium': {
    w: 1180,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium-zoom-large': {
    w: 1280,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium-large': {
    w: 800,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium-large-zoom-small': {
    w: 768,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium-large-zoom-medium': {
    w: 1180,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-medium-large-zoom-large': {
    w: 1280,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-xlarge': {
    w: 1600,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-xlarge-zoom-small': {
    w: 768,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-xlarge-zoom-medium': {
    w: 1180,
    h: MAX_HEADROOM,
    r: x2
  },
  'flex-xlarge-zoom-large': {
    w: 1280,
    h: MAX_HEADROOM,
    r: x2
  },
  'vertical-small-variable': {
    w: 250,
    h: MAX_HEADROOM,
    r: x2
  },
  // not currently used (might be in the future!)
  'silo-image': {
    w: 200,
    h: 300,
    r: x2
  },
  'travel-horizontal-large': {
    w: 670,
    h: 450
  },
  'travel-square-small': {
    w: 320,
    h: 320
  },
  'cut-section-vid': {
    w: 336,
    h: 255,
    r: x2
  },
  // original:                original image w/h
  'cut-hp-square-1x': {
    w: 600,
    h: 600,
    r: x1
  },
  'cut-hp-square-2x': {
    w: 600,
    h: 600,
    r: x2
  },
  // homepage components:
  'homepage-article-promo-small-small': {
    w: 727,
    h: 727,
    r: x2
  },
  'homepage-article-promo-small-medium': {
    w: 180,
    h: 180,
    r: x2
  },
  'homepage-article-promo-small-large': {
    w: 240,
    h: 240,
    r: x2
  },
  'homepage-article-promo-package-small': {
    w: 727,
    h: 727,
    r: x2
  },
  'homepage-article-promo-package-medium': {
    w: 200,
    h: 200,
    r: x2
  },
  'homepage-article-promo-package-large': {
    w: 300,
    h: 300,
    r: x2
  },
  'homepage-article-promo-medium-small': {
    w: 727,
    h: 727,
    r: x2
  },
  'homepage-article-promo-medium-medium': {
    w: 240,
    h: 240,
    r: x2
  },
  'homepage-article-promo-medium-large': {
    w: 340,
    h: 340,
    r: x2
  },
  'homepage-article-promo-large-small': {
    w: 727,
    h: 727,
    r: x2
  },
  'homepage-article-promo-large-medium': {
    w: 300,
    h: 300,
    r: x2
  },
  'homepage-article-promo-large-large': {
    w: 380,
    h: 380,
    r: x2
  },
  'homepage-article-promo-xlarge-small': {
    w: 727,
    h: 727,
    r: x2
  },
  'homepage-article-promo-xlarge-medium': {
    w: 300,
    h: 300,
    r: x2
  },
  'homepage-article-promo-xlarge-large': {
    w: 480,
    h: 480,
    r: x2
  },
  'homepage-article-promo-huge-small': {
    w: 727,
    h: 727,
    r: x2
  },
  'homepage-article-promo-huge-medium': {
    w: 340,
    h: 340,
    r: x2
  },
  'homepage-article-promo-huge-large': {
    w: 560,
    h: 560,
    r: x2
  },
  'homepage-article-promo-lede-small': {
    w: 727,
    h: 933,
    r: x2
  },
  'homepage-article-promo-lede-medium': {
    w: 300,
    h: 300,
    r: x2
  },
  'homepage-article-promo-lede-large': {
    w: 480,
    h: 480,
    r: x2
  },
  'homepage-article-promo-video-small': {
    w: 727,
    h: 555,
    r: x2
  },
  'homepage-article-promo-section-small': {
    w: 727,
    h: 727,
    r: x2
  },
  'homepage-article-promo-section-medium': {
    w: 300,
    h: 300,
    r: x2
  },
  'homepage-article-promo-section-large': {
    w: 430,
    h: 430,
    r: x2
  },
  'homepage-excerpt': {
    w: 255,
    h: 255,
    r: x2
  },
  'homepage-top-lede-small': {
    w: 335,
    h: 430,
    r: x2
  },
  'homepage-top-lede-medium': {
    w: 640,
    h: 640,
    r: x2
  },
  'homepage-article-bar': {
    w: 220,
    h: 220,
    r: x1
  },
  // the mediaplay server is having issues with delays in 2x renditions when a specific rendition is manually uploaded, so we're setting this to use a 1x rendition
  'fashion-show': {
    w: 180,
    h: 270,
    r: x2
  },
  'listing-media': {
    w: 710,
    h: 475,
    r: x2
  },
  'issue-promo': {
    w: 183,
    h: 235,
    r: x2
  },
  'homepage-top-lede-section': {
    w: 620,
    h: 620,
    r: x2
  },
  'img-gal-mobile-grid-lg': {
    w: 384,
    h: 577,
    r: x2
  },
  'img-gal-mobile-grid-sm': {
    w: 384,
    h: 384,
    r: x2
  },
  'img-gal-tablet-grid-lg': {
    w: 590,
    h: 886,
    r: x2
  },
  'img-gal-tablet-grid-sm': {
    w: 590,
    h: 590,
    r: x2
  },
  'img-gal-desktop-grid-lg': {
    w: 300,
    h: 450,
    r: x2
  },
  'img-gal-desktop-grid-sm': {
    w: 300,
    h: 300,
    r: x2
  },
  'img-gal-mobile-list-vertical': {
    w: 768,
    h: 1154,
    r: x2
  },
  'img-gal-mobile-list-square': {
    w: 768,
    h: 768,
    r: x2
  },
  'img-gal-desktop-list-vertical': {
    w: 450,
    h: 676,
    r: x2
  },
  'img-gal-desktop-list-horizontal': {
    w: 807,
    h: 539,
    r: x2
  },
  'content-feed-article-small-small': {
    w: 135,
    h: 95,
    r: x2
  },
  'content-feed-article-small-medium': {
    w: 180,
    h: 108,
    r: x2
  },
  'content-feed-article-small-large': {
    w: 195,
    h: 130,
    r: x2
  },
  'content-feed-article-medium-small': {
    w: 135,
    h: 95,
    r: x2
  },
  'content-feed-article-medium-medium': {
    w: 180,
    h: 108,
    r: x2
  },
  'content-feed-article-medium-large': {
    w: 275,
    h: 185,
    r: x2
  },
  'content-feed-article-large-small': {
    w: 135,
    h: 95,
    r: x2
  },
  'content-feed-article-large-medium': {
    w: 180,
    h: 108,
    r: x2
  },
  'content-feed-article-large-large': {
    w: 410,
    h: 275,
    r: x2
  },
  'content-feed-article-lede-small': {
    w: 712,
    h: 474,
    r: x2
  },
  'content-feed-article-lede-medium': {
    w: 830,
    h: 553,
    r: x2
  },
  'content-feed-article-lede-large': {
    w: 570,
    h: 383,
    r: x2
  },
  'tv-show-small': {
    w: 600,
    h: 400,
    r: x2
  },
  'tv-show-medium': {
    w: 350,
    h: 235,
    r: x2
  },
  'tv-show-large': {
    w: 350,
    h: 235,
    r: x2
  },
  // newsletter email rendering
  'newsletter-horizontal': {
    w: 600,
    h: 358,
    r: x2
  },
  'newsletter-horizontal-medium': {
    w: 275,
    h: 164,
    r: x2
  },
  'newsletter-horizontal-large': {
    w: 335,
    h: 221,
    r: x2
  },
  'newsletter-horizontal-large-alt': {
    w: 335,
    h: 200,
    r: x2
  },
  'newsletter-square-small': {
    w: 100,
    h: 100,
    r: x2
  },
  'newsletter-square-medium': {
    w: 275,
    h: 275,
    r: x2
  },
  'newsletter-square-large': {
    w: 335,
    h: 335,
    r: x2
  },
  'newsletter-flex': {
    w: 600,
    h: MAX_HEADROOM,
    r: x2
  },
  // amp lede renditions
  'amp-lede-horizontal': {
    w: 500,
    h: 400,
    r: x2
  },
  'amp-lede-vertical': {
    w: 400,
    h: 500,
    r: x2
  },
  // new article stuff
  'inset-square': {
    w: 330,
    h: 330,
    r: x2
  },
  'inset-vertical': {
    w: 330,
    h: 412,
    r: x2
  },
  'inline-square': {
    w: 700,
    h: 700,
    r: x2
  },
  'inline-vertical': {
    w: 600,
    h: 750,
    r: x2
  },
  'inline-horizontal': {
    w: 700,
    h: 467,
    r: x2
  },
  'feature-horizontal': {
    w: 1100,
    h: 733,
    r: x2
  },
  'feature-vertical': {
    w: 570,
    h: 712,
    r: x2
  },
  'feature-square': {
    w: 700,
    h: 700,
    r: x2
  },
  'special-feature-horizontal': {
    w: 1100,
    h: 733,
    r: x2
  },
  'special-feature-vertical': {
    w: 570,
    h: 712,
    r: x2
  },
  'special-feature-square': {
    w: 700,
    h: 700,
    r: x2
  },
  'article-details_vertical-logo': {
    w: 120,
    h: 150,
    r: x2
  },
  'article-details_author': {
    w: 120,
    h: 150,
    r: x2
  },
  'article-details_horizontal-logo': {
    w: 200,
    h: 50,
    r: x2
  },
  // nym-image-collection renditions
  'nym-image-collection-square': {
    w: 570,
    h: 570,
    r: x2
  },
  'nym-image-collection-horizontal': {
    w: 700,
    h: 467,
    r: x2
  },
  'nym-image-collection-horizontal-break-out': {
    w: 900,
    h: 600,
    r: x2
  },
  'nym-image-collection-vertical': {
    w: 460,
    h: 575,
    r: x2
  },
  'nym-image-collection-deep-vertical': {
    w: 460,
    h: 690,
    r: x2
  },
  'nym-image-collection-flex': {
    w: 710,
    h: MAX_HEADROOM,
    r: x2
  },
  'nym-image-collection-flex-break-out': {
    w: 900,
    h: MAX_HEADROOM,
    r: x2
  },
  // curated-feed renditions
  'curated-feed-article-feature': {
    w: 640,
    h: 320,
    r: x2
  },
  'curated-feed-article-feature-large': {
    w: 880,
    h: 440,
    r: x2
  },
  'curated-feed-article-large': {
    w: 420,
    h: 279,
    r: x2
  },
  'curated-feed-image-post': {
    w: 600,
    h: 400,
    r: x2
  }
},
    variableRenditions = [// note: there will be more of these when we add slideshow renditions
'flex', 'flex-large', 'flex-small', 'flex-xxsmall', 'flex-medium-small', 'flex-medium', 'flex-medium-large', 'flex-xlarge', 'vertical-small-variable', 'newsletter-flex', 'nym-image-collection-flex', 'nym-image-collection-flex-break-out'],
    originalRenditions = ['original', 'full-bleed'],
    defaultRendition = renditions.horizontal,
    unit = 'px';
/**
 * format the width, height, and pixel-depth for media play URL
 * @param {{w: number, h: number, r: string}} dimensions
 * @returns {string}
 */


function addDimensions(dimensions) {
  if (dimensions.r === '2x') {
    return '.w' + dimensions.w + '.h' + dimensions.h + '.' + dimensions.r;
  } else {
    return '.w' + dimensions.w + '.h' + dimensions.h;
  }
}
/**
 * format the crop status for media play URL (defaults to true)
 * @param {boolean} crop
 * @returns {string}
 */


function addCrop(crop) {
  if (crop === false) {
    // if crop is EXPLICITLY false
    return '.nocrop';
  } else {
    // if crop is undefined, or true
    return '';
  }
}
/**
 * Remove width, height, cropping, and resolution from media-play url.
 * @param {string} url
 * @returns {string}
 */


function cleanUrl(url) {
  return url.replace('http://', 'https://').replace(/\.w\d+/i, '') // remove width
  .replace(/\.h\d+/i, '') // remove height
  .replace(/\.\dx/, '') // remove dimensions
  .replace(/\.nocrop/, ''); // remove cropping
}
/**
 * Get the file extension from full URL.
 * @param {string} url
 * @returns {string}
 */


function getExt(url) {
  return '.' + url.split('.').pop();
}
/**
 * Get the file name from full URL.
 * @param {string} url
 * @returns {string}
 */


function getInitial(url) {
  return _initial(cleanUrl(url).split('.')).join('.');
}
/**
 * Get the file name from full URL.
 * @param {string} url
 * @param {{w: number, h: number}} dimensions
 * @param {boolean} crop
 * @returns {string}
 */


function getRenditionUrl(url, dimensions, crop) {
  if (!dimensions || !dimensions.w || !dimensions.h) {
    if (dimensions && dimensions.w && !dimensions.h && !crop) {
      // If we have everything but height and aren't cropping, set to max height
      dimensions.h = MAX_HEADROOM;
    } else {
      throw new Error('Dimensions required for media play.');
    }
  }

  return getInitial(url) + addCrop(crop) + addDimensions(dimensions) + getExt(url);
}

function isMediaPlay(url) {
  return _includes(url, 'pixel') || _includes(url, 'mediaplay');
}

function isInvalidUrl(url) {
  return !_isString(url) || !url.length;
}
/**
 * get a url for a named rendition
 * @param {string} url
 * @param {string} [renditionName=defaultRendition]
 * @returns {string}
 */


function getRendition(url, renditionName) {
  if (isInvalidUrl(url) || !isMediaPlay(url)) {
    return '';
  } else if (!renditionName) {
    // default to horizontal rendition
    return getRenditionUrl(url, defaultRendition);
  } else if (_includes(originalRenditions, renditionName)) {
    // get the original url without any dimensions
    return cleanUrl(url);
  } else if (_includes(variableRenditions, renditionName)) {
    // get rendition, and DO NOT crop
    return getRenditionUrl(url, renditions[renditionName], false);
  } else if (renditions[renditionName]) {
    // get named rendition
    return getRenditionUrl(url, renditions[renditionName]);
  } else {
    // if they ask for a rendition that doesn't exist, fail hard
    throw new Error('No dimensions found for rendition "' + renditionName + '"');
  }
}
/**
 * get a url for an unnamed rendition by passing in the required dimensions
 * @param {string} url
 * @param {number} width
 * @param {number} height
 * @param {boolean} doubleDensity
 * @returns {string}
 */


function getDynamicRendition(url, width, height, doubleDensity) {
  if (isInvalidUrl(url) || !isMediaPlay(url)) {
    return '';
  }

  if (isNaN(parseInt(width, 10)) || isNaN(parseInt(height, 10))) {
    return '';
  }

  return getRenditionUrl(url, {
    w: parseInt(width, 10),
    h: parseInt(height, 10),
    r: doubleDensity ? x2 : x1
  });
}
/**
 *  get a url that keeps 'nocrop' in string if
 * present in origianl URL and zoomActive is true
 * defaults to original img url for older images
 * @param {string} url
 * @param {string} [renditionName=defaultRendition]
 * @param {Boolean} zoomActive should be used only for zoom renditions
 * @returns {string}
 */


function getRenditionZoom(url, renditionName, zoomActive) {
  var endRes = getRendition(url, renditionName),
      testPttrn = /nocrop\.w[0-9]+\.h/i,
      wdthPttrn = /\.w[0-9]+\.h/;

  if (zoomActive && testPttrn.test(url) && !testPttrn.test(endRes)) {
    endRes = endRes.replace(wdthPttrn, '.nocrop$&');
  }

  return endRes || url;
}
/**
 * @param {string} renditionName
 * @param {number} [adjustment=0]
 * @returns {string}
 */


function getRenditionWidth(renditionName, adjustment) {
  adjustment = _isNumber(adjustment) && parseFloat(adjustment) || 0;

  if (!renditionName) {
    return defaultRendition.w + adjustment + unit;
  } else if (_includes(originalRenditions, renditionName)) {
    return '';
  } else if (_includes(variableRenditions, renditionName)) {
    throw new Error('We currently do not support variable height images.');
  } else if (renditions[renditionName]) {
    // get named rendition
    return renditions[renditionName].w + adjustment + unit;
  } else {
    // if they ask for a rendition that doesn't exist, fail hard
    throw new Error('No dimensions found for rendition "' + renditionName + '"');
  }
}
/**
 * @param {string} renditionName
 * @param {number} [adjustment=0]
 * @returns {string}
 */


function getRenditionHeight(renditionName, adjustment) {
  adjustment = _isNumber(adjustment) && parseFloat(adjustment) || 0;

  if (!renditionName) {
    return defaultRendition.h + adjustment + unit;
  } else if (_includes(originalRenditions, renditionName)) {
    return '';
  } else if (_includes(variableRenditions, renditionName)) {
    throw new Error('We currently do not support variable height images.');
  } else if (renditions[renditionName]) {
    // get named rendition
    return renditions[renditionName].h + adjustment + unit;
  } else {
    // if they ask for a rendition that doesn't exist, fail hard
    throw new Error('No dimensions found for rendition "' + renditionName + '"');
  }
}
/**
 * transform a mediaplay url into a path we can call the api with
 * note: this is the same as the `mediaplayUrl` transform in magic-button
 * @param {string} url
 * @returns {string}
 */


function getImgPath(url) {
  var path = url.replace(/^.*?imgs\//, ''); // remove domain and everything up to imgs/
  // remove rendition stuff

  var barePath = path.replace(/\.w\d+/, ''); // remove width

  barePath = barePath.replace(/\.h\d+/, ''); // remove height

  barePath = barePath.replace('.2x', ''); // remove resolution

  barePath = barePath.replace('.nocrop', ''); // remove cropping

  return barePath;
}
/**
 * generate clay credit from mediaplay credit, credit url, and copyright/source
 * @param {string} credit
 * @param {string} creditUrl
 * @param {string} source
 * @returns {string}
 */


function generateCredit(credit, creditUrl, source) {
  var finalCredit = ''; // figure out credit + source

  if (credit && source) {
    // first, trim the source off of the credit, in case it was manually added there
    // this prevents double-sources
    finalCredit = credit.replace("/".concat(source), ''); // then, append the source to the credit

    finalCredit += "/".concat(source);
  } else if (credit) {
    finalCredit = credit;
  } else if (source) {
    // we almost never have a situation with just the source,
    // but we should handle this scenario just in case
    finalCredit = source;
  } // figure out credit url


  if (finalCredit && creditUrl) {
    // wrap the whole credit+source in a link
    finalCredit = "<a href=\"".concat(creditUrl, "\" target=\"_blank\" title=\"").concat(finalCredit, "\">").concat(finalCredit, "</a>");
  }

  return finalCredit;
}
/**
 * get the credit for a mediaplay image, from the image url
 * @param {string} url
 * @returns {Promise}
 */


function getMediaplayMetadata(url) {
  var metadata = {},
      metaCredit,
      metaCreditUrl,
      metaSource;
  metadata.imageType = '';
  metadata.credit = '';

  if (!isInvalidUrl(url)) {
    return rest.get(window.process.env.AMBROSE_HOST + '/content/assets/images/' + getImgPath(url)).then(function (res) {
      metaCredit = _get(res, 'metadata.credit') || '';
      metaCreditUrl = _get(res, 'metadata.creditUrl') || '';
      metaSource = _get(res, 'metadata.copyright') || '';
      metadata.imageType = _get(res, 'metadata.photoType') || '';
      metadata.credit = generateCredit(metaCredit, metaCreditUrl, metaSource);
      metadata.dimensions = res.dimension || {};
      return metadata;
    }).catch(function (error) {
      log('error', 'Failed to retrieve mediaplay metadata', {
        url: url,
        message: error && error.message,
        error: error,
        ambrosePath: window.process.env.AMBROSE_HOST + '/content/assets/images/' + getImgPath(url)
      });
      return metadata;
    });
  } else {
    return Promise.resolve(metadata);
  }
}
/**
 * get the credit for a mediaplay image, from the image url
 * @param {string} url
 * @returns {Promise}
 */


function getRawMetadata(url) {
  if (!isInvalidUrl(url)) {
    return rest.get(window.process.env.AMBROSE_HOST + '/content/assets/images/' + getImgPath(url)).then(function (resp) {
      return resp.metadata;
    }).catch(function () {
      return {};
    });
  } else {
    return Promise.resolve({});
  }
}
/**
 * getRenditionWithoutPixelDensity
 *
 * because of the way code works, its much easier to remove the 2x from the url string than it is to add it (in the right place).
 * Hence we remove the resolution from a rendition for non-retina versions of an image with the same dimensions
 *
 * @param {String} url mediaplay image with resolution
 * @returns {String} url rendition url without resolution
 */


function getRenditionWithoutPixelDensity(url) {
  return url.replace(/\.\dx/, '');
}
/**
 * Get the rendition aspect ratio; useful if fitting within constrained space
 * @param {string} [renditionName=defaultRendition]
 * @returns {number}
 */


function getRenditionAspectRatio(renditionName) {
  var rendition = renditions[renditionName] || defaultRendition;
  return Math.round(rendition.w / rendition.h * 100) / 100;
}

function getCalculatedRenditionDimensionsFromMetadata(renditionName, metadata) {
  var data = {};

  if (_includes(variableRenditions, renditionName)) {
    var srcWidth = _get(metadata, 'dimensions.width', null),
        srcHeight = _get(metadata, 'dimensions.height', null),
        renditionWidth = _get(renditions, "".concat(renditionName, ".w"), null);

    if (srcWidth && srcHeight && renditionWidth) {
      data.width = renditionWidth;
      data.height = Math.floor(renditionWidth * srcHeight / srcWidth);
      data.ratio = srcWidth / srcHeight * 100;
    } else {
      data.width = null;
      data.height = null;
      data.ratio = null;
    }
  } else {
    if (_includes(originalRenditions, renditionName)) {
      data.width = _get(metadata, 'dimensions.width', null);
      data.height = _get(metadata, 'dimensions.height', null);
    } else {
      var width = parseInt(getRenditionWidth(renditionName).replace('px', '')),
          height = parseInt(getRenditionHeight(renditionName).replace('px', ''));
      data.width = width;
      data.height = height;
    }

    data.ratio = null;
  }

  return data;
} // for use by components, the `rendition` filter, and any services that need it


module.exports.isMediaPlay = isMediaPlay;
module.exports.getMediaplayMetadata = getMediaplayMetadata;
module.exports.getRawMetadata = getRawMetadata;
module.exports.getRendition = getRendition;
module.exports.getRenditionAspectRatio = getRenditionAspectRatio;
module.exports.getRenditionWidth = getRenditionWidth;
module.exports.getRenditionHeight = getRenditionHeight;
module.exports.getRenditionZoom = getRenditionZoom;
module.exports.getRenditionWithoutPixelDensity = getRenditionWithoutPixelDensity;
module.exports.getDynamicRendition = getDynamicRendition;
module.exports.getCalculatedRenditionDimensionsFromMetadata = getCalculatedRenditionDimensionsFromMetadata;
module.exports.cleanUrl = cleanUrl;
module.exports.getImgPath = getImgPath; // for testing

module.exports.getRenditionUrl = getRenditionUrl; // for testing and referencing renditions in other internal modules

module.exports.renditions = renditions;
module.exports.variableRenditions = variableRenditions;
module.exports.originalRenditions = originalRenditions;

}).call(this,require(22),"/services/universal/media-play.js")}, {"5":5,"22":22,"32":32,"33":33,"81":81,"159":159,"164":164,"898":898}];
window.modules["1266"] = [function(require,module,exports){'use strict';

var dateFormat = require(52),
    sitePaths = {
  // if a site uses folders for each day (YYYY/MM/DD/) we'll open the current day
  // if a site has a custom prefix, we'll use that
  // otherwise, if a site is on this list, we'll use 'daily/<slug>' as the folder prefix
  // for sites not on this list, we'll just open the daily/ folder
  strategist: {
    date: true // true if it uses the /YYYY/MM/DD/ folder structure
    // note: no prefix means this'll use 'daily/<slug>/YYYY/MM/DD/'

  },
  vindicated: {
    date: true,
    prefix: 'daily/strategist' // custom (not daily/<slug>/) folder
    // note: will prefix and date, this'll use 'daily/strategist/YYYY/MM/DD/'

  },
  vulture: {
    date: true
  },
  selectall: {
    date: true
  },
  scienceofus: {
    date: true,
    prefix: 'daily/science'
  },
  di: {
    date: true,
    prefix: 'daily/intelligencer'
  },
  intelligencer: {
    date: true,
    prefix: 'daily/intelligencer'
  },
  thecut: {
    date: true,
    prefix: 'fashion/daily'
  },
  wwwthecut: {
    date: true,
    prefix: 'fashion/daily'
  },
  grubstreet: {
    date: true,
    prefix: 'daily/grub'
  },
  nyxny: true,
  // no daily folders, just use 'daily/<slug>/'
  betamale: {
    date: true
  },
  press: {
    date: true
  },
  speed: {
    date: true
  },
  thejob: {
    date: true,
    prefix: 'daily/the-job'
  }
};
/**
 * get site path
 * @param  {string} slug
 * @return {string}
 */


function getSitePath(slug) {
  var sitePath = sitePaths[slug];

  if (sitePath && sitePath.date) {
    var now = dateFormat(new Date(), 'YYYY/MM/DD');
    return "".concat(getSitePrefix(sitePath, slug), "/").concat(now);
  } else if (sitePath) {
    // go to prefix or slug folder
    return getSitePrefix(sitePath, slug);
  } else {
    return 'daily';
  }
}
/**
 * get site prefix / slug folder
 * @param  {object|boolean} sitePath
 * @param  {string} slug
 * @return {string}
 */


function getSitePrefix(sitePath, slug) {
  if (sitePath.prefix) {
    return sitePath.prefix;
  } else {
    return "daily/".concat(slug);
  }
}

module.exports.getSitePath = getSitePath;
}, {"52":52}];
window.modules["48"] = [function(require,module,exports){'use strict';

var _get = require(32),
    _require = require(43),
    getSiteRootHost = _require.getSiteRootHost;
/**
 * The parsely "site id" is also referred to as the "api key"
 * Most of the time is is the root hostname, with a couple of exceptions below
 * @param {object} locals
 * @returns {string}
 */


function getParselySiteId(locals) {
  var rootHost = getSiteRootHost(locals),
      sitePath = _get(locals, 'site.path', '');

  if (rootHost === 'nymag.com' && (sitePath === '/intelligencer' || sitePath === '/strategist')) {
    return "".concat(sitePath.substr(1), ".").concat(rootHost);
  }

  return rootHost;
}

module.exports.getParselySiteId = getParselySiteId;
}, {"32":32,"43":43}];
window.modules["176"] = [function(require,module,exports){'use strict';

var smartyPants = require(1180).smartypants;
/**
 * replaces all pretty quotes added by typogr
 * @param {string} str
 * @param {string} newSubstr
 * @returns {{quoteMarksFound: number, updatedString: string}}
 */


function removeQuoteEntities(str, newSubstr) {
  // keeping span in regex to support instances previously saved
  // TODO: write an upgrade.js files to update data for components previously saved -Jon
  var smartQuoteRegExp = /^(|"|&quot;|&#8220;|<span class="dquo">(&#8220;|)<\/span>)|(|"|&quot;|&#8221;)$/ig,
      quoteMarksFound = 0,
      updatedString = str.replace(smartQuoteRegExp, function () {
    return ++quoteMarksFound && newSubstr;
  });
  return {
    quoteMarksFound: quoteMarksFound,
    updatedString: updatedString
  };
}
/**
 * removes old typogrify and adds new pretty quotes (HTML entity)
 * @param {string} string
 * @returns {string}
 */


function quotesToEntities(string) {
  return smartyPants(removeQuoteEntities(string, '"').updatedString);
}
/**
 * checks if a string has the right # of quote marks
 * quotes need to be a setting so that they can be styled
 * @param {string} string
 * @returns {boolean}
 */


function hasQuoteMarks(string) {
  var _removeQuoteEntities = removeQuoteEntities(string, ''),
      quoteMarksFound = _removeQuoteEntities.quoteMarksFound;

  if (quoteMarksFound === 2) {
    return true;
  } else {
    return false;
  }
}

;
module.exports.removeQuoteEntities = removeQuoteEntities;
module.exports.quotesToEntities = quotesToEntities;
module.exports.hasQuoteMarks = hasQuoteMarks;
}, {"1180":1180}];
window.modules["77"] = [function(require,module,exports){(function (process,__filename){
'use strict';

var queryService = require(49),
    escapeStringRegExp = require(558),
    rest = require(5),
    log = require(81).setup({
  file: __filename
}),
    utils = require(43),
    db = require(69),
    amazonProducts = require(1270),
    _require = require(43),
    urlToCanonicalUrl = _require.urlToCanonicalUrl,
    _require2 = require(56),
    isPage = _require2.isPage,
    _get = require(32),
    _uniqBy = require(913),
    _pick = require(174),
    _pickBy = require(59),
    _merge = require(904),
    _min = require(905),
    _set = require(87),
    _cloneDeep = require(47),
    urlParse = require(235).parse,
    randomString = require(917),
    indexName = '*-products',
    queryBody = {
  sort: [{
    // `_index` is the index name, therefore sorting alphabetically desc,
    // will give us `published-products` before `editable-products`
    _index: {
      order: 'desc'
    }
  }, {
    // unpublished/editable products may have instances where products with the same URL have different IDs
    // sorting by creationDate ensures that the same id is always returned before saving published version
    // fifo
    creationDate: {
      order: 'asc'
    }
  }]
},
    productComponentInstancesPath = '/_components/product/instances',
    idCreationTryLimit = 10,
    syncFields = ['productId', 'priceLow', 'salePrice', 'salePercentage', 'offerCode', 'upc'],
    AMAZON_PRODUCT_QUERY_LIMIT = typeof window.process.env.AMZN_PAAPI_LIMIT === 'undefined' ? 10 : window.process.env.AMZN_PAAPI_LIMIT;
/**
 * check our index for an existing product id based off of the product url
 * first check the published-products and then check the editable-products
 * editable-products is required so that we can handle products saved in a page publish batch
 * @param {string} url
 * @param {object} locals
 * @returns {Promise.<string|undefined>}
 */


function getProductIdFromUrl(url, locals) {
  var productIdPath = 'hits.hits[0]._source.productId';
  var query = queryService(indexName, locals);
  query.body = queryBody;
  query.body.query = {
    term: {
      buyUrl: url // returns all products that have matching buyUrl

    }
  };
  return queryService.searchByQueryWithRawResult(query, {
    uniqueKey: "getProductIdFromUrl:".concat(urlToCanonicalUrl(url))
  }, locals, false).then(function (results) {
    return _get(results, productIdPath);
  }).catch(function (err) {
    return log('debug', "product doesn't exist: ".concat(productIdPath), {
      error: err.message
    });
  });
}
/**
 * Zero hits returned means there were no matches
 * @param {object} results - results from elastic search
 * @returns {boolean}
 */


function matchFound(results) {
  return _get(results, 'hits.total', 0) !== 0;
}
/**
 * check to see whether or not a product id exists in the index already
 * first try the published products and then the editable products
 * @param {string} productId
 * @param {object} locals
 * @returns {Promise.<boolean>}
 */


function doesIndexContainId(productId, locals) {
  var query = queryService(indexName, locals);
  query.body = queryBody;
  query.body.query = {
    term: {
      productId: productId
    }
  };
  return queryService.searchByQueryWithRawResult(query, {
    uniqueKey: "doesIndexContainId:".concat(productId)
  }, locals, false).then(matchFound).catch(function (err) {
    return log('debug', "product id doesn't exist: ".concat(productId), {
      error: err.message
    });
  });
}
/**
 * creates a new product component instance and returns its data
 * @param {object} productLink
 * @param {string} productLink.url
 * @param {string} productLink.text
 * @param {object} locals
 * @returns {Promise.<{name: string, buyUrl: string, vendor: string, id: string}>}
 */


function createProduct(productLink, locals) {
  var productData = {
    name: productLink.text,
    buyUrl: productLink.url,
    buyUrlHistory: [productLink.url],
    vendor: 'Amazon' // productId and creationDate are handled by model.js

  };
  return rest.post(utils.getSiteBaseUrl(locals) + productComponentInstancesPath, productData, true).then(function (product) {
    var publishedUri = utils.uriToUrl(product._ref + '@published', locals);
    delete product._ref;
    return rest.put(publishedUri, product, true);
  }).catch(function (err) {
    log('error', "error creating product instance from link ".concat(productLink.url), {
      error: err.message
    });
    throw err; // do not swallow error
  });
}
/**
 * for a given product url, get or create a product id
 * @param {object} product
 * @param {object} locals
 * @returns {[Promise.<{url: string, text: string, productId: string}>]}
 */


function addProductIdToProduct(product, locals) {
  var url = product.url;

  if (url) {
    return getProductIdFromUrl(url, locals).then(function (existingProductIdFromUrl) {
      return existingProductIdFromUrl || createProduct(product, locals).then(function (productData) {
        return productData.productId;
      });
    }).then(function (productId) {
      product.productId = productId;
      return product;
    }).catch(function (e) {
      throw new Error("Error occurred while retrieving product entry from elastic: ".concat(e));
    });
  }

  return product;
}
/**
 * for all of the urls, get or create a product id
 * @param {object} urls - keys are urls and values are the link text
 * @param {object} locals
 * @returns {[Promise.<{url: string, text: string, productId: string}>]}
 */


function mapUrlsToProducts(urls, locals) {
  return Object.keys(urls).map(function (url) {
    var product = {
      url: url,
      text: urls[url],
      productId: '',
      amazonSubtag: ''
    };
    return addProductIdToProduct(product, locals).then(addAmazonSubtagToProduct.bind(null, product, locals));
  });
}
/**
 * checks if the link is pointing to amazon.com and allows for sub-domains
 * @param {string} url
 * @returns {boolean}
 */


function isAmazonUrl(url) {
  var domain = (url.split('://')[1] || '').split('/')[0].toLowerCase();
  return domain.indexOf('amazon.com') === 0 || domain.indexOf('.amazon.com') > 0;
}
/**
 * checks if the link is associated with Narrativ
 * @param {string} url
 * @returns {boolean}
 */


function isNarrativUrl(url) {
  var domain = (url.split('://')[1] || '').split('/')[0].toLowerCase();
  return domain.indexOf('shop-links.co') > -1;
}
/**
 * find all of the amazon links in the text and return link url and link text
 * @param {string} text
 * @returns {object} keys are urls and values are the link text
 */


function reduceToUniqueAmazonUrls(text) {
  // assume `href` is first attribute of anchor
  return text.split('<a href="').reduce(function (urls, anchorFragment) {
    // assume no html tags within anchor text
    // assume href surrounded by quotes, but could have other attributes
    var anchorClose = anchorFragment.indexOf('>'),
        anchor = anchorFragment.substr(0, anchorClose),
        anchorEndQuote = anchor.indexOf('" '),
        url = anchorEndQuote > -1 ? anchor.substr(0, anchorEndQuote) : anchor.substr(0, anchor.length - 1),
        linkText = anchorFragment.substr(anchorClose + 1).split('</a>')[0];

    if (isAmazonUrl(url)) {
      urls[url] = linkText;
    }

    return urls;
  }, {});
}
/**
 * remove ambrose prefix and @published suffix from uri
 * @param {string} uri
 * @returns {string}
 */


function shortenUri(uri) {
  return (uri || '').split('/').pop().replace('ambrose-', 'a-').replace('@published', '');
}
/**
 *
 * @param {object} data
 * @param {object} locals
 * @returns {Promise.<object>}
 */


function addAmazonLinkTrackingAttributes(data, locals) {
  var text = data.text || '',
      urls = reduceToUniqueAmazonUrls(text),
      products = mapUrlsToProducts(urls, locals);
  return Promise.all(products).then(function (products) {
    data.text = products.reduce(function (text, product) {
      var buyUrlWithSubtag = generateBuyUrlWithSubtag(product.url, product.productId, locals),
          productLinksWithoutAttributes = new RegExp("<a href=\"".concat(escapeStringRegExp(product.url), "\"[^>]*"), 'g'),
          productLinkWithAttributes = "<a href=\"".concat(buyUrlWithSubtag, "\" data-track-type=\"product-link\" data-track-id=\"").concat(product.productId, "\"");
      return text.replace(productLinksWithoutAttributes, productLinkWithAttributes);
    }, data.text);
    return data;
  });
}
/**
 * Adds an amazon subtag key-value pair to the product data object
 * @param {object} data
 * @param {object} locals
 * @returns {object}
 */


function addAmazonSubtagToProduct(data, locals) {
  data.amazonSubtag = generateAmazonSubtag(data.productId, locals);
  return data;
}
/**
 * Generate an amazon subtag using productId and locals
 * Note: the key-value pairs appended here are limited to what can be appended server-side,
 * and will be extended clientside by the `amazon` DS service
 * Any changes to the subtag schema should be documented in /_components/product/schema.yml description
 * @param {string} productId
 * @param {object} locals
 * @returns {string}
 */


function generateAmazonSubtag(productId, locals) {
  var siteShortKey = _get(locals, 'site.shortKey'),
      pageUri = _get(locals, 'url'); // nullify pageUri if exists on layout level
  // (instead determine client-side)


  if (pageUri && !isPage(pageUri)) {
    pageUri = null;
  }

  return (siteShortKey ? '[]' + siteShortKey : '') + (pageUri ? '[p]' + shortenUri(pageUri) : '') + (productId ? '[i]' + productId : '');
}
/**
 * Return a matching subtag key for a given product link
 * @param {string} buyUrl
 * @returns {string}
 */


function getSubtagKey(buyUrl) {
  if (isAmazonUrl(buyUrl || '')) {
    return 'ascsubtag';
  } else if (isNarrativUrl(buyUrl || '')) {
    return 'u1';
  }

  return '';
}
/**
 * Generate a buy url with amazon subtag and site tag appended
 * @param {string} buyUrl
 * @param {string} productId
 * @param {object} locals
 * @param {string} [amazonAssociateId] allows for amazon associate id other than standard site id
 * @returns {string}
 */


function generateBuyUrlWithSubtag(buyUrl, productId, locals, amazonAssociateId) {
  var amazonSubtag,
      buyUrlWithSubtag,
      hasSiteTag,
      hasSubtag,
      expr,
      subtagKey = getSubtagKey(buyUrl);

  if (subtagKey) {
    buyUrlWithSubtag = urlParse(buyUrl);
    buyUrlWithSubtag.search = buyUrlWithSubtag.search || '';
    amazonSubtag = generateAmazonSubtag(productId, locals);
    hasSubtag = buyUrlWithSubtag.search.indexOf("".concat(subtagKey, "=")) > -1;
    hasSiteTag = buyUrlWithSubtag.search.match(/[?&]tag=/);
    amazonAssociateId = amazonAssociateId || getSiteAmazonAssociateId(locals);

    if (hasSubtag) {
      // replace user-provided amazon subtag with auto-generated subtag
      expr = new RegExp("".concat(subtagKey, "=[^&]+"));
      buyUrlWithSubtag.search = buyUrlWithSubtag.search.replace(expr, "".concat(subtagKey, "=").concat(amazonSubtag));
    } else {
      // append subtag query param to buy url
      buyUrlWithSubtag.search += (buyUrlWithSubtag.search ? '&' : '?') + "".concat(subtagKey, "=").concat(amazonSubtag);
    }

    if (amazonAssociateId && !hasSiteTag) {
      // append site tag to buy url
      buyUrlWithSubtag.search += '&tag=' + amazonAssociateId;
    }

    return buyUrlWithSubtag.format();
  }

  return '';
}
/**
 * Retrieve amazon site tag from locals
 * @param {object} locals
 * @returns {string}
 */


function getSiteAmazonAssociateId(locals) {
  return _get(locals, 'site.amazon', '');
}
/**
 * Generates a random 6-character id, checks if it exists
 * @param {object} locals
 * @returns {Promise.<string>}
 * @throws throws an error if a unique id cannot be generated after 10 tries
 */


function generateId(locals) {
  var count = 0;

  function tryNewId() {
    var dictionary = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789',
        productId = randomString(dictionary, 6);
    count += 1;

    if (count > idCreationTryLimit) {
      throw new Error("failed to generate unique product id after ".concat(idCreationTryLimit, " tries"));
    }

    return doesIndexContainId(productId, locals).then(function (indexContainsId) {
      return indexContainsId ? tryNewId() : // if true, the product id is used by another product, so try another id
      productId;
    }); // if false, the product id is NOT used by another product, so use the generated one
  }

  return tryNewId();
}
/**
 * Filters input array to contain only unique product instances
 * @param {array} productArray
 * @returns {array}
 */


function removeDuplicateProducts(productArray) {
  var amazonProductDelimiter = '\/(dp|gp\/product)\/',
      amazonDelimiterExp = new RegExp(amazonProductDelimiter),
      amazonProductExp = new RegExp(amazonProductDelimiter + '[^?\/]+'); // filter out products with the same image url

  productArray = _uniqBy(productArray, function (product) {
    return product.imageUrl;
  }); // filter out products with the same name

  productArray = _uniqBy(productArray, function (product) {
    return product.name;
  }); // filter out products with matching amazon product asin IDs
  // (/dp/[asin] or /gp/product/[asin] pattern)

  return _uniqBy(productArray, function (product) {
    var buyUrl = _get(product, 'buyUrl', ''),
        amazonMatch = _get(buyUrl.match(amazonProductExp), '[0]');

    return amazonMatch ? amazonMatch.replace(amazonDelimiterExp, '') : buyUrl;
  });
}
/**
 * Transform data parsed from Amazon Product API query
 * @param {Object} data
 * @returns {Object}
 */


function transformAmazonData(_ref) {
  var listPrice = _ref.listPrice,
      offerPrice = _ref.offerPrice,
      salePrice = _ref.salePrice,
      upc = _ref.upc;
  var saleThreshold = 0; // minimum price difference to be considered on sale

  var priceLow = _min([listPrice, offerPrice, salePrice]) || salePrice || listPrice || offerPrice,
      salePercentage; // apply sales logic

  if (listPrice - priceLow > saleThreshold) {
    salePrice = Math.round(priceLow);
    salePercentage = Math.round(100 * (listPrice - salePrice) / listPrice);
    priceLow = listPrice;
  } else if (listPrice && priceLow) {
    // unset sale price
    salePrice = '';
    salePercentage = '';
  }

  return _pickBy({
    priceLow: priceLow ? Math.round(priceLow) : undefined,
    salePrice: salePrice,
    salePercentage: salePercentage,
    upc: upc
  }, function (item) {
    return typeof item !== 'undefined';
  });
}
/**
 * merges overrideData into data on syncFields
 * @param {string} data
 * @param {string} overrideData
 * @returns {function}
 */


function mergeOnSyncFields(data, overrideData) {
  return _merge(data, _pick(overrideData, syncFields));
}
/**
 * Update product entity in redis
 * @param {string} uri
 * @param {object} originalData
 * @param {object} updateData
 * @returns {function}
 */


function updateProductEntity(uri, originalData, updateData) {
  var saveField = 'preSyncData',
      preSyncData = mergeOnSyncFields({}, originalData);

  if (!updateData.hasOwnProperty(saveField)) {
    updateData[saveField] = preSyncData;
  }

  log('debug', "updating product entity: ".concat(uri), updateData);
  return db.put(uri, JSON.stringify(updateData)).then(function () {
    return updateData;
  }).catch(function () {
    return updateData;
  });
}
/**
 * Either query amazon for most recent price data and merge that to product entity
 * or return existing product entity data from redis
 * @param {object} data
 * @returns {function}
 */


function getEntityData(data) {
  var timeLimit = 1000 * 60 * AMAZON_PRODUCT_QUERY_LIMIT,
      lastQueried = data.lastQueriedAmazon || 0,
      buyUrl = data.buyUrl,
      shouldQueryAmazon = isAmazonUrl(buyUrl) && Date.now() - lastQueried > timeLimit && !data.disableAmazonSync && amazonProducts.meetsCallThreshold();
  return function (productUri) {
    if (!productUri) {
      return Promise.resolve({});
    } // get product entity data


    return db.get(productUri).then(function (entityData) {
      return shouldQueryAmazon ? module.exports.syncDataFromAmazon(entityData, productUri) : entityData;
    }).catch(function () {
      return {};
    });
  };
}
/**
 * Retrieve data from amazon and merge into entityData,
 * and PUT modified data back to redis
 * @param {object} entityData
 * @param {string} productUri
 * @returns {Promise}
 */


function syncDataFromAmazon(entityData, productUri) {
  var buyUrl = entityData.buyUrl;
  amazonProducts.getProductDataFromAmazon(buyUrl).then(function (res) {
    log('debug', "successful amazon call: ".concat(productUri), res);
    return res;
  }).then(transformAmazonData).then(function (data) {
    return mergeOnSyncFields(_cloneDeep(entityData), data);
  }).then(function (data) {
    return _set(data, 'lastQueriedAmazon', Date.now());
  }).then(function (data) {
    return updateProductEntity(productUri, entityData, data);
  }).catch(function (err) {
    // promise is rejected but err is an empty if AMZN_PAAPI_TIMEOUT is 0
    if (err !== 'Amazon Sync Disabled') {
      log('warn', 'Error syncing data from Amazon Product API', {
        error: err.message
      });
    }

    return entityData;
  }); // to avoid stalling page render, allow the promise above to resolve in the background while	
  // returning entityData immediately

  return Promise.resolve(entityData);
}
/**
 * Check our index for a product document based on buyUrl.
 * The last-edited match on buyUrl is considered the canonic entity.
 * Returns the product URI, which is the key needed to get entity data from redis
 * @param {string} url
 * @param {object} locals
 * @returns {Promise.<object|undefined>}
 */


function getProductEntityUri(url, locals) {
  var productUriPath = 'hits.hits[0]._id'; // only match product entity from `published-products` index

  var query = queryService('published-products', locals); // retrieve most recently updated document

  queryService.addSort(query, {
    lastUpdated: 'desc'
  });
  queryService.addMust(query, {
    term: {
      buyUrl: url
    }
  });
  queryService.addSize(query, 1); // Splitting on the url to remove any query params/hash

  return queryService.searchByQueryWithRawResult(query, {
    uniqueKey: "getProductEntityUri:".concat(url)
  }, locals, false).then(function (results) {
    return _get(results, productUriPath) || '';
  }).catch(function (err) {
    log('debug', "product doesn't exist: ".concat(productUriPath), {
      error: err.message
    });
    return '';
  });
}
/**
 * Update select fields in `data` with values obtained for a matching document
 * in the product database
 * @param {object} data
 * @param {object} locals
 * @returns {Promise.<object|undefined>}
 */


function syncDataFromEntity(data, locals) {
  var url = data.buyUrl;

  if (!url) {
    return data;
  }

  return getProductEntityUri(url, locals).then(getEntityData(data)).then(function (res) {
    return _merge(data, _pick(res, syncFields));
  });
}

module.exports.addAmazonLinkTrackingAttributes = addAmazonLinkTrackingAttributes;
module.exports.generateBuyUrlWithSubtag = generateBuyUrlWithSubtag;
module.exports.generateId = generateId;
module.exports.getProductIdFromUrl = getProductIdFromUrl;
module.exports.isAmazonUrl = isAmazonUrl;
module.exports.addProductIdToProduct = addProductIdToProduct;
module.exports.removeDuplicateProducts = removeDuplicateProducts;
module.exports.getEntityData = getEntityData;
module.exports.syncDataFromEntity = syncDataFromEntity;
module.exports.getProductEntityUri = getProductEntityUri;
module.exports.syncDataFromAmazon = syncDataFromAmazon;
module.exports.transformAmazonData = transformAmazonData;
module.exports.updateProductEntity = updateProductEntity;

}).call(this,require(22),"/services/universal/products.js")}, {"5":5,"22":22,"32":32,"43":43,"47":47,"49":49,"56":56,"59":59,"69":69,"81":81,"87":87,"174":174,"235":235,"558":558,"904":904,"905":905,"913":913,"917":917,"1270":1270}];
window.modules["46"] = [function(require,module,exports){'use strict';
/**
 * bluebird.props with native promises
 * @param {object} props
 * @returns {Promise}
 */

module.exports.props = function (props) {
  return Promise.all(Object.keys(props).map(function (key) {
    return Promise.resolve(props[key]).then(function (res) {
      var one = {};
      one[key] = res;
      return one;
    });
  })).then(function (resolvedArray) {
    return resolvedArray.reduce(function (memo, oneRes) {
      var key = Object.keys(oneRes)[0];
      memo[key] = oneRes[key];
      return memo;
    }, {});
  });
};
/**
 * simple and easy promise timeout
 * @param  {Promise} promise
 * @param  {number} time    number of milliseconds to allow the promise to resolve
 * @return {Promise}
 */


module.exports.timeout = function (promise, time) {
  var timer = null;
  return Promise.race([new Promise(function (resolve, reject) {
    timer = setTimeout(reject, time, new Error('Timed out!'));
    return timer;
  }), promise.then(function (value) {
    clearTimeout(timer);
    return value;
  })]);
};
}, {}];
